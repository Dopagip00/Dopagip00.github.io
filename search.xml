<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>”JAVA--JDBC知识点“</title>
    <url>/2022/02/09/JAVA-JDBC%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>JDBC相当于一个驱动，让数据库和java打交道。</p>
<span id="more"></span>

<p>对于开发人员来说，只需要掌握JDBC接口的操作即可。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6cb5c95aa1fa076e8db6cc3bbedaf3e6.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>结构图，我们只需要学JDBC</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1f734dc4920ffa0e272fe890bfcf6492.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>记得先要导入jar包</p>
<h2 id="mysql-—-基本的操作"><a href="#mysql-—-基本的操作" class="headerlink" title="mysql — 基本的操作"></a><a href="https://dopagip.wordpress.com/2021/12/12/mysql-%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/">mysql — 基本的操作</a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--在sql里面所有的注释都用“--”,school是我们创建的数据库。</span><br><span class="line">show databases; --显示所有的数据库</span><br><span class="line"></span><br><span class="line">use school; --使用数据库</span><br><span class="line">change database</span><br><span class="line"></span><br><span class="line">use tables;  --显示所有的数据表</span><br><span class="line"></span><br><span class="line">desc tables; --显示数据库中所有表的信息</span><br><span class="line"></span><br><span class="line">create database &quot;school&quot;; --创建数据库</span><br><span class="line"></span><br><span class="line">exit; --退出mysql</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p><strong>数据库XX语言：</strong></p>
<p>DDL 定义</p>
<p>DML 操作</p>
<p>DQL 查询</p>
<p>DCL 控制</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>”JAVA--List接口“</title>
    <url>/2022/02/09/JAVA-List%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>List接口的特点：有序，有下标，元素可以重复</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c9cdc1cdd6f5c40143f331e073b1e6d5.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>方法</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0bedf789e0a4cd33aaa07ae2168acd44.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>添加和删除元素</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/19185e0b9483bfe1b38c34162844d34f.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>get方法用于获取对应下标的元素</p>
<p>使用迭代器的时候一定要创建对象：Iteration it = new Iteration();</p>
<p>列表迭代器ListIteration:</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/dcbd1ce79c18634b6492f4448bf5b888.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>ListIteration</p>
<p>判断和获取位置：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ca6817f90e6db3a22f8091e3658e58ab.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>List对象使用List.remove();括号里面填的是对应删除位置的下标，要删除对应元素要使用“”</p>
<p>subList方法：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6f314a747cf1a833d4c6d71055ca2ac7.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>subList</p>
<p>用来返回一个子集合，括号里面有两个数，逗号前面是集合开始的位置，后面是集合结束的位置。注意是含头不含尾的，左闭右开。</p>
<p><strong>List的类</strong>：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/de3ed4574c6a50d128b9bd4d3f3cdacb.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>Vector现在少用了，ArrayList用的多</p>
<p>ArrayList默认长度是0。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>”JAVA--Collec体系集合“</title>
    <url>/2022/02/09/JAVA-Collecting%E4%BD%93%E7%B3%BB%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p> Collect接口知识点总结</p>
<span id="more"></span>

<p><img src="https://img-blog.csdnimg.cn/img_convert/5888cfe5738f77ca7a81306dbae10536.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>rt</p>
<h2 id="Collect父接口"><a href="#Collect父接口" class="headerlink" title="Collect父接口"></a>Collect父接口</h2><p>特点：（有些）对象，无序，无下标，不能重复–&gt;对应着Set接口。</p>
<p>方法：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/3bf59b036ab708cfc76b85554f643deb.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>常用方法</p>
<p>iteration迭代器</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/58df797c645cb5fe3e3f7dbd39a89bc0.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>使用next()来用指针不断指向下一行</p>
<p>iteration要定义对象的：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/79b7331b81bc69966635494f587bc2a0.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>三个常用方法</p>
<p>遍历元素的方法：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5a9858fdff8876de3732ae53f9c65917.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p><strong>注意：</strong>在iteration里面不能使用collection.remove();来删除元素，要使用iteration(这是对象)来删除元素，iteration.remove()。</p>
<p>collection判断：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/80ec081de26e2bccf885c09c38fe3aba.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>使用contains方法进行判断，返回值是布朗类型的</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>”JAVA--properties类“</title>
    <url>/2022/02/09/JAVA-properties%E7%B1%BB/</url>
    <content><![CDATA[<p> properties相当于一个集合</p>
<span id="more"></span>

<p><img src="https://img-blog.csdnimg.cn/img_convert/d91d50beb656346ba65a174526fc43f6.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>setproperties在集合里面增加变量。</p>
<p>1.list方法适用于PrintWriter</p>
<p>2.store方法适用于FileOutputStream</p>
<p>3.load方法适用于FileInputStream</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>”JAVA--SringBuffer和StringBudilder“</title>
    <url>/2022/02/09/JAVA-SringBuffer%E5%92%8CStringBudilder/</url>
    <content><![CDATA[<p>这两个都是可变字符串.</p>
<span id="more"></span>

<p><strong>StringBuffer</strong>：</p>
<p>StringBuffer str = new StringBuffer();</p>
<p>可以使用append在后面追加字符串，用insert增加字符串</p>
<p>insert（“0”，str）在第0个字符的前面增加字符串str。</p>
<p><strong>用replace来更改指定位置字符：</strong></p>
<p>replace(“0”，“5”，str)把0-5之间的字符替换为str。</p>
<p>用<strong>delete删除指定位置的字符：</strong></p>
<p>delete（“0”，“5”）删除0-5之间的字符串。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>”JAVA--Sring声明“</title>
    <url>/2022/02/09/JAVA-Sring%E5%A3%B0%E6%98%8E/</url>
    <content><![CDATA[<p>引用类型的引用在栈里面，对象在堆里面。</p>
<span id="more"></span>

<p>字符串的字面值存储在字符串池中，可以实现共享。</p>
<p>String name = 20;//这里name存储在堆里面，20存储在方法池里面。</p>
<p>声明string字符串有两种方式：</p>
<p>1.String name = “Hellp”//产生一个对象，存储在字符串池中</p>
<p>2.String name = new String(“Hello”)//产生两个对象，在字符串池和堆中各存放一个</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>”JAVA--Sring方法“</title>
    <url>/2022/02/09/JAVA-Sring%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>一共十三点</p>
<p>1.length()：返回字符串长度。</p>
<p>2.charAt(number)：用于定点输出字符，记住从0开始计算，例如charAt(3)用来输出在字符串第四位的字符。</p>
<p>3.contains（”字符串”）：用于判断在大的字符串里面是否包含contains里面的字符串，如果包含返回true，不包含返回false。</p>
<p>4.toCharArray()：返回字符串对应的数组 。</p>
<p>5.indexOf()：返回子字符串首次出现的位置。可以indexOf(“***”，number)意思就是从第number个数字开始往后数。</p>
<p>6.lastIndexOf()：返回字符串最后一次出现的位置。</p>
<p>7.trim()：去掉在字符串之间存在的空格</p>
<p>8.toUpperCase()：把小写转换成大写，toLowerCase()：把大写转换成小写。</p>
<p>9.endWith(str)：判断是否已str结尾，是输出true，反之输出false。startsWith(str)判断是否str开头。</p>
<p>10.split(“分隔符”)：对字符串进行拆分，用for循环输出。如果要空格逗号都成为分隔符则用split([ ,])里面放空格和逗号。如果要多个空格成为分隔符则用split([ ]+)。</p>
<p>11.equal：比较两个字符串是否相等，如果内容相同但是大小写不同用字符串1.equalIgnoreCase(字符串2).</p>
<p>12.s3.compareTo(s4)：实现s3减s4，如果是字符串就用第一个字符的ASCII码相减，如果第一个字符相等就比较第二个。<code>String s1 = &quot;abc&quot;;</code>String s2 = “abcxyz”;前三个abc都相同，但是s1后面没有了，就用长度相减3-6 = -3；</p>
<p>13.replace(“a1”，“a2”)：用a2替换a1。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA--static关键字知识点</title>
    <url>/2022/02/09/JAVA-static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>1.有static修饰的属性就不用声明对象了，直接用类名去.属性</p>
<span id="more"></span>

<p>2.非静态方法能直接调用静态方法，但是静态方法不能调用非静态方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class GG&#123;</span><br><span class="line">    public void  A()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void B()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class 静态 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        GG.A();//不可行，因为A方法是非静态的</span><br><span class="line">        GG.B();//可行，因为B是静态的</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>介绍一些奇葩的代码块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class QIPA &#123;</span><br><span class="line">    &#123;//作用：赋初值；</span><br><span class="line">        System.out.println(&quot;匿名代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;//作用：只能执行一次</span><br><span class="line">        System.out.println(&quot;static代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public QIPA()&#123;</span><br><span class="line">        System.out.println(&quot;普通的代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        QIPA qipa = new QIPA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p><img src="https://img-blog.csdnimg.cn/2a0caa983f3c4678bad9caf60fa4296e.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 先执行static代码块，再执行匿名的代码块，在执行普通的代码块。（static代码块即使不定义对象也可以执行）</p>
<p>天秀操作：静态导入包（如我们想生成随机数）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.lang.math;//正常来说到这一步就不能往下了</span><br><span class="line">import static java.lang.math.random;//加个static就可以到下一步了，这叫静态调用包</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p><strong>子类不能继承被final继承的父类！</strong></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>”JAVA--外部类和内部类“</title>
    <url>/2022/02/09/JAVA-%E5%A4%96%E9%83%A8%E7%B1%BB%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<p> 介绍外部类和内部类</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package bilibili;</span><br><span class="line"></span><br><span class="line">class Oouter &#123;</span><br><span class="line">    class Inter &#123;</span><br><span class="line">        Inter() &#123;</span><br><span class="line">            System.out.println(&quot;这是内部类&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Outer&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Oouter oouter = new Oouter();</span><br><span class="line">        Oouter.Inter inter = oouter.new Inter();//这里最最重要</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">内部类的概念：在一个类的内部再定义一个完整的类，内部类也会生成class文件。但是有$符号。</span><br></pre></td></tr></table></figure>

<p>1.声明内部类的对象的方法是：</p>
<p><strong>外部类名(点)内部类名(空格)内部类对象 = 外部类对象(点)new(空格)内部类名（）；</strong></p>
<p>比如现在<strong>外部类名Outer，内部类名Inter，外部类对象outer，内部类对象inter</strong>，则：</p>
<p>Outer.Inter inter = outer.new Inter();</p>
<p>内部类可以调用外部类的私有属性，当然也可以调用外部私有方法，但是当内部类加上了static后就不能调用外部类的private属性了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private int a()&#123;</span><br><span class="line">    int a = 20;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">class Inter &#123;</span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.println(a());</span><br><span class="line">        System.out.println(&quot;这是内部类&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.局部内部类：在方法里面定义类；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.匿名内部类：没有名字的类：</span><br><span class="line">假设我们有一个类Apple，Apple里面有一个a方法，我们可以先不对Apple进行实例化，直接使用new Apple().a()来调用a方法.</span><br><span class="line">匿名内部类一般用在接口或者父类当中。</span><br><span class="line">匿名内部类必须在声明对象之后，然后在后面可以调用该匿名内部类的方法，该内部类是匿名的，然后要用声明的对象的名字。</span><br><span class="line">匿名内部类必须继承父类或者实现一个接口。</span><br></pre></td></tr></table></figure>

<p>4.静态内部类：不依赖外部类，可直接创建或通过类名访问，可声明静态成员。</p>
<p><strong>特点：</strong></p>
<p>1.在内部类中可以调用内部类的私有方法，但是调用外部类的私有方法用（外部类的对象）.私有名字。</p>
<p>2.只有外部类可以是静态的，内部类不行。</p>
<p>3.内部类想要访问局部变量，需要局部变量是final修饰的（局部变量即方法里面定义的变量）</p>
<p>4.内部类也可以继承接口用implements</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA--多态</title>
    <url>/2022/02/09/JAVA-%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<p><strong>如果子类没有重写父类方法，就调用父类的。</strong></p>
<p><strong>如果子类重写了父类，就算左边是父类，也是调用子类的重写方法。</strong></p>
<p><strong>调用父类时，可以调用子类中的重写方法，但是不能调用子类中独有的方法！！！</strong></p>
<span id="more"></span>

<p>对象执行哪些方法主要看左边，和右边关系不大<img src="https://img-blog.csdnimg.cn/9e24d298f81a470e90e67d4007b4f523.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>多态的注意事项：</p>
<p>1.多态是方法的多态，属性没有多态；</p>
<p>\2. 父类和子类之间有联系 离谱的类型转换肯定报错（如String转Person方法）类型转换异常：ClassCastException.</p>
<p>3.方法可以转换，同样遵循低转高原则（子类是低，父类是高），如果要高转低的话可以（子类）+方法名来实现。</p>
<p>4.存在条件：继承关系，方法需要重写，父类的引用指向子类（即在声明对象的时候父类在左边，子类在右边）</p>
<p>##但是有些方法是不能重写的：</p>
<p>1.static方法：属于类，不属于实例</p>
<p>2.final属性</p>
<p>3.private方法是私有的，当然重写了也没用</p>
<p>instanceof （类型转换） 引用类型</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>”JAVA--字符流知识点“</title>
    <url>/2022/02/09/JAVA-%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>在使用read读取字符流的时候，一点要在硬盘里面先创建要读取的文件，否则会报错。</p>
<span id="more"></span>

<p><strong>字符流和字节流的区别：字节流可以复制所有包括图片的文件，但是字符流只能复制文本文件，图片等文件都不能复制。</strong></p>
<p><strong>输入流（FileReader）：</strong></p>
<p>public int read(char[] c);从流中读取多个字符，将读到的内容存进c数组，返回读取到的字符数，如果到达文件的结尾，返回-1。</p>
<p>一种方法：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5a90bcd8900c6c6b86f4918742c563c0.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>另一种方法：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b26f776ef1dc56a1cd10c2f50b73c6d3.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p><strong>输出流（FileWriter）：</strong></p>
<p>public void write(String str):一次写入多个字符，将str中的所有字符全部写入输出流中。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7624a06874a9e5560ec895e884896a18.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>只能用for循环表示，while循环无法转换类型。</p>
<p>用FileWriter和FileReader复制文件：（只能复制文本文件，不能复制图片和声音视频等）</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ca3c56e7bb5938b65c0e17d26fe500d8.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>把read的内容复制粘贴到read1当中，利用了字符数组by</p>
<p><strong>复制图片文件？</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9b0880f0888663e401ee1f5c7a0bfcde.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>文件名字不一样，其他和上面一样。</p>
<p>结果会报错：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/99730c60bdecf8a9c918b73c61618110.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>WriterBuffered缓冲区和ReaderBuffered缓冲区:</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0c932e4142daa263933523eea841c51a.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>br.read()一次读取一个字符</p>
<p>没什么难度，和前面一样。</p>
<p>缓冲流的特点：</p>
<p>1.高效读写；2.支持输入换行符(bw.newline;)；3.可以一次写一行读一行。（用readline一次读取一行而不是一个字符。）</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2f6b2103d1048aa0da0f0683df50fba7.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>读取一行字符，以换行符为结尾。</p>
<p><strong>PrintWriter的使用：</strong>调用java.io.PrintWriter.</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ac542505b12931975133b1314d0ac37a.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>相当于直接用System.out来打印，可以使用print和println等等，记得close关闭.</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA--super知识点</title>
    <url>/2022/02/09/JAVA-super%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>1.Super指向父类的构造方法，必须在构造方法的第一个；</p>
<p>2.Super只能出现在子类的构造方法中.</p>
<span id="more"></span>

<p>3.this和super不能同时调用构造方法</p>
<p>与this的对比：<br>this：本类的构造；super：父类的构造</p>
<p>this：没有继承也可以使用；super：必须要有继承才可以使用</p>
<p>this：调用本身对象；super：调用父类对象</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>”JAVA--字符编码知识点“</title>
    <url>/2022/02/09/JAVA-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>介绍五种常用编码方式</p>
<span id="more"></span>

<p>ISO-8859-1 ：ASCII编码+西欧希腊等国的字符编码。</p>
<p>UTF-8：针对Unicode码的字符编码。</p>
<p>GBK ：简体中文。</p>
<p>GB312：简体中文。</p>
<p>BIG5：台湾，繁体中文。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>”JAVA--常用类“</title>
    <url>/2022/02/09/JAVA-%E5%B8%B8%E7%94%A8%E7%B1%BB/</url>
    <content><![CDATA[<p>介绍两个类：Date和Calendar</p>
<p><strong>一、Date表示特定的瞬间，精确到毫秒。</strong></p>
<p>1.创建date对象：</p>
<p>Date date=new Date();</p>
<p>2.一些方法：直接打印date：输出当前的时间。</p>
<p>打印date.getTime输出从1970.1.1到现在所有的毫秒数。</p>
<p>方法after和before:直接加一天。</p>
<p>compareTo方法，date1.toString(date2)，是date1-date2.</p>
<p>当然也可以用equal方法。</p>
<p><strong>二、Calendar类提供了获取各类日历字段的方法：(就是你代替了date类当中的许多方法)</strong></p>
<p>因为Calendar的构造方法是protected的，所以不能直接创建对象。要通过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();来设置Calendar对象。</span><br><span class="line">Calendar的方法很多，get最常见，int year = calendar.get(calendar.YEAR);这样输出的就是今年的年份了。</span><br><span class="line">int year = calendar.get(calendar.YEAR);</span><br><span class="line">int month = calendar.get(calendar.MONTH);</span><br><span class="line">int day = calendar.get(calendar.DAY_OF_WEEK);</span><br><span class="line">int hour = calendar.get(calendar.HOUR);</span><br><span class="line">int minute = calendar.get(calendar.MINUTE);</span><br><span class="line">int second = calendar.get(calendar.SECOND);</span><br><span class="line">这样分别定义了年，月，日，小时，分钟，秒。用get()方法!</span><br><span class="line">calendar.getActualMaximum()可以输出括号内的最大值，如calendar.getActualMaximum(Calendar.DAY_OF_MOUTH),可以输出月份的最大值30.</span><br><span class="line">同理calendar.getActualMinimum()</span><br></pre></td></tr></table></figure>

<p><strong>三、SimpleDateFormat类用于格式化解析日期：（import java.text.SimpleDateFormat）</strong></p>
<p>1.创建SimpleDateFormat对象：(Y：年，M:月，d：日，H：小时，m:分钟，s：秒)</p>
<p>SimpleDateFormat sim = new SimpleDateFormat(“YYYY年MM月dd日 HH:mm:ss”)</p>
<p>2.//创建date：</p>
<p>Date date = new Date();</p>
<p>//格式化date</p>
<p>String str = sim.format(date);</p>
<p>这时候再把str打印出来就可以得到—–2021年11月08日 10:27:08</p>
<p><strong>四、System类（很重要！）</strong></p>
<p>私有类，不需要创建对象，并且方法是静态的。</p>
<p>方法：</p>
<p><strong>1.arraycopy：用于复制数组</strong></p>
<p>arraycopy(src,srcPos,dest,destPos,length)有五个参数</p>
<p>//src:原数组，srcPos：从什么位置开始复制，dest：目标数组，destPos:目标数组的位置</p>
<p>要注意目标数组长度要大于等于原数组长度。</p>
<p><strong>2.currentTimeMillis：获取当前系统时间，返回毫秒值。</strong></p>
<p>可以用来计算程序执行的时间，在程序前面加个start在程序后面加个end。</p>
<p><strong>3.gc()：建议JVM使用垃圾回收器回收垃圾。</strong></p>
<p>用来回收不用的对象。</p>
<p>4.exit(int status)：退出JVM，参数是0表示正常退出，参数是-1表示异常退出。</p>
<p>在exit后面的语句当然就不执行了！</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA--封装</title>
    <url>/2022/02/09/JAVA-%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<p>1.<strong>高内聚，低耦合：</strong>程序内部的操作细节由自己或者内部人员完成，仅仅暴露少量内容给外部人员。</p>
<span id="more"></span>

<p>2.get/set 方法最重要：用get方法获得该值，用set方法给该值赋予数值,因为你的属性被private限制住了，只能通过其他方法输出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class AA&#123;</span><br><span class="line">    private int a=20;</span><br><span class="line">    public int geta()&#123;</span><br><span class="line">        return this.a;</span><br><span class="line">    &#125;</span><br><span class="line">    public void seta(int a)&#123;</span><br><span class="line">        this.a=a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class getset &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        AA aa = new AA();</span><br><span class="line">        //System.out.println(aa.a);这样写是错的，因为属性a被private限制了，只能在AA类中使用</span><br><span class="line">        //这时候就要使用set和get函数了</span><br><span class="line">        aa.seta(50);//这一步用来设置a的值</span><br><span class="line">        System.out.println(aa.geta());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>封装的作用：</p>
<p>1.提高程序的安全性，保护程序</p>
<p>2.统一接口（唯一接口只有get/set）</p>
<p>3.隐藏代码实现细节</p>
<p>4.系统的可维护性增加</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>”JAVA--拆箱和装箱，字符串数字转换“</title>
    <url>/2022/02/09/JAVA-%E6%8B%86%E7%AE%B1%E5%92%8C%E8%A3%85%E7%AE%B1%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>数据类型（int，float等等）存放在栈里面。</p>
<p>引用类型（Integer，Float等等）存放在堆里面 。</p>
<span id="more"></span>

<p>装箱就是 Java 将基本类型转换成对应的包装类型，比如将 int 转换成 Integer 对象。反之将 Integer 转换成 int 值，则称为拆箱。</p>
<p><strong>装箱:</strong></p>
<p>int num = 20;</p>
<p>Integer integer1 = num;</p>
<p>如上这样就可以实现装箱使int成为integer了。</p>
<p><strong>拆箱：</strong></p>
<p>int num2=integer;</p>
<p>这样就可以拆箱。</p>
<p>integer的范围是-128——127之间，超过这个范围会溢出</p>
<p><strong>字符串和数字之间的转换：</strong></p>
<p>int num = 20;</p>
<p>Integer integer = num;</p>
<p>String s = integer.tostring(num，10)//这里解释一下，tostring括号里面的num是要转换为字符串的数字，后面的10是转换为10进制的，当然也可以变成8/16转换成八进制十六进制。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>”JAVA--捕获异常“</title>
    <url>/2022/02/09/JAVA-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p> 捕获异常的知识点</p>
<span id="more"></span>

<p><img src="https://img-blog.csdnimg.cn/img_convert/9e2b02acb699d3e3244694956cb154e7.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>这个代码中b等于0，所以会报错，错误类型为ArithmeException，我们使用catch关键字可以捕获这个异常，并且输出语句，最后再用finally处理最后。</p>
<p>假设要捕获多个异常，从大到小。</p>
<p>抛出异常：（用throw 关键字抛出new一个新异常）</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/29d685470b9578cce9bfcfcd70d0c61f.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>”JAVA--抽象类“</title>
    <url>/2022/02/09/JAVA-%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
    <content><![CDATA[<p>抽象类的作用：如果我们不想在方法中写内容就用抽象类：abstract;</p>
<span id="more"></span>

<p>1.当子类继承的父类当中有抽象的方法时，子类必须要重写抽象方法</p>
<p>2.java里面的类是单继承的，但是接口时多继承的</p>
<p>3.不能new抽象类，只能靠子类去实现它（约束）</p>
<p>4.抽象方法必须在抽象类里面</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>”JAVA--接口interface“</title>
    <url>/2022/02/09/JAVA-%E6%8E%A5%E5%8F%A3interface/</url>
    <content><![CDATA[<p> 1.接口只有规范，无法写方法，是专业的抽象。实现约束和实现分离，面向接口编程。</p>
<span id="more"></span>

<p>2.接口就是规范，约束了编程的行为</p>
<p>写一个接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface jiekou &#123;//这是一个接口，下面实行增删改查</span><br><span class="line">    void insert();</span><br><span class="line">    void delete();</span><br><span class="line">    void update();</span><br><span class="line">    void select();</span><br><span class="line">    //上面的四个方法都是在接口里面的方法，固定为抽象方法，抽象的abstract可以省略，直接用返回值+方法名来定义方法即可；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>（抽象）类只能单继承，但是接口可以多继承，这就是接口的好处；</p>
<p>继承接口用关键字implement，格式为：class+类名+implement+接口名{}</p>
<p>实现了接口中的类就要重写接口中的方法，接口的多继承用逗号连接实现。</p>
<p>接口的作用</p>
<p><img src="https://img-blog.csdnimg.cn/9ec1434941764960bada7de63fcf34be.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>”JAVA--数据库操作“</title>
    <url>/2022/02/09/JAVA-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.创建数据库</span><br><span class="line">CREATE DATABASE [IF NOT EXISTS] school;</span><br><span class="line"></span><br><span class="line">2.使用数据库</span><br><span class="line">USE `school` --如果你的数据库是一个字段名称，则需要用到``</span><br><span class="line">USE school</span><br><span class="line"></span><br><span class="line">3.删除数据库</span><br><span class="line">DROP school</span><br><span class="line"></span><br><span class="line">4.查看数据库</span><br><span class="line">show school</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<span id="more"></span>

<p><strong>1.数据的类型：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/91af09cb3212396fd9c813d854b51273.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>数据类型</p>
<p><strong>2.字符的类型</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/56725a5990086f030065bd7f4d69e6ec.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p><strong>3.时间日期：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7deb7817956479929d635e146dd7daf1.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>时间和日期的表示</p>
<h2 id="数据库的字段属性（重点）"><a href="#数据库的字段属性（重点）" class="headerlink" title="数据库的字段属性（重点）"></a><strong>数据库的字段属性</strong>（重点）</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/c747df1e0837a93370d176c7069d4eda.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/8b083c9474eed9a88b4beffa3043cbfe.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>修改表数据：（所有修改表的操作都使用ALTER来操作）</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/70414dc25ff166f16d33a9daa0bef6fc.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d8784fef04c69c151654bbe73747730f.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>删除表的话用：DROP TABLE student;</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA--数组（基础）</title>
    <url>/2022/02/09/JAVA-%E6%95%B0%E7%BB%84%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/</url>
    <content><![CDATA[<p> <strong>有关数组的基础知识</strong></p>
<span id="more"></span>

<p><strong>两种给数组赋值的方法：</strong><br> 1.静态初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int num[] = &#123;1,2,3,4,5,6,7,8,9,10&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>这个的意思是在声明数组的过程中顺便给数组赋了值，称为静态初始化。但是这个静态初始化赋予数组的值并不是固定的，在后面也可以对其中一个元素进行变更。</p>
<p>2.动态初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int num[] = new int[5];</span><br><span class="line">num[0] = 1;</span><br><span class="line">num[1] = 2;</span><br><span class="line">num[2] = 3;</span><br><span class="line">num[3] = 4;</span><br><span class="line">num[4] = 5;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>像这样先使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int num[] = new int[5];</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>对数组num进行声明和创建（注意，这里数组的下标最多到达4，不能到5，因为是从0开始的，如果到达了5会运行错误，显示数组下标溢出）,然后在下面的代码中对num进行赋值。</p>
<p>数组越界异常警报是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Array Index Out Of Bounds Exception:数组下标越界</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p><strong>数组的四个基本特点：</strong></p>
<p>1.数组的长度是确定的，一旦数组被确定，它的长度就不能被更改。</p>
<p>2.数组的内容可以是所有的类型（基本类型和引用类型都可以），但是数组不能是多种类型的混合，只能是单独一种类型。</p>
<p>3.数组本身是在堆当中的。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA--方法重写</title>
    <url>/2022/02/09/JAVA-%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99/</url>
    <content><![CDATA[<p>方法的调用只和左边有关，即A a/B b</p>
<span id="more"></span>

<p><img src="https://img-blog.csdnimg.cn/e3ae7194364e47b2b5dd489751a7ae95.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFfNTI1OTk4NzA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>方法的重写不要用static，</p>
<p><img src="https://img-blog.csdnimg.cn/74ba5f5219e542c88cbe7cfa66795b61.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFfNTI1OTk4NzA=,size_13,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p><strong>因为b是A new出来的对象，因此调用了A的方法</strong></p>
<p><strong>因为静态方法是类的方法，而非静态是对象的方法</strong></p>
<p><strong>有static时，b调用了B类的方法，因为b是用b类定义的</strong></p>
<p><strong>没有static时，b调用的是对象的方法，而b是用A类new的</strong></p>
<p><strong>简单来说就是有static调用后面，没有static调用前面。</strong></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>”JAVA--方法盘点“</title>
    <url>/2022/02/09/JAVA-%E6%96%B9%E6%B3%95%E7%9B%98%E7%82%B9/</url>
    <content><![CDATA[<p>介绍四个方法</p>
<span id="more"></span>

<p><strong>getCalss()方法：</strong></p>
<p>1.使用方法:<strong>对象.getClass()</strong>;</p>
<p>2.有什么用：返回对象的内容，比如这个对象是A类的，那就返回A类给getClass()，返回的值是Class类型的。</p>
<p><strong>hashcode()方法：</strong></p>
<p>1.使用方法:<strong>对象.hashcode()</strong>;</p>
<p>2.返回一个值，哈希码的值实际上是对象的地址或者字符串之类的，所以相同对象返回相同哈希码。</p>
<p><strong>toString()方法</strong>：</p>
<p>1.其实也就是返回getclass和hashcode的合体，但是哈希值是十六进制的。</p>
<p>qeual方法：</p>
<p>return(this == 一个类对象)</p>
<p>System.out.println(s1.equal(s2)) #判断s1和s2对象是否相等。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/017447037a9afaba91fed9ca66807b05.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA--构造器</title>
    <url>/2022/02/09/JAVA-%E6%9E%84%E9%80%A0%E5%99%A8/</url>
    <content><![CDATA[<p> 定义一个构造器：（构造方法必须没有返回值）</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    public Person()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class void main(String[] args)&#123;</span><br><span class="line">    Person person = new Person();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>1.在类里面即使你什么都不写，都会存在一个构造器.</p>
<p>2.当我们在用new关键字创建一个新对象的时候，<strong>对象调用的一定是方法，而不是调用类！！这就是为什么即使什么都不写依然会存在一个构造器的原因，因为要定义一个对象就一定需要构造器！简单理解为使用new创建对象的本质就是在调用构造器。</strong></p>
<p><strong>举个例子：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//还是刚才那个构造器</span><br><span class="line">class Person&#123;</span><br><span class="line">    String st;</span><br><span class="line">    public Person()&#123;</span><br><span class="line">        this.st = &quot;OK!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class void main(String[] args)&#123;</span><br><span class="line">    Person person = new Person();</span><br><span class="line">    System.out.println(person.st);</span><br><span class="line">    //这里会输出OK！而不是NULL了，因为对象调用的是方法person而person已经定义了st为&quot;OK!&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>上面我们说的是无参数的构造器，下面我们来介绍有参数的构造器。</p>
<p>有参构造，一旦有了有参构造，无参构造就必须显式定义，什么意思呢，下面来解释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">//还是刚才那个构造器</span><br><span class="line">class Person&#123;</span><br><span class="line">    String st;</span><br><span class="line">    public Person()&#123;</span><br><span class="line">        this.st = &quot;不OK!&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    public Person(int a)&#123;</span><br><span class="line">        this.st = &quot;OK!&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class void main(String[] args)&#123;</span><br><span class="line">    Person person1 = new Person();//这里调用的是无参构造。</span><br><span class="line">    Person person2 = new Person(20);//这里调用的是有参构造。</span><br><span class="line">    //当然，你的对象名也不能相同，否则会报错。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>无参构造是什么意思：就是在构造器中不加参数的。</p>
<p>显式定义是什么意思：就是即使方法里面什么东西都没有你也要把该方法写出来。</p>
<p><strong>其实构造器最大的作用就是初始化值！</strong></p>
<p><strong>快捷键：在IDEA里面Alt+Insert 快速建立构造器！</strong></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>”JAVA--流的知识点“</title>
    <url>/2022/02/09/JAVA-%E6%B5%81%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p><strong>概念：存储和内存之间的传输数据的通道.(硬盘和内存之间)</strong></p>
<span id="more"></span>

<p>一、<strong>流的分类：</strong></p>
<p>*<strong>1.按方向：*</strong></p>
<p>输入流(input)：将“存储设备”中的数据留到“内存(程序)”中。</p>
<p>输出流(output)：将“内存(程序)”中的数据流到“存储设备”中去。</p>
<p><em><strong>2.按单位：</strong></em></p>
<p>字节流：以字节为单位，可以读写所有数据。</p>
<p>字符流：以字符为单位，只能读写文本数据。</p>
<p>*<strong>3.按功能：*</strong></p>
<p>节点流：具有实际传输数据的读写功能。</p>
<p>过滤流：在节点流的基础之上增强功能。</p>
<p>字节流的父类（抽象）：<br> <strong>InputStream:字节输入流</strong>:</p>
<p>int <code>available()</code> 返回从该输入流中可以读取（或跳过）的字节数的估计值，而不会被下一次调用此输入流的方法阻塞。</p>
<p><code>void close()</code> 关闭此输入流并释放与流相关联的任何系统资源。</p>
<p><code>void mark(int readlimit)</code> 标记此输入流中的当前位置。</p>
<p><code>boolean markSupported()</code> 测试这个输入流是否支持 <code>mark</code>和 <code>reset</code>方法。</p>
<p><code>abstract int read()</code> 从输入流读取数据的下一个字节。</p>
<p><code>int read(byte[] b)</code> 从输入流读取一些字节数，并将它们存储到缓冲区 <code>b</code> 。</p>
<p><code>int read(byte[] b, int off, int len)</code> 从输入流读取最多 <code>len</code>字节的数据到一个字节数组。</p>
<p><code>void reset()</code> 将此流重新定位到上次在此输入流上调用 <code>mark</code>方法时的位置。</p>
<p><code>long skip(long n)</code> 跳过并丢弃来自此输入流的 <code>n</code>字节数据。</p>
<p><strong>OutputStream:字节输出</strong>:</p>
<p><code>void close()</code> 关闭此输出流并释放与此流相关联的任何系统资源。</p>
<p><code>void flush()</code> 刷新此输出流并强制任何缓冲的输出字节被写出。</p>
<p><code>void write(byte[] b)</code> 将 <code>b.length</code>字节从指定的字节数组写入此输出流。</p>
<p><code>void write(byte[] b, int off, int len)</code> 从指定的字节数组写入 <code>len</code>个字节，从偏移 <code>off</code>开始输出到此输出流。</p>
<p><code>abstract void write(int b)</code> 将指定的字节写入此输出流。</p>
<p>二、<strong>文件字节流：</strong></p>
<p>1.<strong>FileInputStream:–public int read*(*byte*[]* b*)*// 从流中读取多个数据，将读到的内容存入b数组，返回实际读到的字节数，，如果达到文件的结尾，则返回-1.</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/edc9beae38a7bf6cb7bf5991f8efc529.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>2.<strong>FileOutputStream:–public void write*(*byte*[]* b*)*//一次写多个字节，将写的字节读入输出流</strong>.<strong>(就是把想要写进文件里面的字符串写在代码里面，代码会帮你写进字符串里面)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FileOutputStream fop = new FileOutputStream(&quot;D:\\aa.txt&quot;);</span><br><span class="line">//如果改成FileOutputStream fop = new FileOutputStream(&quot;D:\\aa.txt&quot;，true);则会变成运行一次在后面加一次123456；</span><br><span class="line">String str = &quot;123456&quot;;</span><br><span class="line">fop.write(str.getBytes());</span><br><span class="line">//就是用这三行代码可以把123456输入到aa.txt里面。</span><br><span class="line"></span><br><span class="line">三、字节缓冲流</span><br><span class="line">import  java.io.BufferedInputStream;</span><br><span class="line">import  java.io.BufferedOutputStream;</span><br><span class="line">用处：1.提高IO流效率，减少访问磁盘的次数；2.数据存储在缓冲区，flush是将缓冲区的内容写进文件里面，也可以直接close。</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/fd912797abd223d09258cc59acac38e2.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>在创建BufferedOutputStream对象之后，关闭bis对象时默认也会关闭fis对象，因此只用调用bis.close();即可关闭两个。</p>
<p><strong>输出（output）缓冲区会把write方法里面的内容存在缓冲区，要输入文件就要调用flush方法写入文件。</strong></p>
<p><strong>四、对象流：</strong>（ObjectInputStream和ObjectOutputStream）</p>
<p>两个基本方法：</p>
<p>1.readObject:从流中读取一个对象。</p>
<p>2.writeObject(Object obj):向流中写入一个对象。</p>
<p>称为序列化和反序列化，下面来解释：</p>
<p>1.序列化：(类似于在硬盘里面输出对象)（ObjectOutputStream）</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/de2c5f977a12b845233c293b9c2cea24.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>*<strong>注意:序列化时在要输出的类当中，必须要调用一个接口：implements Serializable。</strong></p>
<p>2.反序列化：(类似于往流里面输入对象)（ObjectInputStream）</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/bfbd81e69a080dcf34d278cac160001c.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p><strong>我们可以使用对象.toString方法打印出写入流的数据。（方法，属性等等）</strong></p>
<p>*序列的注意事项：</p>
<p>1.必须使用Serializable接口。（包括属性也是一样）</p>
<p>2.序列化版本号ID可以在类中定义，保证序列化和反序列化的ID是相同的值。（更改了声明对象的类的序列化ID之后，不能直接反序列化，必须先序列化一次使得硬盘中的序列号相同才能下一步反序列化）。</p>
<p>3.使用transient（瞬间的）修饰属性，这个属性不能被序列化。</p>
<p>4.静态的属性不能序列化。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>”JAVA--类的盘点“</title>
    <url>/2022/02/09/JAVA-%E7%B1%BB%E7%9A%84%E7%9B%98%E7%82%B9/</url>
    <content><![CDATA[<p>先来一个特殊的：</p>
<p>double res = 1.4-0.5/0.9;</p>
<span id="more"></span>

<p>System.out.println(res);//这时候输出的会是0.999999999</p>
<p>这时候就要用到BigDecimal来精确输出double类型的数据了。</p>
<p>BigDecimal num = new BigDecimal(“0.9”);//这样就可以声明一个BigDecimal数据了。</p>
<p>当然要在前面加上import java.math.BigDecimal来引入BigDecimal</p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.4&quot;</span>).subtract(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.5&quot;</span>)).</span><br><span class="line">divide(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>)))<span class="comment">//这样就可以输出1而不是0.9999999了。</span></span><br><span class="line">同样也可以:</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.4&quot;</span>).subtract(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.5&quot;</span>)).divide(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>”JAVA--文件file类“</title>
    <url>/2022/02/09/JAVA-%E6%96%87%E4%BB%B6file%E7%B1%BB/</url>
    <content><![CDATA[<p>java.io.File是文件名的抽象表示。</p>
<span id="more"></span>

<p><strong>你的文件表示必须在创建对象时候体现。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/fb6fdb58d06f307e95bb0d2ef094c34d.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>常用的方法</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/750b65bb2dac31431da0c1b5fd888c62.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>File中的Separator是\ ，Separator是;</p>
<p><strong>最好是用一个布尔类型的变量来表示createNewFile</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/528a9bda160f3d0530d1dc86aad54817.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>用布尔类型表示</p>
<p>删除文件：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9af1fd354a5574fcaab8bd8ebe206a6b.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>有这两种方法</p>
<p>获取文件创建日期：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b26e5fed45d628eebec7235cb9350a2a.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>判断文件是否可写可读；</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/3f790142d2c2d99e836e65e2346e57d7.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>当只读的时候就不能写了</p>
<p>判断是不是文件，是否是隐藏的：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/dce4fd3d48c2ccd0dc1fba07e62d8da5.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>判断是不是隐藏的，是不是文件：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ce447e9b190e99c3e310830dfc5b3daa.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>这里可以选择</p>
<h2 id="文件夹"><a href="#文件夹" class="headerlink" title="文件夹"></a>文件夹</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/ac863ec6df97a50a337f82ec314ebcbc.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>mkdirs创建多级目录文件夹，mkdir创建单级文件夹。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9541a40c8b7423f37eb5e810b1bb34db.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>获取绝对路径，路径，文件名</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9a2e173622aa85c9f576a72996639cc0.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>判断是否是文件夹是否隐藏</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/de6bca422bb73bab89a0181d5a3a2381.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>用了增强for循环</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>”JAVA--泛型“</title>
    <url>/2022/02/09/JAVA-%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<p>介绍泛型的基本概念</p>
<span id="more"></span>

<p><strong>基本概念：</strong>（传递类型参数的东西）</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/446e9973ebc5dab7b15dbedca430ed4c.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA--继承</title>
    <url>/2022/02/09/JAVA-%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p>1.extend的意思是’’拓展，扩大’’,子类是对父类的拓展。</p>
<span id="more"></span>

<p><img src="https://img-blog.csdnimg.cn/5d39b5ad4d0c474a818fe81179381fc9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFfNTI1OTk4NzA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>如teacher is a person.</p>
<p><strong>子类不能继承父类的private属性或者方法！</strong></p>
<p>ctrl+H可以打开继承面板</p>
<p>2.Object！</p>
<p>在Java中所有的类都默认继承Object类！！！</p>
<p>例：public class AA /<em>entend Object</em>/{}</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>”JAVA--转换流知识点“</title>
    <url>/2022/02/09/JAVA-%E8%BD%AC%E6%8D%A2%E6%B5%81%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>InputStreamReader和OutputStreamWriter:</p>
<span id="more"></span>


<p> <strong>InputStreamReader</strong>:</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f0b6cfe4735777363bc8e2eeafde2a2b.png" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>这样接下来直接用isr即可</p>
<p>OutputStreamWriter同理。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>”JAVA--集合知识点“</title>
    <url>/2022/02/09/JAVA-%E9%9B%86%E5%90%88%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>1.集合的概念：存放对象的容器，类似数组的概念，同样集合也有对多个对象进行批量操作的功能。</p>
<span id="more"></span>

<p>2.集合与数组的区别：<br>（1）数组的长度是固定的，但是集合的长度是不固定的。</p>
<p>（2）数组可以存放引用类型（如Integer Float等）和基本数据类型（int float 等），集合只能存放引用类型。</p>
<p>3.集合用到的所有类都在java.util.*这个包里面。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA--面向对象知识点总结</title>
    <url>/2022/02/09/JAVA-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>有关面向对象知识点的总结</p>
<span id="more"></span>

<p>1.类与对象：</p>
<p>类是一个模板（抽象），对象是一个具体的实例（具体化）<br>2.方法：<br>定义、调用<br>3.对应的引用<br>引用类型:基本类型 (8)<br>对象是通过引用来操作的:栈—&gt;堆<br>4.属性:字段Field 成员变量<br><strong>默认初始化:</strong><br>数字: 0 和 0.0<br>char : u0000<br>boolean: false<br>引用: null<br>修饰符属性类型 属性名。属性值!<br>5.对象的创建和使用(属性就是变量的意思)<br>必须使用new关键字创造对象，构造器 Person my = new Person();<br>-对象的属性my. name<br>-对象的方法my. sleep()</p>
<p>6.类：<br>静态的定义：属性</p>
<p>动态的定义：方法</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>”Linux--Xshell和Xftp“</title>
    <url>/2022/02/09/Linux-Xshell%E5%92%8CXftp/</url>
    <content><![CDATA[<p>共同点：xshell和Xftp都需要使用Linux中的ip地址（在linux的cmd中使用ifconfig来查看连接用到的ip）</p>
<p>不同点：Xftp用于发送文件。</p>
<p>Xshell可以使用windows来访问Linux，实现远程操控。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>”Linux--vi和vim“</title>
    <url>/2022/02/09/Linux-vi%E5%92%8Cvim/</url>
    <content><![CDATA[<p> vim具有编程的能力，是vi的增强版本，代码补全，颜色都有（有点像IDEA） </p>
<span id="more"></span>

<p><img src="https://img-blog.csdnimg.cn/7f41fab8a28c46cc877a41e40ddc1957.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>注意：</p>
<p>1.按下“i”进入输入模式；先输入esc再按下“：”进入命令行模式。不进入编辑模式是没办法写代码的。</p>
<p>2.vim和vi的命令是区分大小写的。</p>
<p>-——————————————————————————————————————————–</p>
<h2 id="下面用Xshell和vim写一个Hello-java程序："><a href="#下面用Xshell和vim写一个Hello-java程序：" class="headerlink" title="下面用Xshell和vim写一个Hello.java程序："></a><strong>下面用Xshell和vim写一个Hello.java程序：</strong></h2><p>1.先输入这个指令：vim Hello.java</p>
<p><img src="https://img-blog.csdnimg.cn/6e6abde8af21487191742eadbff7d350.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>2.在生成的界面中按下“i”键进入编辑模式，看到最下面变成“–插入–” 即可</p>
<p><img src="https://img-blog.csdnimg.cn/a4df0727a4e446f79efd224933f30871.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_12,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>3.在空白的地方写java代码，输出一个Helloworld</p>
<p><img src="https://img-blog.csdnimg.cn/ab0f994ac7ec4d73aeb50f516514790f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>4.最后按下esc再按下“：wq”（其中wq表示write和quit）即可完成Hello.java程序的编写。</p>
<p>-——————————————————————————————————————————–</p>
<h1 id="重点：在vim中各种模式的切换"><a href="#重点：在vim中各种模式的切换" class="headerlink" title="重点：在vim中各种模式的切换"></a><strong>重点：在vim中各种模式的切换</strong></h1><p> <img src="https://img-blog.csdnimg.cn/a081d79f164048a8a0b204e1e2237e82.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>wq（保存退出），q（退出），q！（强制退出，并且不保存）</p>
<p>快捷键：</p>
<p>1.“yy”用于拷贝当前行，“5yy”用于拷贝从光标那行往下的5行。</p>
<p>2.“dd”用于删除当前行，“5dd”用于删除光标往下的那5行。</p>
<p>3.寻找文件中对应的关键字或者字符，在一般模式下点“/” 然后输入你想找的关键字。输入“n”寻找下一个。</p>
<p>4.按下“G”到达文件的最底端，按下“gg”到达文件的最顶端。</p>
<p>5.撤销动作：在一般模式下按“u”。</p>
<p>6.想要定位到对应的行：比如你想对应到20行，在一般模式下输入20，然后shift+g。</p>
<p>7.一般模式下“：”输入set nu表示打开行号，输入“set nonu”表示关闭行号。</p>
<h1 id="Linux下的开机，重启，关机"><a href="#Linux下的开机，重启，关机" class="headerlink" title="Linux下的开机，重启，关机"></a><strong>Linux下的开机，重启，关机</strong></h1><p>1.shutdown -h now 现在马上关机</p>
<p>2.shutdown -h 1 一分钟后关机</p>
<p>3.shutdown -r now 现在马上重启</p>
<p>4.halt 关机</p>
<p>5.reboot 现在重启</p>
<p>6.sync 将内存的内容同步到磁盘(相当于保存)</p>
<h1 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a><strong>用户登录</strong></h1><p>尽量不要使用root登录，避免失误。</p>
<p>若是普通用户登录后需要获得管理员权限，使用su-用户名 即可。</p>
<p>使用logout来注销用户登录（在运行级别三上面有用）</p>
<p>在root情况下logout退到你原来的用户，再使用一次logout退出系统！</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>”Linux--忘记密码的找回方法“</title>
    <url>/2022/02/09/Linux-%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81%E7%9A%84%E6%89%BE%E5%9B%9E%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>非常详细！保姆级教程！</p>
<span id="more"></span>

<p> (1)在登录前的界面按下“e”编辑，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/24c29cb043ac4d2f91a731ff9b6121ae.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>（2）找到linux16所在的那一行的下面一行：（如果没找到linux16就按着键盘向下的箭头就能看见了）</p>
<p><img src="https://img-blog.csdnimg.cn/2f7d063b6b994865a19935d18958e2de.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> （3）在UTF-8后面按下空格后加上这句话：init=/bin/sh</p>
<p><img src="https://img-blog.csdnimg.cn/8b229a66f7534503bcf5298f85aa9fcf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>(4)输入完之后按下快捷键Ctrl+x进入单用户模式（如果左边的Ctrl不行就试试右边的） </p>
<p>（5）在光标闪烁的位置输入这句话：mount -o remount,rw/  输入完之后回车。</p>
<p><img src="https://img-blog.csdnimg.cn/2f62ded86e884e48b6b27fa8e15eb14d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p><img src="https://img-blog.csdnimg.cn/3db9328c5fb742acbf74ccdcc4698f29.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> （6）然后在新界面光标闪烁位置输入passwd然后回车，输入新密码，然后确认密码</p>
<p>（7）输入完之后当我们看到passwd=****就说明成功修改了密码。</p>
<p><img src="https://img-blog.csdnimg.cn/5f29832e73d74f2dad243c54a44b6f6e.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>（8）紧接着在下面的一行输入这句话：touch /.autorelabel（注意：touch和/之间有一个空格）</p>
<p><img src="https://img-blog.csdnimg.cn/8df0b14725b648ec9f51e7b974ae8f33.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>（9）继续在光标闪烁的位置输入exec /sbin/init（同样在exec和/之间有一个空格），完成后按回车，耐心等待系统修改密码（时间会稍长）完成后linux会自动重启。</p>
<p><img src="https://img-blog.csdnimg.cn/4b5f47ea34064e89a594099f73e1c200.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>（10）登录时使用新密码即可 .</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>”Linux--实用指令“</title>
    <url>/2022/02/09/Linux-%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>介绍Linux的运行级别和找回root密码的方式</p>
<span id="more"></span>

<p> <strong>1.运行级别：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/cfe449dfc95f4cc1869792e4e53bf39c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_11,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>常用的运行级别是3和5</p>
<p>使用init来切换运行级别（init 运行级别）</p>
<p>查看当前运行级别：systemctl get-default</p>
<p><strong>2.找回root密码</strong></p>
<p>(1)在登录前的界面按下“e”编辑，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/24c29cb043ac4d2f91a731ff9b6121ae.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>（2）找到linux16所在的那一行的下面一行：（如果没找到linux16就按着键盘向下的箭头就能看见了）</p>
<p><img src="https://img-blog.csdnimg.cn/2f7d063b6b994865a19935d18958e2de.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> （3）在UTF-8后面按下空格后加上这句话：init=/bin/sh</p>
<p><img src="https://img-blog.csdnimg.cn/8b229a66f7534503bcf5298f85aa9fcf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>(4)输入完之后按下快捷键Ctrl+x进入单用户模式（如果左边的Ctrl不行就试试右边的） </p>
<p>（5）在光标闪烁的位置输入这句话：mount -o remount,rw/  输入完之后回车。</p>
<p><img src="https://img-blog.csdnimg.cn/2f62ded86e884e48b6b27fa8e15eb14d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p><img src="https://img-blog.csdnimg.cn/3db9328c5fb742acbf74ccdcc4698f29.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> （6）然后在新界面光标闪烁位置输入passwd然后回车，输入新密码，然后确认密码</p>
<p>（7）输入完之后当我们看到passwd=****就说明成功修改了密码。</p>
<p><img src="https://img-blog.csdnimg.cn/5f29832e73d74f2dad243c54a44b6f6e.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>（8）紧接着在下面的一行输入这句话：touch /.autorelabel（注意：touch和/之间有一个空格）</p>
<p><img src="https://img-blog.csdnimg.cn/8df0b14725b648ec9f51e7b974ae8f33.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>（9）继续在光标闪烁的位置输入exec /sbin/init（同样在exec和/之间有一个空格），完成后按回车，耐心等待系统修改密码（时间会稍长）完成后linux会自动重启。</p>
<p><img src="https://img-blog.csdnimg.cn/4b5f47ea34064e89a594099f73e1c200.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>（10）登录时使用新密码即可 .</p>
<p>如果在登录的状态下修改密码那就容易得多了，在终端使用passwd 用户名 即可。</p>
<p><img src="https://img-blog.csdnimg.cn/8d46bf1dc8f4486f80463a0ad95c030b.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h1 id="Linux里的帮助指令"><a href="#Linux里的帮助指令" class="headerlink" title="Linux里的帮助指令"></a><strong>Linux里的帮助指令</strong></h1><p><img src="https://img-blog.csdnimg.cn/4735254542224f94a3e8ba707bc2c2dc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 基本命令：</p>
<p>ls 显示当前目录下所有文件但是没有隐藏文件</p>
<p>ls -a 显示当前目录下所有文件包括隐藏文件</p>
<p>ls -l（等效于ll）表示目录以单行的方式输出<img src="https://img-blog.csdnimg.cn/c8efefc5fb2144dc9fab281847b94cb6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> ls -la或者ls -al 表示单行输出文件包括隐藏文件</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>”Linux--文件目录指令“</title>
    <url>/2022/02/09/Linux-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>介绍Linux用于文件的常用指令</p>
<span id="more"></span>

<p>1.pwd指令：显示当前文件目录的绝对路径</p>
<p>2.ls指令：显示当前目录下的文件（-a显示隐藏文件，-l以单行形式输出）</p>
<p>3.cd指令：（1）cd ~ 回到自己的家目录</p>
<p>​        （2）cd .. 回到上一级目录</p>
<p>4.mkdir（make dir）指令：mkdir 创建目录，mkdir -p 创建多级目录</p>
<p>5.rmdir 删除指定目录：（1）删除空目录 rmdir 目录</p>
<p>​                    (2) 删除非空目录 rm -rf 目录（是rm -f 和rm -r的结合体）</p>
<p>6.创建空文件：touch 文件名称。如创建一个Hello.txt 文件，使用touch Hello.txt</p>
<p><strong>7.cp指令：</strong></p>
<p><strong>(1)比如想把home/a路径下的Hello.txt文件拷贝到home/b路径下，我们要先在home/a路径下执行操作:cp Hello.txt home/b/</strong></p>
<p><strong>(2)把整个文件夹的内容拷贝到另外一个文件夹：cp -r home/a/ home/b/（其中是把a拷贝到b）</strong></p>
<p><strong>（3）强制覆盖文件的方法是在cp前面加一个\ 其他的不变</strong></p>
<p>8.rm指令：rm -r 递归删除整个文件夹</p>
<p>​         rm -f 强制删除不提示</p>
<p>9.mv指令：</p>
<p><img src="https://img-blog.csdnimg.cn/ab9d6a81664b4e97bfbb25e95846b7ba.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>例：若想把/home/目录下面的pig.txt文件移动到/target/目录下面，使用1.cd /home/  2.mv pig.txt /target/</p>
<p>10.cat指令：显示文件的内容（用cat -n 来显示行数），通常在cat指令后面会加上一个| more来给用户操作，有了more指令不会把你的文件在一行显示完可以有更多的操作。</p>
<p>11.more指令：也可以使用more指令来显示文件内容：more /home/Hello.java<img src="https://img-blog.csdnimg.cn/77e9b31369dc4d4b82157f2fb77c92fd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 12.less指令： 跟more指令一样的作用，但是less指令是在文件看到哪里加载到哪里，不看的内容不会加载，这对大型文件很有作用。<img src="https://img-blog.csdnimg.cn/8593ab6174384638beca6a7edf1bb9bc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>13.echo指令：</p>
<p><img src="https://img-blog.csdnimg.cn/54a6b36c221b419e94f67338cf510d72.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_16,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>14.head指令：<br> <img src="https://img-blog.csdnimg.cn/b7a7a2663dd64d828304850916f30986.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">​</p>
<p> 例题答案：head -n 5 /etc/profile</p>
<p>15.tail指令：（与head指令相反） </p>
<p><img src="https://img-blog.csdnimg.cn/57c3d4a749ae43fa9a3530cd01a49298.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 在后面加-f是实时监控、</p>
<p>比如我要监控Hello.txt文件，那么使用tail -f Hello.txt，然后我在linux的终端使用echo Hello &gt; Hello.txt，这时会在Xshell中显示Hello，因为实时监控了。</p>
<p>在echo Hello &gt; Hello.txt 中&gt;的作用是覆盖原先文件的内容，而&gt;&gt;的作用是在文件的后面追加内容</p>
<p><img src="https://img-blog.csdnimg.cn/9c2cbff394d14f77b07a3d72c5631388.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p><img src="https://img-blog.csdnimg.cn/6abcdc70449d491fa2902b21acffb776.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>16.ln指令：</p>
<p>ln -s [源文件或者目录] [软链接名] </p>
<p><img src="https://img-blog.csdnimg.cn/9f1d6f2211584101bd42d61514438c39.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>17.history指令：</p>
<p>显示出历史指令。</p>
<p><img src="https://img-blog.csdnimg.cn/a9bd055e7e5b4ecdbd997227dca209b4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_14,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>”Linux--用户管理“</title>
    <url>/2022/02/09/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p> 一、基本操作：</p>
<p>添加用户：useradd 用户名</p>
<p>删除用户(保留家目录）：userdel 用户名(但是需要root权限，自己当然不能删除自己)</p>
<span id="more"></span>

<p>删除用户(不保留家目录)：userdel -r 用户名</p>
<p>更改用户密码：passwd 用户名</p>
<p>查询用户信息：id 用户名</p>
<p>切换用户：1.低权限用户到高权限用户（root）需要密码，反之不需要。</p>
<p>​         2.使用su - 用户名来实现，在高权限状态时可以使用exit/logout来换成普通用户。</p>
<p>想要查看现在的用户是谁：who am i（离谱）</p>
<p>pwd：查看现在在哪个目录下面</p>
<p><strong>用户组：（有一定的权限，对一个组的用户进行批量操作）</strong></p>
<p>添加组：groupadd 组名</p>
<p>删除组：groupdel 组名</p>
<p>创建用户的同时分组：useradd -g 组名 用户名</p>
<p>用户换组：usermod -g 新组名 用户名</p>
<p><strong>用户和组的相关文件：</strong></p>
<p>/etc/passwd文件：（其中shell相当于中间商，我们的指令要经过shell才能发送给linux进行识别）<img src="https://img-blog.csdnimg.cn/7157c66835b141c2a79d908aca8b62bd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>/etc/shadow文件：<img src="https://img-blog.csdnimg.cn/112b921605f2469faa7f4c5662f1c333.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令手册</title>
    <url>/2022/02/12/Linux%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h2 id="常用的Linux命令大全"><a href="#常用的Linux命令大全" class="headerlink" title="常用的Linux命令大全"></a>常用的Linux命令大全</h2><span id="more"></span>

<h1 id="关机-重启-注销"><a href="#关机-重启-注销" class="headerlink" title="关机/重启/注销"></a>关机/重启/注销</h1><table>
<thead>
<tr>
<th>常用命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>shutdown -h now</td>
<td>即刻关机</td>
</tr>
<tr>
<td>shutdown -h 10</td>
<td>10分钟后关机</td>
</tr>
<tr>
<td>shutdown -h 11:00</td>
<td>11：00关机</td>
</tr>
<tr>
<td>shutdown -h +10</td>
<td>预定时间关机（10分钟后）</td>
</tr>
<tr>
<td>shutdown -c</td>
<td>取消指定时间关机</td>
</tr>
<tr>
<td>shutdown -r now</td>
<td>重启</td>
</tr>
<tr>
<td>shutdown -r 10</td>
<td>10分钟之后重启</td>
</tr>
<tr>
<td>shutdown -r 11:00</td>
<td>定时重启</td>
</tr>
<tr>
<td>reboot</td>
<td>重启</td>
</tr>
<tr>
<td>init 6</td>
<td>重启</td>
</tr>
<tr>
<td>init 0</td>
<td>⽴刻关机</td>
</tr>
<tr>
<td>telinit 0</td>
<td>关机</td>
</tr>
<tr>
<td>poweroff</td>
<td>⽴刻关机</td>
</tr>
<tr>
<td>halt</td>
<td>关机</td>
</tr>
<tr>
<td>sync</td>
<td>buff数据同步到磁盘</td>
</tr>
<tr>
<td>logout</td>
<td>退出登录Shell</td>
</tr>
</tbody></table>
<h1 id="系统信息和性能查看"><a href="#系统信息和性能查看" class="headerlink" title="系统信息和性能查看"></a>系统信息和性能查看</h1><table>
<thead>
<tr>
<th>常用命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>uname -a</td>
<td>查看内核/OS/CPU信息</td>
</tr>
<tr>
<td>uname -r</td>
<td>查看内核版本</td>
</tr>
<tr>
<td>uname -m</td>
<td>查看处理器架构</td>
</tr>
<tr>
<td>arch</td>
<td>查看处理器架构</td>
</tr>
<tr>
<td>hostname</td>
<td>查看计算机名</td>
</tr>
<tr>
<td>who</td>
<td>显示当前登录系统的⽤户</td>
</tr>
<tr>
<td>who am i</td>
<td>显示登录时的⽤户名</td>
</tr>
<tr>
<td>whoami</td>
<td>显示当前⽤户名</td>
</tr>
<tr>
<td>cat /proc/version</td>
<td>查看linux版本信息</td>
</tr>
<tr>
<td>cat /proc/cpuinfo</td>
<td>查看CPU信息</td>
</tr>
<tr>
<td>cat /proc/interrupts</td>
<td>查看中断</td>
</tr>
<tr>
<td>cat /proc/loadavg</td>
<td>查看系统负载</td>
</tr>
<tr>
<td>uptime</td>
<td>查看系统运⾏时间、⽤户数、负载</td>
</tr>
<tr>
<td>env</td>
<td>查看系统的环境变量</td>
</tr>
<tr>
<td>lsusb -tv</td>
<td>查看系统USB设备信息</td>
</tr>
<tr>
<td>lspci -tv</td>
<td>查看系统PCI设备信息</td>
</tr>
<tr>
<td>lsmod</td>
<td>查看已加载的系统模块</td>
</tr>
<tr>
<td>grep MemTotal /proc/meminfo</td>
<td>查看内存总量</td>
</tr>
<tr>
<td>grep MemFree /proc/meminfo</td>
<td>查看空闲内存量</td>
</tr>
<tr>
<td>free -m</td>
<td>查看内存⽤量和交换区⽤量</td>
</tr>
<tr>
<td>date</td>
<td>显示系统⽇期时间</td>
</tr>
<tr>
<td>cal 2021</td>
<td>显示2021⽇历表</td>
</tr>
<tr>
<td>top</td>
<td>动态显示cpu/内存/进程等情况</td>
</tr>
<tr>
<td>vmstat 1 20</td>
<td>每1秒采⼀次系统状态，采20次</td>
</tr>
<tr>
<td>iostat</td>
<td>查看io读写/cpu使⽤情况</td>
</tr>
<tr>
<td>查看io读写/cpu使⽤情况</td>
<td>查询cpu使⽤情况（1秒⼀次，共10次）</td>
</tr>
<tr>
<td>sar -d 1 10</td>
<td>查询磁盘性能</td>
</tr>
</tbody></table>
<h1 id="磁盘和分区"><a href="#磁盘和分区" class="headerlink" title="磁盘和分区"></a>磁盘和分区</h1><table>
<thead>
<tr>
<th>常用命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>fdisk -l</td>
<td>查看所有磁盘分区</td>
</tr>
<tr>
<td>swapon -s</td>
<td>查看所有交换分区</td>
</tr>
<tr>
<td>df -h</td>
<td>查看磁盘使⽤情况及挂载点</td>
</tr>
<tr>
<td>df -hl</td>
<td>同上</td>
</tr>
<tr>
<td>du -sh /dir</td>
<td>查看指定某个⽬录的⼤⼩</td>
</tr>
<tr>
<td>du -sk * | sort -rn</td>
<td>从⾼到低依次显示⽂件和⽬录⼤⼩</td>
</tr>
<tr>
<td>mount /dev/hda2 /mnt/hda2</td>
<td>挂载hda2盘</td>
</tr>
<tr>
<td>mount -t ntfs /dev/sdc1 /mnt/usbhd1</td>
<td>指定⽂件系统类型挂载（如ntfs）</td>
</tr>
<tr>
<td>mount -o loop xxx.iso /mnt/cdrom</td>
<td>挂 载 iso ⽂ 件</td>
</tr>
<tr>
<td>umount -v /dev/sda1</td>
<td>通过设备名卸载</td>
</tr>
<tr>
<td>umount -v /mnt/mymnt</td>
<td>通过挂载点卸载</td>
</tr>
<tr>
<td>fuser -km /mnt/hda1</td>
<td>强制卸载(慎⽤)</td>
</tr>
</tbody></table>
<h1 id="⽤户和⽤户组"><a href="#⽤户和⽤户组" class="headerlink" title="⽤户和⽤户组"></a>⽤户和⽤户组</h1><table>
<thead>
<tr>
<th>常用命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>useradd codesheep</td>
<td>创建⽤户</td>
</tr>
<tr>
<td>userdel -r codesheep</td>
<td>删除⽤户</td>
</tr>
<tr>
<td>usermod -g group_name user_name</td>
<td>修改⽤户的组</td>
</tr>
<tr>
<td>usermod -aG group_name user_name</td>
<td>将⽤户添加到组</td>
</tr>
<tr>
<td>usermod -s /bin/ksh -d /home/codepig –g dev codesheep</td>
<td>修改⽤户codesheep的登录Shell、主⽬录以及⽤户组</td>
</tr>
<tr>
<td>groups test</td>
<td>查看test⽤户所在的组</td>
</tr>
<tr>
<td>groupadd group_name</td>
<td>创建⽤户组</td>
</tr>
<tr>
<td>groupdel group_name</td>
<td>删除⽤户组</td>
</tr>
<tr>
<td>groupmod -n new_name old_name</td>
<td>重命名⽤户组</td>
</tr>
<tr>
<td>su - user_name</td>
<td>su - user_name</td>
</tr>
<tr>
<td>passwd</td>
<td>修改⼝令</td>
</tr>
<tr>
<td>passwd codesheep</td>
<td>修改某⽤户的⼝令</td>
</tr>
<tr>
<td>w</td>
<td>查看活动⽤户</td>
</tr>
<tr>
<td>id codesheep</td>
<td>查看指定⽤户codesheep信息</td>
</tr>
<tr>
<td>last</td>
<td>查看⽤户登录⽇志</td>
</tr>
<tr>
<td>crontab -l</td>
<td>查看当前⽤户的计划任务</td>
</tr>
<tr>
<td>cut -d: -f1 /etc/passwd</td>
<td>查看系统所有⽤户</td>
</tr>
<tr>
<td>cut -d: -f1 /etc/group</td>
<td>查看系统所有组</td>
</tr>
</tbody></table>
<h1 id="⽹络和进程管理"><a href="#⽹络和进程管理" class="headerlink" title="⽹络和进程管理"></a>⽹络和进程管理</h1><table>
<thead>
<tr>
<th>常用命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ifconfig</td>
<td>查看⽹络接⼝属性</td>
</tr>
<tr>
<td>ifconfig eth0</td>
<td>查看某⽹卡的配置</td>
</tr>
<tr>
<td>route -n</td>
<td>查看路由表</td>
</tr>
<tr>
<td>netstat -lntp</td>
<td>查看所有监听端⼝</td>
</tr>
<tr>
<td>netstat -antp</td>
<td>查看已经建⽴的TCP连接</td>
</tr>
<tr>
<td>netstat -lutp</td>
<td>查看TCP/UDP的状态信息</td>
</tr>
<tr>
<td>ifup eth0</td>
<td>启⽤eth0⽹络设备</td>
</tr>
<tr>
<td>ifdown eth0</td>
<td>禁⽤eth0⽹络设备</td>
</tr>
<tr>
<td>iptables -L</td>
<td>查看iptables规则</td>
</tr>
<tr>
<td>ifconfig eth0 192.168.1.1 netmask 255.255.255.0</td>
<td>配置ip地址</td>
</tr>
<tr>
<td>dhclient eth0</td>
<td>以dhcp模式启⽤eth0</td>
</tr>
<tr>
<td>route add -net 0/0 gw Gateway_IP</td>
<td>配置默认⽹关</td>
</tr>
<tr>
<td>route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1</td>
<td>配置静态路由到达⽹络’192.168.0.0/16’</td>
</tr>
<tr>
<td>route del 0/0 gw Gateway_IP</td>
<td>删除静态路由</td>
</tr>
<tr>
<td>hostname</td>
<td>查看主机名</td>
</tr>
<tr>
<td>host <a href="http://www.baidu.com/">www.baidu.com</a></td>
<td>解析主机名</td>
</tr>
<tr>
<td>nslookup <a href="http://www.baidu.com/">www.baidu.com</a></td>
<td>查询DNS记录，查看域名解析是否正常</td>
</tr>
<tr>
<td>ps -ef</td>
<td>查看所有进程</td>
</tr>
<tr>
<td>ps -ef | grep codesheep</td>
<td>过滤出你需要的进程</td>
</tr>
<tr>
<td>kill -s name</td>
<td>kill指定名称的进程</td>
</tr>
<tr>
<td>kill -s pid</td>
<td>kill指定pid的进程</td>
</tr>
<tr>
<td>top</td>
<td>实时显示进程状态</td>
</tr>
<tr>
<td>vmstat 1 20</td>
<td>每1秒采⼀次系统状态，采20次</td>
</tr>
<tr>
<td>iostat</td>
<td>iostat</td>
</tr>
<tr>
<td>sar -u 1 10</td>
<td>查询cpu使⽤情况（1秒⼀次，共10次）</td>
</tr>
<tr>
<td>sar -d 1 10</td>
<td>查询磁盘性能</td>
</tr>
</tbody></table>
<h1 id="常⻅系统服务命令"><a href="#常⻅系统服务命令" class="headerlink" title="常⻅系统服务命令"></a>常⻅系统服务命令</h1><table>
<thead>
<tr>
<th>常用命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>chkconfig –list</td>
<td>列出系统服务</td>
</tr>
<tr>
<td>service &lt;服务名&gt; status</td>
<td>查看某个服务</td>
</tr>
<tr>
<td>service &lt;服务名&gt; start</td>
<td>启动某个服务</td>
</tr>
<tr>
<td>service &lt;服务名&gt; stop</td>
<td>终⽌某个服务</td>
</tr>
<tr>
<td>service &lt;服务名&gt; restart</td>
<td>重启某个服务</td>
</tr>
<tr>
<td>systemctl status &lt;服务名&gt;</td>
<td>查看某个服务</td>
</tr>
<tr>
<td>systemctl start &lt;服务名&gt;</td>
<td>启动某个服务</td>
</tr>
<tr>
<td>systemctl stop &lt;服务名&gt;</td>
<td>终⽌某个服务</td>
</tr>
<tr>
<td>systemctl restart &lt;服务名&gt;</td>
<td>重启某个服务</td>
</tr>
<tr>
<td>systemctl enable &lt;服务名&gt;</td>
<td>关闭⾃启动</td>
</tr>
<tr>
<td>systemctl disable &lt;服务名&gt;</td>
<td>关闭⾃启动</td>
</tr>
</tbody></table>
<h1 id="⽂件和⽬录操作"><a href="#⽂件和⽬录操作" class="headerlink" title="⽂件和⽬录操作"></a>⽂件和⽬录操作</h1><table>
<thead>
<tr>
<th>常用命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>cd &lt;⽬录名&gt;</td>
<td>进⼊某个⽬录</td>
</tr>
<tr>
<td>cd ..</td>
<td>回上级⽬录</td>
</tr>
<tr>
<td>cd ../..</td>
<td>回上两级⽬录</td>
</tr>
<tr>
<td>cd</td>
<td>进个⼈主⽬录</td>
</tr>
<tr>
<td>cd -</td>
<td>回上⼀步所在⽬录</td>
</tr>
<tr>
<td>pwd</td>
<td>显示当前路径</td>
</tr>
<tr>
<td>ls</td>
<td>查看⽂件⽬录列表</td>
</tr>
<tr>
<td>ls -F</td>
<td>查看⽬录中内容（显示是⽂件还是⽬录）</td>
</tr>
<tr>
<td>ls -l</td>
<td>查看⽂件和⽬录的详情列表</td>
</tr>
<tr>
<td>ls -a</td>
<td>查看隐藏⽂件</td>
</tr>
<tr>
<td>ls -lh</td>
<td>查看⽂件和⽬录的详情列表（增强⽂件⼤⼩易读性）</td>
</tr>
<tr>
<td>ls -lSr</td>
<td>查看⽂件和⽬录列表（以⽂件⼤⼩升序查看）</td>
</tr>
<tr>
<td>tree</td>
<td>查看⽂件和⽬录的树形结构</td>
</tr>
<tr>
<td>mkdir &lt;⽬录名&gt;</td>
<td>创建⽬录</td>
</tr>
<tr>
<td>mkdir dir1 dir2</td>
<td>同时创建两个⽬录</td>
</tr>
<tr>
<td>mkdir -p /tmp/dir1/dir2</td>
<td>创建⽬录树</td>
</tr>
<tr>
<td>rm -f file1</td>
<td>删除’file1’⽂件</td>
</tr>
<tr>
<td>rmdir dir1</td>
<td>删除’dir1’⽬录</td>
</tr>
<tr>
<td>rm -rf dir1</td>
<td>删除’dir1’⽬录和其内容</td>
</tr>
<tr>
<td>rm -rf dir1 dir2</td>
<td>同时删除两个⽬录及其内容</td>
</tr>
<tr>
<td>mv old_dir new_dir</td>
<td>重命名/移动⽬录</td>
</tr>
<tr>
<td>cp file1 file2</td>
<td>复制⽂件</td>
</tr>
<tr>
<td>cp dir/* .</td>
<td>复制某⽬录下的所有⽂件⾄当前⽬录</td>
</tr>
<tr>
<td>cp -a dir1 dir2</td>
<td>复制⽬录</td>
</tr>
<tr>
<td>cp -a /tmp/dir1 .</td>
<td>复制⼀个⽬录⾄当前⽬录</td>
</tr>
<tr>
<td>ln -s file1 link1</td>
<td>创建指向⽂件/⽬录的软链接</td>
</tr>
<tr>
<td>ln file1 lnk1</td>
<td>创建指向⽂件/⽬录的物理链接</td>
</tr>
<tr>
<td>find / -name file1</td>
<td>从跟⽬录开始搜索⽂件/⽬录</td>
</tr>
<tr>
<td>find / -user user1</td>
<td>搜索⽤户user1的⽂件/⽬录</td>
</tr>
<tr>
<td>find /dir -name *.bin</td>
<td>在⽬录/dir中搜带有.bin后缀的⽂件</td>
</tr>
<tr>
<td>locate &lt;关键词&gt;</td>
<td>快速定位⽂件</td>
</tr>
<tr>
<td>locate *.mp4</td>
<td>寻找.mp4结尾的⽂件</td>
</tr>
<tr>
<td>whereis &lt;关键词&gt;</td>
<td>显示某⼆进制⽂件/可执⾏⽂件的路径</td>
</tr>
<tr>
<td>which &lt;关键词&gt;</td>
<td>查找系统⽬录下某的⼆进制⽂件</td>
</tr>
<tr>
<td>chmod ugo+rwx dir1</td>
<td>设置⽬录所有者(u)、群组(g)及其他⼈(o)的读（r）写(w)执⾏(x)权限</td>
</tr>
<tr>
<td>chmod go-rwx dir1</td>
<td>移除群组(g)与其他⼈(o)对⽬录的读写执⾏权限</td>
</tr>
<tr>
<td>chown user1 file1</td>
<td>改变⽂件的所有者属性</td>
</tr>
<tr>
<td>chown -R user1 dir1</td>
<td>改变⽬录的所有者属性</td>
</tr>
<tr>
<td>chgrp group1 file1</td>
<td>改变⽂件群组</td>
</tr>
<tr>
<td>chown user1:group1 file1</td>
<td>改变⽂件的所有⼈和群组</td>
</tr>
</tbody></table>
<h1 id="⽂件查看和处理"><a href="#⽂件查看和处理" class="headerlink" title="⽂件查看和处理"></a>⽂件查看和处理</h1><table>
<thead>
<tr>
<th>常用命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>cat file1</td>
<td>查看⽂件内容</td>
</tr>
<tr>
<td>cat -n file1</td>
<td>查看内容并标示⾏数</td>
</tr>
<tr>
<td>tac file1</td>
<td>从最后⼀⾏开始反看⽂件内容</td>
</tr>
<tr>
<td>more file1</td>
<td>more file1</td>
</tr>
<tr>
<td>less file1</td>
<td>类似more命令，但允许反向操作</td>
</tr>
<tr>
<td>head -2 file1</td>
<td>查看⽂件前两⾏</td>
</tr>
<tr>
<td>tail -2 file1</td>
<td>查看⽂件后两⾏</td>
</tr>
<tr>
<td>tail -f /log/msg</td>
<td>实时查看添加到⽂件中的内容</td>
</tr>
<tr>
<td>grep codesheep hello.txt</td>
<td>在⽂件hello.txt中查找关键词codesheep</td>
</tr>
<tr>
<td>grep ^sheep hello.txt</td>
<td>在⽂件hello.txt中查找以sheep开头的内容</td>
</tr>
<tr>
<td>grep [0-9] hello.txt</td>
<td>选择hello.txt⽂件中所有包含数字的⾏</td>
</tr>
<tr>
<td>sed ‘s/s1/s2/g’ hello.txt</td>
<td>将hello.txt⽂件中的s1替换成s2</td>
</tr>
<tr>
<td>sed ‘/^$/d’ hello.txt</td>
<td>从hello.txt⽂件中删除所有空⽩⾏</td>
</tr>
<tr>
<td>sed ‘/ *#/d; /^$/d’ hello.txt</td>
<td>从hello.txt⽂件中删除所有注释和空⽩⾏</td>
</tr>
<tr>
<td>sed -e ‘1d’ hello.txt</td>
<td>从⽂件hello.txt 中排除第⼀⾏</td>
</tr>
<tr>
<td>sed -n ‘/s1/p’ hello.txt</td>
<td>查看只包含关键词”s1”的⾏</td>
</tr>
<tr>
<td>sed -e ‘s/ *$//‘ hello.txt</td>
<td>删除每⼀⾏最后的空⽩字符</td>
</tr>
<tr>
<td>sed -e ‘s/s1//g’ hello.txt</td>
<td>从⽂档中只删除词汇s1并保留剩余全部</td>
</tr>
<tr>
<td>sed -n ‘1,5p;5q’ hello.txt</td>
<td>查看从第⼀⾏到第5⾏内容</td>
</tr>
<tr>
<td>sed -n ‘5p;5q’ hello.txt</td>
<td>查看第5⾏</td>
</tr>
<tr>
<td>paste file1 file2</td>
<td>合并两个⽂件或两栏的内容</td>
</tr>
<tr>
<td>paste -d ‘+’ file1 file2</td>
<td>合并两个⽂件或两栏的内容，中间⽤”+”区分</td>
</tr>
<tr>
<td>sort file1 file2</td>
<td>排序两个⽂件的内容</td>
</tr>
<tr>
<td>comm -1 file1 file2</td>
<td>⽐较两个⽂件的内容(去除’file1’所含内容)</td>
</tr>
<tr>
<td>comm -2 file1 file2</td>
<td>⽐较两个⽂件的内容(去除’file2’所含内容</td>
</tr>
<tr>
<td>comm -3 file1 file2</td>
<td>⽐较两个⽂件的内容(去除两⽂件共有部分)</td>
</tr>
</tbody></table>
<h1 id="打包和解压"><a href="#打包和解压" class="headerlink" title="打包和解压"></a>打包和解压</h1><table>
<thead>
<tr>
<th>常用命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>zip xxx.zip file</td>
<td>压缩⾄zip包</td>
</tr>
<tr>
<td>zip -r xxx.zip file1 file2 dir1</td>
<td>将多个⽂件+⽬录压成zip包</td>
</tr>
<tr>
<td>unzip xxx.zip</td>
<td>解压zip包</td>
</tr>
<tr>
<td>tar -cvf xxx.tar file</td>
<td>创建⾮压缩tar包</td>
</tr>
<tr>
<td>tar -cvf xxx.tar file1 file2 dir1</td>
<td>将多个⽂件+⽬录打tar包</td>
</tr>
<tr>
<td>tar -tf xxx.tar</td>
<td>查看tar包的内容</td>
</tr>
<tr>
<td>tar -xvf xxx.tar</td>
<td>解压tar包</td>
</tr>
<tr>
<td>tar -xvf xxx.tar -C /dir</td>
<td>将tar包解压⾄指定⽬录</td>
</tr>
<tr>
<td>tar -cvfj xxx.tar.bz2 dir</td>
<td>创建bz2压缩包</td>
</tr>
<tr>
<td>tar -jxvf xxx.tar.bz2</td>
<td>解压bz2压缩包</td>
</tr>
<tr>
<td>tar -cvfz xxx.tar.gz dir</td>
<td>创建gzip压缩包</td>
</tr>
<tr>
<td>tar -zxvf xxx.tar.gz</td>
<td>解压gzip压缩包</td>
</tr>
<tr>
<td>bunzip2 xxx.bz2</td>
<td>解压bz2压缩包</td>
</tr>
<tr>
<td>bzip2 filename</td>
<td>压缩⽂件</td>
</tr>
<tr>
<td>gunzip xxx.gz</td>
<td>解压gzip压缩包</td>
</tr>
<tr>
<td>gzip filename</td>
<td>压缩⽂件</td>
</tr>
<tr>
<td>gzip -9 filename</td>
<td>最⼤程度压缩</td>
</tr>
</tbody></table>
<h1 id="RPM包管理命令"><a href="#RPM包管理命令" class="headerlink" title="RPM包管理命令"></a>RPM包管理命令</h1><table>
<thead>
<tr>
<th>常用命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>rpm -qa</td>
<td>查看已安装的rpm包</td>
</tr>
<tr>
<td>rpm -q pkg_name</td>
<td>查询某个rpm包</td>
</tr>
<tr>
<td>rpm -q –whatprovides xxx</td>
<td>显示xxx功能是由哪个包提供的</td>
</tr>
<tr>
<td>rpm -q –whatrequires xxx</td>
<td>显示xxx功能被哪个程序包依赖的</td>
</tr>
<tr>
<td>rpm -q –changelog xxx</td>
<td>显示xxx包的更改记录</td>
</tr>
<tr>
<td>rpm -qi pkg_name</td>
<td>查看⼀个包的详细信息</td>
</tr>
<tr>
<td>rpm -qd pkg_name</td>
<td>查询⼀个包所提供的⽂档</td>
</tr>
<tr>
<td>rpm -qc pkg_name</td>
<td>查看已安装rpm包提供的配置⽂件</td>
</tr>
<tr>
<td>rpm -ql pkg_name</td>
<td>查看⼀个包安装了哪些⽂件</td>
</tr>
<tr>
<td>rpm -qf filename</td>
<td>查看某个⽂件属于哪个包</td>
</tr>
<tr>
<td>rpm -qR pkg_name</td>
<td>查询包的依赖关系</td>
</tr>
<tr>
<td>rpm -ivh xxx.rpm</td>
<td>安装rpm包</td>
</tr>
<tr>
<td>rpm -ivh –test xxx.rpm</td>
<td>测试安装rpm包</td>
</tr>
<tr>
<td>rpm -ivh –nodeps xxx.rpm</td>
<td>安装rpm包时忽略依赖关系</td>
</tr>
<tr>
<td>rpm -e xxx</td>
<td>卸载程序包</td>
</tr>
<tr>
<td>rpm -Fvh pkg_name</td>
<td>升级确定已安装的rpm包</td>
</tr>
<tr>
<td>rpm -Uvh pkg_name</td>
<td>升级rpm包(若未安装则会安装)</td>
</tr>
<tr>
<td>rpm -V pkg_name</td>
<td>RPM包详细信息校验</td>
</tr>
</tbody></table>
<h1 id="YUM包管理命令"><a href="#YUM包管理命令" class="headerlink" title="YUM包管理命令"></a>YUM包管理命令</h1><table>
<thead>
<tr>
<th>常用命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>yum repolist enabled</td>
<td>显示可⽤的源仓库</td>
</tr>
<tr>
<td>yum search pkg_name</td>
<td>搜索软件包</td>
</tr>
<tr>
<td>yum install pkg_name</td>
<td>下载并安装软件包</td>
</tr>
<tr>
<td>yum install –downloadonly pkg_name</td>
<td>只 下 载 不 安 装</td>
</tr>
<tr>
<td>yum list</td>
<td>显示所有程序包</td>
</tr>
<tr>
<td>yum list installed</td>
<td>查看当前系统已安装包</td>
</tr>
<tr>
<td>yum list updates</td>
<td>查看可以更新的包列表</td>
</tr>
<tr>
<td>yum check-update</td>
<td>查看可升级的软件包</td>
</tr>
<tr>
<td>yum update</td>
<td>更新所有软件包</td>
</tr>
<tr>
<td>yum update pkg_name</td>
<td>升级指定软件包</td>
</tr>
<tr>
<td>yum deplist pkg_name</td>
<td>列出软件包依赖关系</td>
</tr>
<tr>
<td>yum remove pkg_name</td>
<td>删除软件包</td>
</tr>
<tr>
<td>yum clean all</td>
<td>清除缓存</td>
</tr>
<tr>
<td>yum clean packages</td>
<td>清除缓存的软件包</td>
</tr>
<tr>
<td>yum clean headers</td>
<td>清除缓存的header</td>
</tr>
</tbody></table>
<h1 id="DPKG包管理命令"><a href="#DPKG包管理命令" class="headerlink" title="DPKG包管理命令"></a>DPKG包管理命令</h1><table>
<thead>
<tr>
<th>常用命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>dpkg -c xxx.deb</td>
<td>列出deb包的内容</td>
</tr>
<tr>
<td>dpkg -i xxx.deb</td>
<td>安装/更新deb包</td>
</tr>
<tr>
<td>dpkg -r pkg_name</td>
<td>移除deb包</td>
</tr>
<tr>
<td>dpkg -P pkg_name</td>
<td>移除deb包(不保留配置)</td>
</tr>
<tr>
<td>dpkg -l</td>
<td>查看系统中已安装deb包</td>
</tr>
<tr>
<td>dpkg -l pkg_name</td>
<td>显示包的⼤致信息</td>
</tr>
<tr>
<td>dpkg -L pkg_name</td>
<td>查看deb包安装的⽂件</td>
</tr>
<tr>
<td>dpkg -s pkg_name</td>
<td>查看包的详细信息</td>
</tr>
<tr>
<td>dpkg –unpack xxx.deb</td>
<td>解开deb包的内容</td>
</tr>
</tbody></table>
<h1 id="APT软件⼯具"><a href="#APT软件⼯具" class="headerlink" title="APT软件⼯具"></a>APT软件⼯具</h1><table>
<thead>
<tr>
<th>常用命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>apt-cache search pkg_name</td>
<td>搜索程序包</td>
</tr>
<tr>
<td>apt-cache show pkg_name</td>
<td>获取包的概览信息</td>
</tr>
<tr>
<td>apt-get install pkg_name</td>
<td>安装/升级软件包</td>
</tr>
<tr>
<td>apt-get purge pkg_name</td>
<td>卸载软件（包括配置）</td>
</tr>
<tr>
<td>apt-get remove pkg_name</td>
<td>卸载软件（不包括配置）</td>
</tr>
<tr>
<td>apt-get update</td>
<td>更新包索引信息</td>
</tr>
<tr>
<td>apt-get upgrade</td>
<td>更新已安装软件包</td>
</tr>
<tr>
<td>apt-get clean</td>
<td>清理缓存</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客的基本操作</title>
    <url>/2022/02/09/hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>hexo clean 清除缓存</p>
<p>hexo n “…” 生成博客文章，标题是…</p>
<span id="more"></span>

<p>hexo s   start博客，默认启动在localhost:4000端口</p>
<p>hexo d   部署到远端</p>
<p>当写完博客之后通常使用这三个：（依次输入）</p>
<p>hexo clean </p>
<p>hexo g</p>
<p>hexo d</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo d出错时的解决办法</title>
    <url>/2022/02/09/hexo-d%E5%87%BA%E9%94%99%E6%97%B6%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>该方法是一次性的，并不能永久解决</p>
<span id="more"></span>

<p>删除blog/.deploy_git文件</p>
<p>然后输入</p>
<p>git config –gloabl core.autocrlf false`</p>
<p>重新</p>
<p>hexo clean</p>
<p>hexo g</p>
<p>hexo d</p>
<p>部署</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>python--name属性</title>
    <url>/2022/03/10/python-name%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>python中的 __  <em>name</em> _ _属性</p>
<span id="more"></span>

<p>除了直接运行，python文件还可以直接作为模块导入。通过Python中的__name__属性来判断，分两种情况：<br>1.如果文件作为模块被导入，那么他的__name__值被自动设置为模块名</p>
<p>2.如果文件直接运行，那么__name__的属性值自动设置为字符串’<strong>main</strong>‘</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>()</span><br><span class="line"><span class="keyword">if</span> __name__ = <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;directly run&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> __name__ = <span class="string">&#x27;hello&#x27;</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;import way&quot;</span>)</span><br><span class="line">    </span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab -- 向量与矩阵</title>
    <url>/2022/03/07/matlab-%E5%90%91%E9%87%8F%E4%B8%8E%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h3 id="向量的基本命令"><a href="#向量的基本命令" class="headerlink" title="向量的基本命令"></a>向量的基本命令</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">#创建一个四维向量（<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>）</span><br><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">#注意：在matlab中下标是从<span class="number">1</span>开始计算的，而不是从<span class="number">0</span>开始计算的</span><br><span class="line">#使用y = x(<span class="built_in">i</span>)可以提取x中的第<span class="built_in">i</span>个元素！！</span><br><span class="line">y  = x(<span class="number">2</span>) #这里我们提取了x中的第二个元素是<span class="number">2</span>，不是<span class="number">3</span>！！！</span><br><span class="line">#使用分号；来分行，用逗号来分列！</span><br><span class="line">x = [<span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>;<span class="number">4</span>] #这时x就是四行了</span><br><span class="line"></span><br><span class="line">#创建等差数列来遍历向量</span><br><span class="line"></span><br><span class="line">#第一种等差数列的方式： x = a:d:b 表示遍历从a到b，其中公差是d（包括开头的数，当然也包括结尾的数，如果能取到的话）</span><br><span class="line">x = <span class="number">1</span>:<span class="number">2</span>:<span class="number">10</span>  #结果就是<span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">9</span></span><br><span class="line">#第二种等差数列的方式：x = <span class="built_in">linspace</span>(a,b,n),简单来说就是在a和b之间平均分成n分呈现出来。当a=b时会产生n个a。</span><br><span class="line">x = <span class="built_in">linspace</span>(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>) #<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">#求向量的维数（长度）</span><br><span class="line">n = <span class="built_in">length</span>(x)</span><br><span class="line">#求向量的转置</span><br><span class="line">xt = transpose(x)	#也可以表示为xt=x&#x27;</span><br><span class="line">#求最大值及对应位置的元素</span><br><span class="line">[m1,p1] = <span class="built_in">max</span>(x)	#m1表示最大值，p1表示对应的位置的元素</span><br><span class="line">#求最大值及对应位置的元素</span><br><span class="line">[m2,p2] = <span class="built_in">min</span>(x)	#m2表示最小值，p2表示对应位置的元素</span><br><span class="line">#求向量x中所有元素的和</span><br><span class="line">y = sum(x)			</span><br><span class="line">#求x中所有元素的平均值</span><br><span class="line">y = <span class="built_in">mean</span>(x)</span><br><span class="line">#求向量x的lp范数</span><br><span class="line">y = norm(x,p)</span><br><span class="line">#求向量的标准差</span><br><span class="line">y = std(x)</span><br><span class="line">#求向量中每个元素的绝对值</span><br><span class="line">y = <span class="built_in">abs</span>(x)</span><br><span class="line">#对向量中的每个元素进行从小到大的排序，p表示位置组成的变量</span><br><span class="line">[y,p] = <span class="built_in">sort</span>(x)				#正序排序</span><br><span class="line">[y,p] = <span class="built_in">sort</span>(x,<span class="string">&#x27;descend&#x27;</span>)	#倒序排序</span><br></pre></td></tr></table></figure>



<h3 id="矩阵的基本命令"><a href="#矩阵的基本命令" class="headerlink" title="矩阵的基本命令"></a>矩阵的基本命令</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">#求矩阵X的大小，m是行数，n是列数</span><br><span class="line">[m,n] = <span class="built_in">size</span>(X)</span><br><span class="line">#求方阵X的行列式</span><br><span class="line">d = det(X)</span><br><span class="line">#求矩阵X的秩</span><br><span class="line">r = rank(X)</span><br><span class="line">#求矩阵X的迹，即矩阵的主对角线元素之和</span><br><span class="line">T = trace(X)</span><br><span class="line">#求主对角线元素组成的列向量</span><br><span class="line">d = <span class="built_in">diag</span>(X)</span><br><span class="line">#将矩阵X按列排成m X n维矩阵Y，要求X的元素个数为m X n</span><br><span class="line">Y = <span class="built_in">reshape</span>(X,m,n)</span><br><span class="line">#求可逆方阵X的逆矩阵</span><br><span class="line">XT = inv(X)</span><br><span class="line">#求m*n维矩阵X的伪逆矩阵Y，Y是n*m维的</span><br><span class="line">Y = pinv(X)</span><br><span class="line">#求矩阵X的lp范数，默认p=<span class="number">2</span></span><br><span class="line">n = norm(X,p)</span><br><span class="line">#求矩阵X的Frobenius范数，即将所有X的元素平方和开根号</span><br><span class="line">n = norm(X,<span class="string">&#x27;fro&#x27;</span>)</span><br></pre></td></tr></table></figure>



<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">#m*n维<span class="number">0</span>矩阵</span><br><span class="line">A = <span class="built_in">zeros</span>(m,n)</span><br><span class="line">#m*n维全<span class="number">1</span>矩阵</span><br><span class="line">A = <span class="built_in">ones</span>(m,n)</span><br><span class="line">#m*n维全无穷大矩阵</span><br><span class="line">A = <span class="built_in">inf</span>(m,n)</span><br><span class="line">#m*n维不定值矩阵</span><br><span class="line">A = <span class="built_in">nan</span>(m,n)</span><br><span class="line">#m*n维随机矩阵，元素服从（<span class="number">0</span>，<span class="number">1</span>）区间上的均匀分布</span><br><span class="line">A = <span class="built_in">rand</span>(m,n)</span><br><span class="line">#m*n维随机矩阵，元素服从均值为<span class="number">0</span>，标准差为<span class="number">1</span>的正态分布</span><br><span class="line">A = <span class="built_in">randn</span>(m,n)</span><br><span class="line">#生成m*n维单位矩阵</span><br><span class="line">A = <span class="built_in">eye</span>(m,n)</span><br><span class="line">#m阶杨辉三角矩阵</span><br><span class="line">A = <span class="built_in">pascal</span>(x)</span><br><span class="line">#向量x组成的范德蒙德矩阵</span><br><span class="line">A = <span class="built_in">vander</span>(x)</span><br><span class="line">#m阶魔术矩阵，即各行各列，对角线元素之和相等</span><br><span class="line">A = <span class="built_in">magic</span>(m)</span><br></pre></td></tr></table></figure>

<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">#求转置矩阵，在矩阵后面加上.<span class="string">&#x27;</span></span><br><span class="line"><span class="string">A = [1,2,3;4,5,6]</span></span><br><span class="line"><span class="string">B = A.&#x27;</span></span><br><span class="line">#求共轭转置矩阵，在矩阵后面加上<span class="string">&#x27;</span></span><br><span class="line"><span class="string">C = A&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#提取第i行第j列的元素</span><br><span class="line">A(i,j)</span><br><span class="line">#提取第i行的元素</span><br><span class="line">A(i,:)</span><br><span class="line">#提取第j列的元素</span><br><span class="line">A(:,j)</span><br><span class="line">#删除第j列的元素</span><br><span class="line">A(:,j) = []</span><br><span class="line">#删除第1和3行的元素</span><br><span class="line">A([1,3],:) = []</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>matlab</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>”python--random“</title>
    <url>/2022/02/09/python-random/</url>
    <content><![CDATA[<p>随机生产一个取值范围在10~100的整数：random.randint(10,100)</p>
<span id="more"></span>

<p>一个比较重要的语法：</p>
<p>random.randint(1~10)假设生成的随机数是1</p>
<p>random.randint(1~10)假设生成的随机数是3</p>
<p>random.randint(1~10)假设生成的随机数是6</p>
<p>我们使用random.setstate(x)</p>
<p>在后面我们再使用三次</p>
<p>random.randint(1~10）</p>
<p>三次生成的数分别是1，3，6，所以可以推断出setstate的作用是把前三次生成的随机数变成一个固定的状态再后面再生成！</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>”python--一些函数“</title>
    <url>/2022/02/09/python-%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p> bool()：判断括号里面的结果是真还是假。</p>
<p>真的情况：在括号里面加引号，引号里面有任何值的结果都是真以及直接输入true（不加引号）</p>
<p>假的情况：在引号里面有引号但是引号里面什么都没有以及直接输入false</p>
<span id="more"></span>

<p>以下是定义为false的情况：</p>
<p><img src="https://img-blog.csdnimg.cn/91c7d524a1064e67a99244784f03bcc4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python--元组</title>
    <url>/2022/02/11/python-%E5%85%83%E7%BB%84/</url>
    <content><![CDATA[<h3 id="包含了元组中的大部分操作"><a href="#包含了元组中的大部分操作" class="headerlink" title="包含了元组中的大部分操作"></a>包含了元组中的大部分操作</h3><span id="more"></span>

<p>1.元组类似于数组，但是元组<strong>可以</strong>不带括号表示，如：数组：（1，2，3），元组：1，2，3。但是建议最好一直加上，增加代码的可读性。</p>
<p>2.不可以改变元组里面的数，如：a[1] = 9 是不可取的。正是因为元组不能修改，所以相对于数组来说安全性更高。</p>
<p>3.切片的翻转操作：a[::-1] 会把元组里面的所有的数进行翻转。</p>
<p>4.大部分的函数操作是和数组操作一样的：index操作，count操作等等都和数组是一样的</p>
<p>5.元组的嵌套：</p>
<p>s=(1,2,3)</p>
<p>t=(4,5,6)</p>
<p>w=s , t</p>
<p>print(w)</p>
<p>输出w的结果是((1,2,3),(4,5,6))</p>
<p>6.元组的迭代：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">t=(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">w=s,t</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> w:</span><br><span class="line">	<span class="keyword">for</span> each <span class="keyword">in</span> i:</span><br><span class="line">		<span class="built_in">print</span>(each,end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>

<p>7.在元组中如何生成只有一个元素的元组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = (<span class="number">12</span>,)</span><br><span class="line"><span class="built_in">type</span>(x)</span><br></pre></td></tr></table></figure>

<p>使用type函数查看即可得出x是tuple元组类型，重要的是12后面的逗号！！</p>
<p>8.打包和解包：</p>
<p><strong>打包：即生成一个元组</strong></p>
<p>解包：如下图这样，生成的t有三个元素，分别赋值给x,y,z称之为解包，解包需要注意的是：左侧变量名的数量必须跟右侧元素的数量一致。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = (<span class="number">123</span>,<span class="number">12</span>,<span class="number">1</span>)</span><br><span class="line">x,y,z = t</span><br><span class="line"><span class="built_in">print</span>(x,y,z)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>”python--列表里的函数“</title>
    <url>/2022/02/09/python-%E5%88%97%E8%A1%A8%E9%87%8C%E7%9A%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p> sort()将数组从小到大排序。</p>
<p>reverse（）将数组此时的位置进行倒转</p>
<span id="more"></span>

<p>count（？）问号的内容是数组里面的数据元素，这个函数用于数出这个数据元素在这个数组里面出现了几次</p>
<p>index（？），问号的内容是数组里面的数据元素，这个函数用于显示这个元素在数组里面出现的位置（如果有多个元素相同，那么显示第一个元素的位置）。<strong>可以在后面再加两个参数分别显示查找开始和结束的位置，index(？，start，end)</strong></p>
<p>一个数组赋值给另外一个列表，比如nums数组赋值给nums_two数组：nums_two = nums.copy()</p>
<p><strong>注意：nums这个数组和nums[:]这个数组是表示的同一个</strong></p>
<p><img src="https://img-blog.csdnimg.cn/9ee34faef1d743f089ab46f13fbc0e56.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p><img src="https://img-blog.csdnimg.cn/1918e8c5870c4dcba8d4b42608cde2ad.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_5,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python--字典</title>
    <url>/2022/02/16/python-%E5%AD%97%E5%85%B8/</url>
    <content><![CDATA[<h2 id="字典是另一种可变容器模型，且可存储任意类型对象。"><a href="#字典是另一种可变容器模型，且可存储任意类型对象。" class="headerlink" title="字典是另一种可变容器模型，且可存储任意类型对象。"></a>字典是另一种可变容器模型，且可存储任意类型对象。</h2><span id="more"></span>

<p>字典的每个键值 <strong>key=&gt;value</strong> 对用冒号 <strong>:</strong> 分割，每个对之间用逗号(<strong>,</strong>)分割，整个字典包括在花括号 <strong>{}</strong> 中 ,格式如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;key1 : value1, key2 : value2, key3 : value3 &#125;</span><br></pre></td></tr></table></figure>

<p>在字典中，键是不变的，但是键值是可变的。</p>
<p>下面是一个简单的字典例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">myinformation = &#123;<span class="string">&#x27;name&#x27;</span> = <span class="string">&#x27;denggaozheng&#x27;</span>,<span class="string">&#x27;number&#x27;</span> = <span class="string">&quot;01&quot;</span>,<span class="string">&#x27;grade&#x27;</span> = <span class="string">&#x27;freshman&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>



<h3 id="字典的一些操作"><a href="#字典的一些操作" class="headerlink" title="字典的一些操作"></a>字典的一些操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用大括号 &#123;&#125; 来创建空字典</span></span><br><span class="line">emptyDict = &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 打印字典</span></span><br><span class="line"><span class="built_in">print</span>(emptyDict)					<span class="comment">#&#123;&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查看字典的数量</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Length:&quot;</span>, <span class="built_in">len</span>(emptyDict))	<span class="comment">#0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查看类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(emptyDict))				<span class="comment">#class = dict</span></span><br></pre></td></tr></table></figure>



<h3 id="使用内建函数dict来创建字典"><a href="#使用内建函数dict来创建字典" class="headerlink" title="使用内建函数dict来创建字典"></a>使用内建函数dict来创建字典</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">emptyDict = <span class="built_in">dict</span>()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 打印字典</span></span><br><span class="line"><span class="built_in">print</span>(emptyDict)   					<span class="comment">#&#123;&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查看字典的数量</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Length:&quot;</span>,<span class="built_in">len</span>(emptyDict))		<span class="comment">#0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查看类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(emptyDict))				<span class="comment">#class = dict</span></span><br></pre></td></tr></table></figure>



<h3 id="访问字典里面的值"><a href="#访问字典里面的值" class="headerlink" title="访问字典里面的值"></a>访问字典里面的值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通常使用 字典名[key名]名来访问字典里的键值</span></span><br><span class="line">di = &#123;<span class="string">&#x27;name&#x27;</span> = <span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;num&#x27;</span> = <span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;class&#x27;</span> = <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">#现在我们访问name里的值</span></span><br><span class="line">di[<span class="string">&#x27;name&#x27;</span>] <span class="comment">#就是这么简单</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果访问的是字典里面没有的键，那么会报错！</span></span><br><span class="line">di = &#123;<span class="string">&#x27;name&#x27;</span> = <span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;num&#x27;</span> = <span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;class&#x27;</span> = <span class="number">3</span>&#125;</span><br><span class="line">di[<span class="string">&#x27;number&#x27;</span>] <span class="comment">#error</span></span><br></pre></td></tr></table></figure>



<h3 id="修改字典和删除字典"><a href="#修改字典和删除字典" class="headerlink" title="修改字典和删除字典"></a>修改字典和删除字典</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改字典</span></span><br><span class="line">di = &#123;<span class="string">&#x27;name&#x27;</span> = <span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;num&#x27;</span> = <span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;class&#x27;</span> = <span class="number">3</span>&#125;</span><br><span class="line">di[<span class="string">&#x27;name&#x27;</span> = <span class="string">&#x27;10&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(di[<span class="string">&#x27;name&#x27;</span>])  <span class="comment">#10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除字典</span></span><br><span class="line"><span class="keyword">del</span> di[<span class="string">&#x27;name&#x27;</span>] <span class="comment"># 删除键 &#x27;Name&#x27;</span></span><br><span class="line">di.clear()     <span class="comment"># 清空字典，但是字典还是保留着的</span></span><br><span class="line"><span class="keyword">del</span> di         <span class="comment"># 删除字典</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python--函数</title>
    <url>/2022/02/19/python-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="函数的基本操作"><a href="#函数的基本操作" class="headerlink" title="函数的基本操作"></a><strong>函数的基本操作</strong></h2><span id="more"></span>

<h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用def来定义一个函数myfun,来实现x的累加</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myfunadd</span>(<span class="params">x</span>):</span><br><span class="line">	x = x + <span class="number">1</span></span><br></pre></td></tr></table></figure>



<h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#位置参数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a,b,c</span>):</span><br><span class="line">    <span class="keyword">return</span><span class="string">&quot;&quot;</span>.join((c,b,a)) <span class="comment">#使用join表示在后面添加字符串</span></span><br><span class="line"><span class="built_in">print</span>(func(<span class="string">&quot;我&quot;</span>, <span class="string">&quot;是&quot;</span>, <span class="string">&quot;你&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#帮助函数中的/:代表着/的左边不能指定参数的名字，只能指定其值，但是/的右边就无所谓了。</span></span><br><span class="line"><span class="comment">#我们还可以用*来代替/ *的左边不能用参数的名字，但是右边要用</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">a,*,b,c</span>):</span><br><span class="line">	<span class="built_in">print</span>(a,b,c)</span><br><span class="line">fun(<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;g&quot;</span>) <span class="comment">#error,第二第三个参数要加参数名字</span></span><br><span class="line">fun(<span class="string">&quot;d&quot;</span>,b=<span class="string">&quot;e&quot;</span>,c=<span class="string">&quot;g&quot;</span>) <span class="comment">#d e g</span></span><br></pre></td></tr></table></figure>



<h3 id="收集参数"><a href="#收集参数" class="headerlink" title="收集参数"></a><strong>收集参数</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#收集函数即只指定一个参数，然后允许调用函数时传入任意数量的参数。在函数的形式参数之前加上*号即可</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myfun</span>(<span class="params">*var</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;一共传入了&#123;&#125;个参数&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(var)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第二个参数是&#123;&#125;&quot;</span>.<span class="built_in">format</span>(var[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意只能指定一个带*号的参数，要是需要其他的形式参数，那么需要用到关键字参数。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myfun2</span>(<span class="params">*var,a,b</span>):</span><br><span class="line">    <span class="built_in">print</span>(var,a,b)</span><br><span class="line">myfun2(<span class="string">&quot;Deng&quot;</span>,a=<span class="string">&quot;Gao&quot;</span>,b=<span class="string">&quot;zheng&quot;</span>) <span class="comment">#像这样a和b使用了关键字参数即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在形式参数之前加上两个*代表着传入的参数可以自动转换成为字典</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myfun</span>(<span class="params">**var</span>):</span><br><span class="line">    <span class="built_in">print</span>(var) <span class="comment">#</span></span><br><span class="line">myfun(a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>) <span class="comment">#(&#x27;a&#x27;:&#x27;1&#x27;,&#x27;b&#x27;:&#x27;2&#x27;,&#x27;c&#x27;:&#x27;3&#x27;)即为字典形式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#综合</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xing</span>(<span class="params">a,*b,**c</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a=&quot;</span>,a,<span class="string">&quot;b=&quot;</span>,b,<span class="string">&quot;c=&quot;</span>,c)</span><br><span class="line">xing(<span class="string">&quot;deng&quot;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,c=<span class="string">&quot;zheng&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>#！！！个人总结：1.对于没有星的参数来说，在传入参数时只要出现“，”，那么就会自动跳到下一个参数！2.对于有一个星的参数来说，不能使用关键字参数来传递参数给它！！！否则会报错，它会自动收集剩下的数，即捡破烂。3.对于有两个*的参数来说，你必须要使用关键字参数来传递，因为它会让你的数变成字典！</p>
<p>综上：没有星无所谓使不使用关键字参数，有一个星不能使用关键字参数，两个星必须使用关键字参数。</p>
<h3 id="解包参数"><a href="#解包参数" class="headerlink" title="解包参数"></a>解包参数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#先定义参数的值，然后再传递参数</span></span><br><span class="line">var = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">a,b,c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a,b,c)</span><br><span class="line">fun(*var)  <span class="comment">#1,2,3 这样就是解包啦！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#字典的解包</span></span><br><span class="line">var = (<span class="string">&#x27;a&#x27;</span> = <span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;b&#x27;</span> = <span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;c&#x27;</span> = <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">a,b,c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a,b,c)</span><br><span class="line">fun(**var)</span><br></pre></td></tr></table></figure>



<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在函数中定义函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">funA</span>():</span><br><span class="line">    x = <span class="number">888</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">funB</span>(): <span class="comment">#这个funB函数的作用域就在funA中，外部调用funB会报错的。</span></span><br><span class="line">    	<span class="built_in">print</span>(x)</span><br><span class="line">    funB() </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line">    x=<span class="number">0</span></span><br><span class="line">    y=<span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">x1,y1</span>):</span><br><span class="line">        <span class="built_in">print</span>(x,y)</span><br><span class="line"><span class="comment">#使用下列语句可以调用inner函数！</span></span><br><span class="line">outer()() <span class="comment">#第一个括号表示调用outer函数，第二个括号表示inner函数</span></span><br></pre></td></tr></table></figure>



<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#函数中函数的名称可以做参数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">avg</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> (x+y)/<span class="number">2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">函数名,x,y</span>):</span><br><span class="line">    函数名(x,y)  <span class="comment">#我们这里把参数的名字当中函数名</span></span><br><span class="line">f(avg,<span class="number">2</span>,<span class="number">4</span>) <span class="comment">#这里实现的就是avg(2,4) = 3</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python--字符串</title>
    <url>/2022/02/13/python-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="涵盖了python中大部分的字符串操作"><a href="#涵盖了python中大部分的字符串操作" class="headerlink" title="涵盖了python中大部分的字符串操作"></a>涵盖了python中大部分的字符串操作</h2><span id="more"></span>

<h3 id="大小写字母转换："><a href="#大小写字母转换：" class="headerlink" title="大小写字母转换："></a>大小写字母转换：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#capitalize 将首字母变成大写，其他不变</span></span><br><span class="line">x = <span class="string">&quot;abcde&quot;</span></span><br><span class="line">x.capitalize() <span class="comment">#Abcde</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#casefold 返回一个全部是小写的新字符串</span></span><br><span class="line">x = <span class="string">&quot;AbCdE&quot;</span></span><br><span class="line">x.casefold() <span class="comment">#abcde</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#title 将字符串首字母变成大写，其他的全变成小写</span></span><br><span class="line">x = <span class="string">&quot;aBCDe&quot;</span></span><br><span class="line">x.title() <span class="comment">#Abcde</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#swapcase 将字符串中大小写字母翻转，大写变小写，小写变大写</span></span><br><span class="line">x = <span class="string">&quot;AbCdE&quot;</span></span><br><span class="line">x.swapcase() <span class="comment">#aBcDe</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#upper 将所有字母变大写</span></span><br><span class="line">x = <span class="string">&quot;abcde&quot;</span></span><br><span class="line">x.upper() <span class="comment">#ABCDE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#lower 将所有字母变小写</span></span><br><span class="line">x = <span class="string">&quot;ABCDE&quot;</span></span><br><span class="line">x.lower() <span class="comment">#abcde</span></span><br><span class="line"><span class="comment">#关于casefold和lower：casefold比lower更加强大。casefold可以处理包括英文字符在内的诸多字符类型，但是lower只能处理英文字符。</span></span><br></pre></td></tr></table></figure>



<h3 id="左中右对齐"><a href="#左中右对齐" class="headerlink" title="左中右对齐"></a>左中右对齐</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用对齐有一个条件：在center等的括号内的数字要大于字符串的长度才能实现此功能！</span></span><br><span class="line">x = <span class="string">&quot;你真厉害！&quot;</span> <span class="comment">#这里一共有五个字符长度，在center括号内的数字需要大于五个字符</span></span><br><span class="line">x.center(<span class="number">7</span>) <span class="comment">#&quot; 你真厉害！ &quot;</span></span><br><span class="line">x.ljust(<span class="number">7</span>)  <span class="comment">#&quot;你真厉害！  &quot;</span></span><br><span class="line">x.rjust(<span class="number">7</span>)  <span class="comment">#&quot;  你真厉害！&quot;</span></span><br><span class="line">x.zfill(<span class="number">9</span>)  <span class="comment">#&quot;0000你真厉害d！&quot;右对齐，并且用0填充左侧</span></span><br><span class="line"><span class="comment">#在后面可以自定义空格中填充的字符串</span></span><br><span class="line">x.center(<span class="number">11</span>,<span class="string">&quot;噢&quot;</span>) <span class="comment">#&quot;噢噢噢你真厉害！噢噢噢&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="寻找字符串"><a href="#寻找字符串" class="headerlink" title="寻找字符串"></a>寻找字符串</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#count统计字符在字符串中出现的次数</span></span><br><span class="line">x = <span class="string">&quot;上海的自来水来自海上&quot;</span></span><br><span class="line">x.count(<span class="string">&quot;自&quot;</span>) <span class="comment">#出现了两次，所以是2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#find查找字符在字符串中第一次出现的位置，rfind则是相反方向的查找（从右往左查找）</span></span><br><span class="line">x = <span class="string">&quot;上海的自来水来自海上&quot;</span></span><br><span class="line">x.find(<span class="string">&quot;海&quot;</span>)  <span class="comment">#1</span></span><br><span class="line">x.rfind(<span class="string">&quot;海&quot;</span>) <span class="comment">#8</span></span><br><span class="line">x.find(<span class="string">&quot;去&quot;</span>)  <span class="comment">#如果在字符串中找不到字符则返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#index和find类似，但是如果找不到会抛出异常</span></span><br><span class="line">x.index(<span class="string">&quot;去&quot;</span>) <span class="comment">#error:...</span></span><br></pre></td></tr></table></figure>



<h3 id="字符串替换和表格转换"><a href="#字符串替换和表格转换" class="headerlink" title="字符串替换和表格转换"></a>字符串替换和表格转换</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#replace方法用于将前后的字符串进行对调</span></span><br><span class="line">x = <span class="string">&quot;上海自来水来自海上&quot;</span></span><br><span class="line">x.replace(<span class="string">&quot;上海&quot;</span>,<span class="string">&quot;北京&quot;</span>) <span class="comment">#北京自来水来自海上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建表格maketrans,注意：在maketrans中字符串的长度一定要匹配，否则会报如下错误：ValueError: the first two maketrans arguments must have equal length</span></span><br><span class="line">table = <span class="built_in">str</span>.maketrans(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>)</span><br><span class="line"><span class="string">&quot;ghi&quot;</span>.translate(table)</span><br></pre></td></tr></table></figure>



<h3 id="字符串的判断（全部返回bool类型）"><a href="#字符串的判断（全部返回bool类型）" class="headerlink" title="字符串的判断（全部返回bool类型）"></a>字符串的判断（全部返回bool类型）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#startwith判断字符是否出现在字符串的开始位置</span></span><br><span class="line">x = <span class="string">&quot;我爱python&quot;</span></span><br><span class="line">x.startwith(<span class="string">&quot;我&quot;</span>) <span class="comment">#true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#同理endswith判断字符是否出现在字符串的结束位置</span></span><br><span class="line">x = <span class="string">&quot;我爱python&quot;</span></span><br><span class="line">x.endswith(<span class="string">&quot;o&quot;</span>) <span class="comment">#false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#startswith和endswith的进阶，可以自定义起始和结束位置</span></span><br><span class="line">startswith(<span class="string">&quot;我&quot;</span>,<span class="number">1</span>) <span class="comment">#表示从“1”的位置开始，此时字符串变成了“爱python”</span></span><br><span class="line">endswith(<span class="string">&quot;on&quot;</span>,<span class="number">0</span>,<span class="number">4</span>) <span class="comment">#表示从“0”的地方开始，在“4”的位置结束，此时字符串变成了“我爱pyt”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#istitle判断字符串中是否都是以大写字母开头，其余的都是小写</span></span><br><span class="line">x = <span class="string">&quot;Abc&quot;</span></span><br><span class="line">x.istitle() <span class="comment">#true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#isupper判断字符串里面是否都是大写字母</span></span><br><span class="line"><span class="comment">#islower判断字符串里面是否都是小写字母</span></span><br><span class="line">x = <span class="string">&quot;ABC&quot;</span></span><br><span class="line">x.isupper() <span class="comment">#true</span></span><br><span class="line">x.islower() <span class="comment">#false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#isalpha判断字符串是否全部由字母构成（存在空格也不算！）</span></span><br><span class="line">x=<span class="string">&quot;ABCDE &quot;</span></span><br><span class="line">x.isalpha() <span class="comment">#false,因为我有空格的存在</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#isspace判断是否全部由空白字符构成，转义字符，tab，space全部都算是空白字符</span></span><br><span class="line"><span class="string">&quot;	\n \t &quot;</span>.space() <span class="comment">#true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#isprintable判断字符串所有元素是否都是可打印字符，注意细节：转义字符不是可打印字符！！</span></span><br><span class="line"><span class="string">&quot;我爱python \n&quot;</span>.isprintable() <span class="comment">#false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#isdecimal(),isdigit(),isnumeric()都是判断字符串中是否都是数字的方法。但是我们通常使用isalnum()方法，它是一个集大成者，只要上面三个方法中任意一个返回true，那么isalnum就返回true</span></span><br><span class="line">x = <span class="string">&quot;123456&quot;</span></span><br><span class="line">x.isalum() <span class="comment">#true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#isidentifier判断是否是python承认的变量命名</span></span><br><span class="line"><span class="string">&quot;I love python&quot;</span>.isidentifier() <span class="comment">#false</span></span><br><span class="line"><span class="string">&quot;I_love_python&quot;</span>.isidentifier() <span class="comment">#true</span></span><br></pre></td></tr></table></figure>

<h3 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#lstrip去除左侧的空白</span></span><br><span class="line"><span class="comment">#rstrip去除右侧的空白</span></span><br><span class="line"><span class="comment">#strip左右的空白都不要</span></span><br><span class="line"><span class="string">&quot;	左侧不要留白&quot;</span>.lstrip() <span class="comment">#&quot;左侧不要留白&quot;</span></span><br><span class="line"><span class="string">&quot;右侧不要留白		&quot;</span>.rstrip() <span class="comment">#&quot;右侧不要留白&quot;</span></span><br><span class="line"><span class="comment">#也可以自定义去除，但是其实是从左或者从右去除到与传入字符没有相同才停止，即匹配来去除，而不是只是删除对应的字符！</span></span><br><span class="line"><span class="string">&quot;www.dopagip00.com&quot;</span>.lstrip(abcd) <span class="comment">#&quot;dopagip00.com&quot;</span></span><br><span class="line"><span class="string">&quot;www.dopagip00.com&quot;</span>.rstrip(abcd) <span class="comment">#&quot;www.dopagip00&quot;</span></span><br><span class="line"><span class="string">&quot;www.dopagip00.com&quot;</span>.strip(abcd) <span class="comment">#&quot;dopagip00&quot;</span></span><br><span class="line"><span class="comment">#对应上面的代码实际上去除的不是abcd（根本不存在abcd）去除的是abcd对应的左右分别四个字符。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用removeprefix(prefix)--&gt;前缀和removesuffix(suffix)--&gt;后缀去除一个特定的子字符串</span></span><br><span class="line"><span class="string">&quot;www.dopagip00.com&quot;</span>.removeprefix(www.) <span class="comment">#&quot;dopagip00.com&quot;</span></span><br><span class="line"><span class="string">&quot;www.dopagip00.com&quot;</span>.removesuffix(.com) <span class="comment">#&quot;www.dopagip00&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#只切分一次：切割字符串,partition表示以.进行切割从右往左寻找分隔符,只找一个！！找到一个就不找了！rpartition表示从右往左寻找分隔符，同样只寻找一个。</span></span><br><span class="line"><span class="string">&quot;www.dopagip00.com&quot;</span>.partition(<span class="string">&quot;.&quot;</span>) <span class="comment">#(&#x27;www&#x27;,&#x27;.&#x27;,&#x27;dopagip00.com&#x27;)</span></span><br><span class="line"><span class="string">&quot;www.dopagip00.com&quot;</span>.rpartition(<span class="string">&quot;.&quot;</span>) <span class="comment">#(&#x27;www.dopagip00&#x27;,&#x27;.&#x27;,&#x27;com&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#切分到没有为止：split按照给定的字符进行切分，默认切分空格。在指定字符的后面一个参数还可以指定分割的次数。</span></span><br><span class="line"><span class="string">&quot;www dopagip com&quot;</span>.split() <span class="comment">#(&#x27;www&#x27;,&#x27;dopagip&#x27;,&#x27;com&#x27;)</span></span><br><span class="line"><span class="string">&quot;www.dopagip.com&quot;</span>.split(<span class="string">&quot;.&quot;</span>) <span class="comment">#(&#x27;www&#x27;,&#x27;dopagip&#x27;,&#x27;com&#x27;)</span></span><br><span class="line"><span class="string">&quot;www.dopagip.com&quot;</span>.rsplit(<span class="string">&quot;.&quot;</span>,<span class="number">1</span>) <span class="comment">#我这里指定切割一次，而且是从右往左切，结果：										 (&quot;www.dopagip&quot;,&quot;com&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#splitlines是以&#x27;行&#x27;进行分割。</span></span><br><span class="line"><span class="string">&quot;www\ndopagip00\ncom&quot;</span>.splitlines() <span class="comment">#(&#x27;www&#x27;,&#x27;dopagip00&#x27;,&#x27;com&#x27;)</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">#join是把列表的数组组合起来成字符串。</span></span><br><span class="line"><span class="string">&quot;.&quot;</span>.join([<span class="string">&#x27;www&#x27;</span>,<span class="string">&#x27;dopagip00&#x27;</span>,<span class="string">&#x27;com&#x27;</span>]) <span class="comment">#www.dopagip00.com</span></span><br></pre></td></tr></table></figure>



<h3 id="格式化字符串（占位）"><a href="#格式化字符串（占位）" class="headerlink" title="格式化字符串（占位）"></a>格式化字符串（占位）</h3><p>其实和c语言的%d,%s占位符类似，只不过python是用{}来占位 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#format方法format里面的参数就是占位的字符，format里面的参数与&#123;&#125;对应，有几个参数就有几个&#123;&#125;</span></span><br><span class="line">a = <span class="string">&quot;python&quot;</span></span><br><span class="line">b = <span class="string">&quot;C&quot;</span></span><br><span class="line">c = <span class="string">&quot;PHP&quot;</span></span><br><span class="line">d = <span class="string">&quot;JAVA&quot;</span></span><br><span class="line"><span class="string">&quot;我爱 &#123;&#125; &quot;</span>.<span class="built_in">format</span>(a) <span class="comment">#我爱python</span></span><br><span class="line"><span class="string">&quot;我爱&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>.<span class="built_in">format</span>(a,b,c,d) <span class="comment">#我爱python,C,PHP,JAVA</span></span><br><span class="line"><span class="comment">#可以在花括号中间加入数字表示占位的顺序,甚至可以在括号内加变量名，然后在format里面给变量赋值</span></span><br><span class="line">a = <span class="string">&quot;python&quot;</span></span><br><span class="line">b = <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我爱&#123;1&#125;,&#123;0&#125;&quot;</span>.<span class="built_in">format</span>(a, b)) <span class="comment">#我爱python，C</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我爱&#123;0&#125;,&#123;1&#125;&quot;</span>.<span class="built_in">format</span>(a, b)) <span class="comment">#我爱C，python</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我爱&#123;py&#125;,&#123;ja&#125;&quot;</span>.<span class="built_in">format</span>(py=<span class="string">&quot;python&quot;</span>,ja=<span class="string">&quot;java&quot;</span>)) <span class="comment">#我爱python,java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#千分符</span></span><br><span class="line"><span class="string">&quot;&#123;:,&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">1234</span>) <span class="comment">#1,234</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#保留小数点后x位即.xf，类别c语言%.xf</span></span><br><span class="line"><span class="string">&quot;&#123;.2f&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">3.14159</span>) <span class="comment">#3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#保留x位数,即.xg</span></span><br><span class="line"><span class="string">&quot;&#123;.2g&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">3.14159</span>) <span class="comment">#3.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#截取x位字符，不能用于数字，会报错！！</span></span><br><span class="line"><span class="string">&quot;&#123;:.2&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;我爱py&quot;</span>)  <span class="comment">#我爱</span></span><br><span class="line"><span class="string">&quot;&#123;:.2&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">1234</span>)     <span class="comment">#error</span></span><br></pre></td></tr></table></figure>

<p>：后面可以加很多值，如下表：（参数即format里面的参数）</p>
<p><img src="C:\Users\me\AppData\Roaming\Typora\typora-user-images\image-20220213212943323.png" alt="image-20220213212943323"></p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>”python--字符串“</title>
    <url>/2022/02/09/python-%E5%AD%97%E7%AC%A6%E4%B8%B2OLD/</url>
    <content><![CDATA[<p>在打印文本的时候如果不想显示转义字符的结果，可以在字符串的引号前面加上r。</p>
<span id="more"></span>

<p>如：1.不加r的时候:print(“D:\three\two\one\now”)</p>
<p>​     显示的结果是：<img src="https://img-blog.csdnimg.cn/cec7ee435319424bad8f796d47085fe4.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>2.加上r的时候: print(<strong>r</strong>“D:\three\two\one\now”)</p>
<p>​     显示的结果是：<img src="https://img-blog.csdnimg.cn/f7f5f4fca14d45db930067db3de40836.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p><strong>加上r代表这后面的字符串显示原始字符！</strong></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python--序列</title>
    <url>/2022/02/15/python-%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="包含了大部分的序列的操作和函数"><a href="#包含了大部分的序列的操作和函数" class="headerlink" title="包含了大部分的序列的操作和函数"></a>包含了大部分的序列的操作和函数</h2><span id="more"></span>

<h3 id="序列中-和-的操作和is，in函数"><a href="#序列中-和-的操作和is，in函数" class="headerlink" title="序列中+和*的操作和is，in函数"></a>序列中+和*的操作和is，in函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># +的操作</span></span><br><span class="line">i = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">i = i + i <span class="comment"># (1,2,3,1,2,3)</span></span><br><span class="line">a = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">id</span>(a) <span class="comment">#1440589908416</span></span><br><span class="line">a += a </span><br><span class="line"><span class="built_in">id</span>(a) <span class="comment">#1440589908416</span></span><br><span class="line"><span class="comment">#发现两次的id是一模一样的，说明变量（对象）的id是固定的，不管对它进行什么样的加法运算！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># *的操作</span></span><br><span class="line">i = i * <span class="number">2</span> <span class="comment"># (1,2,3,1,2,3)</span></span><br><span class="line">a = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">id</span>(a) <span class="comment">#1440589908416</span></span><br><span class="line">a *= a </span><br><span class="line"><span class="built_in">id</span>(a) <span class="comment">#1440512989913</span></span><br><span class="line"><span class="comment">#发现这两次的id并不相同。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#加法和乘法结果的id值并不相似，为此，python推出了is和is not 函数来判断两个对象是否是相同的</span></span><br><span class="line">x = <span class="string">&quot;dgz&quot;</span></span><br><span class="line">y = <span class="string">&quot;dgz&quot;</span></span><br><span class="line">x <span class="keyword">is</span> y <span class="comment">#true,说明x和y是相同的对象</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a <span class="keyword">is</span> b <span class="comment">#false,说明a和b不是相同的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#in和not in函数，比如我们想知道字符串&quot;dgz&quot;里面是否含有&quot;d&quot;字符，我们可以使用：</span></span><br><span class="line"><span class="string">&quot;d&quot;</span> <span class="keyword">in</span> <span class="string">&quot;dgz&quot;</span> <span class="comment">#true</span></span><br><span class="line"><span class="string">&quot;d&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&quot;dgz&quot;</span> <span class="comment">#false</span></span><br></pre></td></tr></table></figure>



<h3 id="删除对象"><a href="#删除对象" class="headerlink" title="删除对象"></a>删除对象</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除全部对象</span></span><br><span class="line">x = <span class="number">12</span></span><br><span class="line">y = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="keyword">del</span> x,y <span class="comment">#我们会发现对象x和y全部不见了！</span></span><br><span class="line"><span class="built_in">print</span>(x) <span class="comment">#error,此时会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除数组里面的部分对象</span></span><br><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">del</span> x[<span class="number">1</span>:<span class="number">4</span>] <span class="comment">#x = [1,5]最后一个是能取到的，左闭右开</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除数组所有内容，但是保留着数组的变量对象</span></span><br><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">del</span> x[:] 或 <span class="keyword">del</span> x[::] 或 <span class="keyword">del</span> x[::<span class="number">1</span>]</span><br></pre></td></tr></table></figure>



<h3 id="函数：list-、tuple-、str"><a href="#函数：list-、tuple-、str" class="headerlink" title="函数：list()、tuple()、str()"></a>函数：list()、tuple()、str()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#list() 将可迭代对象或者元组，数组等等变成列表</span></span><br><span class="line">x = <span class="string">&quot;denggaozheng&quot;</span></span><br><span class="line">x.<span class="built_in">list</span>() <span class="comment">#[&#x27;d&#x27;,&#x27;g&#x27;,...,&#x27;g&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#tuple() 将可迭代对象或者数组变成元组</span></span><br><span class="line">x = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">x.<span class="built_in">tuple</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">#str() 将可迭代对象等转换成字符串</span></span><br><span class="line">x = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">x.__<span class="built_in">str</span>()__ <span class="comment">#[1,2,3,4]字符串类型的</span></span><br></pre></td></tr></table></figure>



<h3 id="函数：max-和min"><a href="#函数：max-和min" class="headerlink" title="函数：max()和min()"></a>函数：max()和min()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#都知道min找最小值，max找最大值，那就举一些极端的例子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果传入的数组是空的，那么找最小最大的时候会报错的</span></span><br><span class="line">s = []</span><br><span class="line"><span class="built_in">min</span>(s) <span class="comment">#error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#min max函数都可以传入默认值default</span></span><br><span class="line">s = []</span><br><span class="line"><span class="built_in">min</span>(s,default = <span class="string">&quot;啥都没有！&quot;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="函数：sum-、len"><a href="#函数：sum-、len" class="headerlink" title="函数：sum()、len()"></a>函数：sum()、len()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sum() 用于求和,可以设定求和开始的位置，比如我从一百开始加s这个数组</span></span><br><span class="line">s = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="built_in">sum</span>(s,start = <span class="number">100</span>) <span class="comment">#100+1+2+3+1+2=109</span></span><br><span class="line"><span class="comment">#如果start=100报错，那就直接sum(s,100)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#len() 方法返回对象（字符、列表、元组等）长度或项目个数</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;runoob&quot;</span></span><br><span class="line"><span class="built_in">len</span>(<span class="built_in">str</span>) <span class="comment">#6</span></span><br><span class="line"> </span><br><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">len</span>(l) <span class="comment">#5</span></span><br></pre></td></tr></table></figure>



<h3 id="函数：sorted-和reversed"><a href="#函数：sorted-和reversed" class="headerlink" title="函数：sorted()和reversed()"></a>函数：sorted()和reversed()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#传什么参数给sorted()他都可以操作!</span></span><br><span class="line"><span class="comment">#sorted()返回的是一个全新的列表(对参数列表进行排序之后得到的新列表),而原列表不会发生改变。</span></span><br><span class="line">s = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">sorted</span>(s) <span class="comment">#[1,2,3,4]</span></span><br><span class="line"><span class="built_in">print</span>(s) <span class="comment">#[1,4,2,5]</span></span><br><span class="line"><span class="comment">#sort会对原先的列表进行修改</span></span><br><span class="line">s.sort() <span class="comment">#[1,2,4,5]</span></span><br><span class="line"><span class="comment">#sorted还可以进行翻转操作</span></span><br><span class="line"><span class="built_in">sorted</span>(s,reverse = true)</span><br><span class="line"></span><br><span class="line"><span class="comment">#reversed返回的是迭代器，参数里面可以放数组元组等等</span></span><br><span class="line">a = <span class="built_in">range</span>(<span class="number">5</span>, <span class="number">9</span>)</span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">reversed</span>(a)) <span class="comment">#[5,6,7,8,9]</span></span><br></pre></td></tr></table></figure>



<h3 id="函数：all-和any"><a href="#函数：all-和any" class="headerlink" title="函数：all()和any()"></a>函数：all()和any()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#all函数判断可迭代对象中是否所有元素的值都为真，其中0是假</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line"><span class="built_in">all</span>(a) <span class="comment">#false</span></span><br><span class="line"><span class="comment">#any函数判断可迭代对象中是否存在为真的值，其中0是假</span></span><br><span class="line">a = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line"><span class="built_in">any</span>(a) <span class="comment">#true</span></span><br></pre></td></tr></table></figure>



<h3 id="函数：enumerate"><a href="#函数：enumerate" class="headerlink" title="函数：enumerate()"></a>函数：enumerate()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#enumerate函数用于将一个可遍历的数据对象(列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，加入start表示下标开始的位置。一般用在 for 循环当中，通常与list函数搭配使用。</span></span><br><span class="line">seasons = [<span class="string">&#x27;Spring&#x27;</span>, <span class="string">&#x27;Summer&#x27;</span>, <span class="string">&#x27;Fall&#x27;</span>, <span class="string">&#x27;Winter&#x27;</span>]</span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">enumerate</span>(seasons, start=<span class="number">1</span>)) <span class="comment">#[(1, &#x27;Spring&#x27;), (2, &#x27;Summer&#x27;), (3, &#x27;Fall&#x27;), (4, &#x27;Winter&#x27;)]</span></span><br></pre></td></tr></table></figure>



<h3 id="函数：zip-常用！！"><a href="#函数：zip-常用！！" class="headerlink" title="函数：zip()常用！！"></a>函数：zip()常用！！</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#zip函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">c = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">zipped = <span class="built_in">zip</span>(a,b)     <span class="comment"># 打包为元组的列表 [(1, 4), (2, 5), (3, 6)]</span></span><br><span class="line"><span class="built_in">zip</span>(a,c)              <span class="comment"># 元素个数与最短的列表一致 [(1, 4), (2, 5), (3, 6)]</span></span><br><span class="line"><span class="built_in">zip</span>(*zipped)          <span class="comment"># 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式 [(1, 2, 3), (4, 5, 6)]</span></span><br><span class="line"><span class="comment">#拓展：如果长的数组和短的数组进行zip，而我们不想按最短的来匹配，可以导入itertools</span></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = itertools.zip_longest(a,b)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(it)) <span class="comment">#[(1, 1), (2, 2), (3, 3), (4, 4), (5, None), (6, None), (7, None)]</span></span><br></pre></td></tr></table></figure>



<h3 id="函数：map-常用！-和filter函数、iter函数"><a href="#函数：map-常用！-和filter函数、iter函数" class="headerlink" title="函数：map()常用！!和filter函数、iter函数"></a>函数：map()常用！!和filter函数、iter函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#map函数会根据提供的函数对指定序列做映射。第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次function 函数返回值的新列表。默认返回的是迭代器：&lt;map object at 0x000001289EC93490&gt;，但是使用list函数可以让他变成数组。</span></span><br><span class="line"><span class="comment">#先定义一个函数fun</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">x</span>):</span><br><span class="line">    x = x + <span class="number">1</span></span><br><span class="line">s = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">map</span>(fun,s)) <span class="comment">#[2,3,4,5,6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#map函数传递的是包含计算结果的数，而filter函数传递的是计算结果为真的数（就没有0了）。</span></span><br><span class="line"><span class="comment">#例如我现在想要找到下面字符串中的大写字符</span></span><br><span class="line">strn = <span class="string">&quot;DengGaoZheng&quot;</span></span><br><span class="line"><span class="built_in">filter</span>(<span class="built_in">str</span>.isupper,strn) <span class="comment">#[&#x27;D&#x27;,&quot;G&quot;,&#x27;Z&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#iter函数：把一个可迭代对象变成迭代器</span></span><br><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">y = <span class="built_in">iter</span>(x) <span class="comment">#这时候y就是一个迭代器啦！</span></span><br><span class="line"><span class="comment">#使用next函数可以将迭代器y中的元素逐一取出来！</span></span><br><span class="line"><span class="built_in">next</span>(y) <span class="comment">#1</span></span><br><span class="line"><span class="built_in">next</span>(y) <span class="comment">#2</span></span><br><span class="line"><span class="built_in">next</span>(y) <span class="comment">#3</span></span><br><span class="line"><span class="built_in">next</span>(y) <span class="comment">#当我们拿完了迭代器里面的元素，再使用next的时候就会报异常！我们还可以自定义报异常的值，在next的第二个参数</span></span><br><span class="line"><span class="built_in">next</span>(y,<span class="string">&quot;已经没了!&quot;</span>) <span class="comment">#已经没了！</span></span><br></pre></td></tr></table></figure>



<h3 id="迭代器，迭代对象"><a href="#迭代器，迭代对象" class="headerlink" title="迭代器，迭代对象"></a>迭代器，迭代对象</h3><p>首先要知道一个迭代器一定是一个迭代对象！</p>
<p>区别是：迭代对象是可以反复使用的，而迭代器是一次性的。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>”python--深拷贝和浅拷贝“</title>
    <url>/2022/02/09/python-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<p><strong>假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。</strong></p>
<span id="more"></span>

<p>浅拷贝的实现方法：</p>
<p>x=…..</p>
<p>y=copy.copy(x)</p>
<p>深拷贝的实现方法：</p>
<p>x=…</p>
<p>y=copy.deepcopy(x)</p>
<p>其中第一个copy是copy模块</p>
<p><img src="https://img-blog.csdnimg.cn/550469b3a1764d3d9357df29840651d2.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>这样的copy是浅拷贝</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>”python--除和地板除“</title>
    <url>/2022/02/09/python-%E9%99%A4%E5%92%8C%E5%9C%B0%E6%9D%BF%E9%99%A4/</url>
    <content><![CDATA[<p>3/2=1.5这个谁都懂</p>
<p>但是3//2=1这个代表3/2的结果向下取整，称之为地板除。</p>
<span id="more"></span>

<p>如-5//2，先算-5/2=-2.5，再向下取整，得-3。</p>
<p>我们还可以使用python的内置函数divmod（）</p>
<p>如divmod(3,2)=(1,1)结果中的第一个1代表着3//2的结果，第二个1代表着3%2的结果。</p>
<p>内置函数abs，如abs（x）意思是取x的绝对值</p>
<p>任何数据类型后面加括号加值的结果都是强制转换成该数据类型。</p>
<p>如：x=2.5</p>
<p>int（x）的结果就是2，向下取整！</p>
<p>pow(2,3)代表2的三次方，和2**3的效果一样。</p>
<p>pow（2,3,4）代表着2**3%4即2的三次方结果除四的余数！</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python--集合</title>
    <url>/2022/02/17/python-%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="一些集合的基本操作"><a href="#一些集合的基本操作" class="headerlink" title="一些集合的基本操作"></a>一些集合的基本操作</h1><span id="more"></span>

<h2 id="set-的集合表示方法"><a href="#set-的集合表示方法" class="headerlink" title="set()的集合表示方法"></a>set()的集合表示方法</h2><h3 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#可以用&#123;&#125;或者set函数创建集合</span></span><br><span class="line"><span class="built_in">type</span>(&#123;<span class="string">&quot;Deng&quot;</span>&#125;) <span class="comment">#class=&quot;set&quot;</span></span><br><span class="line">s = <span class="built_in">set</span>(<span class="string">&quot;Deng&quot;</span>) <span class="comment">#class=&quot;set&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="集合的无序性"><a href="#集合的无序性" class="headerlink" title="集合的无序性"></a>集合的无序性</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建一个集合并且按字符输出可以发现集合是无序的！</span></span><br><span class="line">s = <span class="built_in">set</span>(<span class="string">&quot;Deng&quot;</span>)</span><br><span class="line">D <span class="keyword">in</span> s <span class="comment">#True</span></span><br><span class="line">d <span class="keyword">not</span> <span class="keyword">in</span> s <span class="comment">#True</span></span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> s:</span><br><span class="line">    <span class="built_in">print</span>(each) <span class="comment"># n e D g 我们可以发现输出的结果是无序的，证明了集合的无序性！</span></span><br></pre></td></tr></table></figure>



<h3 id="集合会自动去重"><a href="#集合会自动去重" class="headerlink" title="集合会自动去重"></a>集合会自动去重</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>])) <span class="comment">#[1,2,3,4]就把多出来的3和4去掉了！</span></span><br></pre></td></tr></table></figure>



<h3 id="判断两个集合之间是否有关系"><a href="#判断两个集合之间是否有关系" class="headerlink" title="判断两个集合之间是否有关系"></a>判断两个集合之间是否有关系</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#先创建第一个集合</span></span><br><span class="line">D = <span class="built_in">set</span>(<span class="string">&quot;Deng&quot;</span>)</span><br><span class="line"><span class="comment">#使用isdisjoint方法判断两个集合之间是否有关系，具体如下</span></span><br><span class="line">s.isdisjoint(<span class="built_in">set</span>(<span class="string">&quot;python&quot;</span>)) <span class="comment">#False代表两个集合之间是有相关的！判断的依据是两个集合之间有相关的元素重合，那么可见有n重合，所以两个集合之间是有相关的及false</span></span><br><span class="line"><span class="comment">#再判断JAVA</span></span><br><span class="line">s.isdisjoint(<span class="built_in">set</span>(<span class="string">&quot;JAVA&quot;</span>)) <span class="comment">#True代表两个集合无关</span></span><br></pre></td></tr></table></figure>



<h3 id="检测两个集合是否有子集关系"><a href="#检测两个集合是否有子集关系" class="headerlink" title="检测两个集合是否有子集关系"></a>检测两个集合是否有子集关系</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用issubset方法，判断前面是否为后面的子集！</span></span><br><span class="line">s = <span class="built_in">set</span>(<span class="string">&quot;Deng&quot;</span>)</span><br><span class="line"><span class="comment">#判断s是否为后面的子集</span></span><br><span class="line">s.issubset(<span class="built_in">set</span>(<span class="string">&quot;DengGaozheng&quot;</span>)) <span class="comment">#True说明s正是DengGaozheng的子集！</span></span><br></pre></td></tr></table></figure>



<h3 id="检测两个集合是否有超集关系"><a href="#检测两个集合是否有超集关系" class="headerlink" title="检测两个集合是否有超集关系"></a>检测两个集合是否有超集关系</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用issuperset对于A和B来说，A中所有元素都在B中有出现，那么说明B是A的超集！</span></span><br><span class="line">A = <span class="built_in">set</span>(<span class="string">&quot;Deng&quot;</span>)</span><br><span class="line">B = <span class="built_in">set</span>(<span class="string">&quot;DengGaozheng&quot;</span>)</span><br><span class="line">B.issuperset(A) <span class="comment">#True说明B是A的超集！</span></span><br></pre></td></tr></table></figure>



<h3 id="两个集合之间使用交集"><a href="#两个集合之间使用交集" class="headerlink" title="两个集合之间使用交集"></a>两个集合之间使用交集</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#intersection方法</span></span><br><span class="line">s = <span class="built_in">set</span>(<span class="string">&quot;Deng&quot;</span>)</span><br><span class="line">s.intersection(<span class="string">&quot;De&quot;</span>) <span class="comment">#&quot;De&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="两个集合之间使用并集"><a href="#两个集合之间使用并集" class="headerlink" title="两个集合之间使用并集"></a>两个集合之间使用并集</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#union方法</span></span><br><span class="line">s = <span class="built_in">set</span>(<span class="string">&quot;Deng&quot;</span>)</span><br><span class="line">s.union(<span class="built_in">set</span>(<span class="string">&quot;Gaozheng&quot;</span>)) <span class="comment">#&quot;DengGaozheng&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="两个集合之间使用差集"><a href="#两个集合之间使用差集" class="headerlink" title="两个集合之间使用差集"></a>两个集合之间使用差集</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#difference方法，差集即存在于一个集合而不存在于另一个集合的元素</span></span><br><span class="line">s = <span class="built_in">set</span>(<span class="string">&quot;DengGao&quot;</span>)</span><br><span class="line">s.difference(<span class="string">&quot;Deng&quot;</span>) <span class="comment">#&quot;Gao&quot;存在于s中而不存在于&quot;Deng&quot;中</span></span><br></pre></td></tr></table></figure>



<h3 id="管道符"><a href="#管道符" class="headerlink" title="管道符"></a>管道符</h3><p>| 管道符的作用是 把 管道符左边的的输出 当做右边命令后面待处理的结果。相当于并集的作用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;Deng&quot;</span></span><br><span class="line">s | <span class="string">&quot;Gao&quot;</span> | <span class="built_in">set</span>(<span class="string">&quot;zheng&quot;</span>) <span class="comment">#这串代码相当于s并&quot;Gao&quot;并set(&quot;zheng&quot;)，结果是&quot;DengGaozheng&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="专属于set的方法"><a href="#专属于set的方法" class="headerlink" title="专属于set的方法"></a>专属于set的方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#update()用来在set创建的集合里面更新元素</span></span><br><span class="line">s = <span class="built_in">set</span>(<span class="string">&quot;Deng&quot;</span>)</span><br><span class="line">s.update(<span class="string">&quot;Gao&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s) <span class="comment">#[&quot;Deng&quot;,&quot;G&quot;,&quot;a&quot;,&quot;o&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#add()用于添加元素</span></span><br><span class="line">s = <span class="built_in">set</span>(<span class="string">&quot;Deng&quot;</span>)</span><br><span class="line">s.add(<span class="string">&quot;Gao&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s) <span class="comment">#&quot;DengGao&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#update和add都可以添加元素，但是区别在于update添加字符串时添加的是单个字符，add添加字符串时添加的是字符串。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#用remove方法删除集合中的元素,如果删除了不存在的元素，那么会抛出异常</span></span><br><span class="line">s = [<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;g&#x27;</span>]</span><br><span class="line">s.remove(<span class="string">&quot;D&quot;</span>) <span class="comment">#[&#x27;e&#x27;,&#x27;n&#x27;,&#x27;g&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pop方法用于随机从集合中弹出一个元素(有点出栈的感觉)</span></span><br><span class="line">s = [<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;g&#x27;</span>]</span><br><span class="line">s.pop() <span class="comment">#&#x27;e&#x27;</span></span><br><span class="line">s.pop() <span class="comment">#&#x27;g&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="frozenset-的集合表示方法"><a href="#frozenset-的集合表示方法" class="headerlink" title="frozenset()的集合表示方法"></a>frozenset()的集合表示方法</h2><h3 id="创建frozenset集合"><a href="#创建frozenset集合" class="headerlink" title="创建frozenset集合"></a>创建frozenset集合</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建frozenset集合</span></span><br><span class="line">s = <span class="built_in">frozenset</span>(<span class="string">&quot;Deng&quot;</span>)</span><br><span class="line"><span class="built_in">type</span>(s) <span class="comment">#class = frozenset</span></span><br></pre></td></tr></table></figure>



<h3 id="可哈希"><a href="#可哈希" class="headerlink" title="可哈希"></a>可哈希</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#整数哈希值：对于整数来说，哈希值永远等于自身的值</span></span><br><span class="line"><span class="built_in">hash</span>(<span class="number">1</span>) <span class="comment">#1</span></span><br><span class="line"><span class="built_in">hash</span>(<span class="number">1.0</span>) <span class="comment">#1.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#列表是不可哈希的</span></span><br><span class="line"><span class="built_in">hash</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">#error!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#哈希配合frozenset可以实现嵌套的集合，这在set里面是实现不了的！</span></span><br><span class="line">x = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">x = <span class="built_in">frozenset</span>(x)</span><br><span class="line">y = &#123;x,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(y)  <span class="comment">#&#123;forzenset(&#123;1,2,3&#125;),4,5&#125;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析-- 误差</title>
    <url>/2022/03/07/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-%E8%AF%AF%E5%B7%AE/</url>
    <content><![CDATA[<h3 id="误差和误差限"><a href="#误差和误差限" class="headerlink" title="误差和误差限"></a>误差和误差限</h3><p>设X* 为X的一个近似值（可大于X也可小于X），有e* =  X-X* ,称e* 为<strong>绝对误差</strong>，简称<strong>误差</strong>。</p>
<p>易得出结论：当绝对误差大于0时，近似值大于真实值，称为<strong>强近似值</strong>；当绝对误差小于0时，近似值小于真实值，称为<strong>弱近似值</strong>。</p>
<p>误差的绝对值不超过某个正数E* ，称这个正数E<em>为近似值的*<em>误差限</em></em> </p>
<h3 id="相对误差和相对误差限"><a href="#相对误差和相对误差限" class="headerlink" title="相对误差和相对误差限"></a>相对误差和相对误差限</h3><p>**相对误差:*<em>指的是近似值e</em> 与真实值X的比值，称为e(r)*（右下角有个小r）</p>
<p><strong>相对误差限：</strong>相对误差不能超过相对误差限E(r)* ，E(r)* =E* / |x*|</p>
<h3 id="绝对误差的计算方法"><a href="#绝对误差的计算方法" class="headerlink" title="绝对误差的计算方法"></a>绝对误差的计算方法</h3><p><strong>注意：绝对误差限一定是一个单位的半个单位，如0.5，0.05，0.005，0.0005等等，那么换成科学计数法的形式就可以变成1/2 * 10^-p</strong></p>
<p><strong>（其中p取正整数！）这时，-p就可以换成另一种表示方法，-p = m-n+1  （其中m是小数点离第一个非0数字的后一位有多远，如123.45的m就是2，而0.00123的m就是-3）（其中n是有几位有效数字如123.45就有5为有效数字，那么n就是5.）通常情况下都是知道了m和n要去求p的！！</strong></p>
<p>例如“派”取近似值3.14，那么|3.14-“派”| = 0.0015926&lt;=0.005=1/2 * 10^-2，则绝对误差限就是1/2 * 10^-2</p>
<h3 id="相对误差的计算方法"><a href="#相对误差的计算方法" class="headerlink" title="相对误差的计算方法"></a>相对误差的计算方法</h3><p>若近似值有n为有效数字，其中a是近似值的个位数。</p>
<p>E(r)*&lt;=1/2a * 10^-(n-1)</p>
<h3 id="误差估计中的重要公式"><a href="#误差估计中的重要公式" class="headerlink" title="误差估计中的重要公式"></a>误差估计中的重要公式</h3><p>E(x1* +- x2* ) = E(x1* ) +- E(x2*)</p>
<p><em><em>E(x1</em> * x2</em> ) = |x1*| * E(x2*) + |x2 *| * E(x1 *)**这个公式在平常的运算中常常能用得上。</p>
<p>E(x1* / x2* ) = |x1*| * E(x2*) + |x2 *| * E(x1 *) / |x2 *|^2    这是上面那一条的除法运算</p>
<h3 id="误差中的规则"><a href="#误差中的规则" class="headerlink" title="误差中的规则"></a>误差中的规则</h3><p>1.要避免除数的绝对值远远小于被除数绝对值的除法</p>
<p>2.避免出现有效数字少的相减如x=123.401,  y = 123.412  ，那么y-x =0.011只有两位有效数字。</p>
<p>3.防止大数吃掉小数</p>
<p>4.注意简化运算流程，简化运算步骤</p>
]]></content>
      <categories>
        <category>数值分析</category>
      </categories>
      <tags>
        <tag>数值分析</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构--基本概念</title>
    <url>/2022/02/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="本章主要讲解数据结构和算法的基本概念，在文中标有-的是重点内容一定要熟记！"><a href="#本章主要讲解数据结构和算法的基本概念，在文中标有-的是重点内容一定要熟记！" class="headerlink" title="本章主要讲解数据结构和算法的基本概念，在文中标有*的是重点内容一定要熟记！"></a>本章主要讲解数据结构和算法的基本概念，在文中标有*的是重点内容一定要熟记！</h1><span id="more"></span>

<h2 id="数据结构考纲"><a href="#数据结构考纲" class="headerlink" title="数据结构考纲"></a>数据结构考纲</h2><h3 id="数据结构的三要素（考点）"><a href="#数据结构的三要素（考点）" class="headerlink" title="数据结构的三要素（考点）"></a>数据结构的三要素（考点）</h3><p>1.<em>逻辑结构：分为线性结构和非线性结构。*<em>线性结构：线性表，栈，队列；非线性结构：树，图，集合</em></em></p>
<p>2.*存储结构（物理结构）</p>
<p>3.数据的运算</p>
<h3 id="数据结构的五个特征"><a href="#数据结构的五个特征" class="headerlink" title="数据结构的五个特征"></a>数据结构的五个特征</h3><p>有穷性，确定性，可行性，输入，输出</p>
<h3 id="效率的度量（重点-考点）"><a href="#效率的度量（重点-考点）" class="headerlink" title="效率的度量（重点+考点）"></a>效率的度量（重点+考点）</h3><p><strong>时间复杂度</strong>*和空间复杂度（<strong>时间复杂度是重中之重，选择题大题都会出现</strong>）</p>
<h2 id="数据结构知识点"><a href="#数据结构知识点" class="headerlink" title="数据结构知识点"></a>数据结构知识点</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>1.数据：数据是<strong>信息的载体</strong>，是描述客观事物属性的数，字符及所有<strong>能输入到计算机中并被计算机程序识别</strong>和处理的符号集合。数据是计算机程序加工的原料。</p>
<p>（1）数值型数据：整数，实数等</p>
<p>（2）非数值型数据：文字，图像，图形，声音等</p>
<p>2.数据元素：<strong>数据元素</strong>是数据的基本单位，通常作为一个整体考虑。也称为<strong>记录</strong>、<strong>顶点</strong>、<strong>结点</strong>。</p>
<p>3.数据项：一个数据元素由若干个数据项组成，<strong>数据项</strong>是数据元素中不可分割的<strong>最小单位</strong>。</p>
<p>4.数据结构：<strong>数据结构</strong>是数据相互之间存在<strong>一种或多种特定关系</strong>的数据元素的集合。 </p>
<p>（1）<strong>逻辑结构</strong>：数据元素之间的逻辑关系</p>
<p>​    <strong>a.线性结构</strong>：有且仅有一个开始和一个终端结点，并且所有节点最多只有一个之间前趋和一个直接后继。</p>
<p>​                            例如：<strong>线性表、栈、队列、串</strong></p>
<p>​    <strong>b.非线性结构</strong>：一个结点可能有多个直接前趋和直接后继</p>
<p>​                            例如：<strong>树、图</strong></p>
<p>（2）<strong>物理结构</strong>（存储结构）：数据元素及其关系在计算机内存中的表示。</p>
<p>​    <strong>a.顺序存储结构</strong>：用一组<strong>连续</strong>的存储单元<strong>依次</strong>存储数据元素，数据元素之间的逻辑关系由元素的<strong>存储位置</strong>来表示，C中用数组来实现顺序存储关系。<strong>方便查找。</strong></p>
<p>​    <strong>b.链式存储结构</strong>：用任意的存储单元存储数据元素，数据元素之间的逻辑关系用<strong>指针</strong>表示，C用<strong>指针</strong>来实现链式存储结构。<strong>方便插入和删除。</strong></p>
<p>​    <strong>c.索引存储结构</strong>：需建立附加的索引表，索引表中每一项称为索引项，一般形式为（关键字，地址）</p>
<p>​    <strong>d.散列存储</strong>：根据关键字计算出结点的存储地址</p>
<p>5.数据对象：<strong>数据对象</strong>是具有<strong>相同性质</strong>的<strong>数据元素</strong>的集合，是数据的一个子集。如整数的数据对象是集合N={1,2,3,…}</p>
<p> 6.数据类型：是指一组性质相同的值的集合和定义在此集合上的一组操作的总称。</p>
<p>（1）原子类型：是不可以再分解的基本类型，包括整型（int），实型，字符型（char）等</p>
<p>（2）结构类型：由若干个类型组合而成，是可以再分解的。如整型数组是由若干个整型数据组成的</p>
<p>7.抽象数据类型（ADT）：抽象数据类型可用三元组（D，S，P）表示，D是数据对象，S是D上的关系集，P是对D的基本操作集。</p>
<p>​    抽象数据类型的标准格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADT 抽象数据类型名&#123;</span><br><span class="line">    Data</span><br><span class="line">        数据元素之间逻辑关系的定义</span><br><span class="line">    Operation</span><br><span class="line">        操作<span class="number">1</span></span><br><span class="line">        	初始条件</span><br><span class="line">        	操作结果描述</span><br><span class="line">        操作<span class="number">2</span></span><br><span class="line">        	...</span><br><span class="line">        操作n</span><br><span class="line">        	...</span><br><span class="line">&#125; ADT 抽象数据类型名</span><br></pre></td></tr></table></figure>

<p><strong>综上：数据&gt;数据对象&gt;数据元素&gt;数据项</strong></p>
<h2 id="算法知识点"><a href="#算法知识点" class="headerlink" title="算法知识点"></a>算法知识点</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>1.<strong>算法的定义：</strong>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且，每条指令表示一个或多个操作。</p>
<p>2.<strong>算法的特性：</strong>算法具有五个基本特性：<strong>输入</strong>，<strong>输出</strong>，<strong>有穷性</strong>，<strong>确定性</strong>，<strong>可行性</strong>。</p>
<p>​    （1）输入和输出：算法具有<strong>零个或多个</strong>输入，尽管大部分的函数都需要有输入。算法至少需要<strong>一个或多个</strong>输出，输出的形式可以是打印输出也可以是返回一个或多个值。</p>
<p>​    （2）有穷性：指算法在执行<strong>有限步骤</strong>之后，自动结束循环而不会出现无限循环，并且每个步骤在一个<strong>可接受的时间</strong>内。</p>
<p>​    （3）确定性：算法的每一个步骤都有确定的含义，<strong>不会出现二义性</strong>。即相同的输入只能出现相同的输出。</p>
<p>​    （4）可行性：算法的每一步都必须是<strong>可行</strong>的，即每一步都能够通过执行<strong>有限步骤</strong>完成。</p>
<h3 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h3><p>1.<strong>正确性</strong>：算法的正确性是指算法至少应该具有输入，输出和加工处理无歧义性，能正确反映问题的需求、得到问题的正确答案。</p>
<p>正确性的要求分为以下四点，按照难度依次递增：    </p>
<p>（1）算法程序没有语法错误。</p>
<p>（2）算法程序对于合法的输入能够产生符合其要求的结果。</p>
<p>（3）算法程序对于非法的输入数据能得出满足规格说明的结果。</p>
<p>（4）算法程序对于精心选择的，甚至刁难的程序都有满足要求的输出结果。</p>
<p>2.<strong>可读性</strong>：算法设计的另一目的是为了便于阅读、理解和交流。为了让别人看得懂啊。</p>
<p>3.<strong>健壮性</strong>（处理异常问题的能力）：当输入数据不合法时，算法也能做出相关的处理，而不是产生异常或莫名其妙的结果。</p>
<p>4.<strong>时间效率高和存储量低</strong>：设计算法应该尽量满足时间效率和存储量低的需求。</p>
<h3 id="算法效率的度量方法"><a href="#算法效率的度量方法" class="headerlink" title="算法效率的度量方法"></a>算法效率的度量方法</h3><p>1.事后统计方法：利用计算机的计时器功能，对算法的运行时间进行对比，从而得出算法效率的高低。</p>
<p>2.事前分析估计方法：在计算机程序编制之前，依据统计方法对算法进行估算。</p>
<p>​    下面我们来对比1+2+3+…+100的两种算法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//算法一</span></span><br><span class="line"><span class="type">int</span> i,sum=<span class="number">0</span>,n=<span class="number">100</span>;			<span class="comment">//执行1次</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;			<span class="comment">//执行n+1次</span></span><br><span class="line">    sum = sum + i;			<span class="comment">//执行n次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,sum)			<span class="comment">//执行一次</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//一共执行了1+(n+1)+n+1 = 2n+3次，即n次</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//算法二</span></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>,n = <span class="number">100</span>;		<span class="comment">//执行一次</span></span><br><span class="line">sum = (<span class="number">1</span>+n)*n/<span class="number">2</span>;			<span class="comment">//执行一次</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,sum);			<span class="comment">//执行一次</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行了三次，即1次</span></span><br></pre></td></tr></table></figure>



<h3 id="算法中函数的渐近增长（重点！）"><a href="#算法中函数的渐近增长（重点！）" class="headerlink" title="算法中函数的渐近增长（重点！）"></a>算法中函数的渐近增长（重点！）</h3><p>定义：给定两个函数f(n)和g(n)，如果存在一共整数N，是的队员所有的n&gt;N，f(n)总是比g(n)大，那么我们说f(n)的增长渐近快于g(n).</p>
<p>对于算法A：2n^2+n 和 算法B：n^3+n^2 我们只需要看最高次幂的幂数，连与最高次项相乘的常数都不重要！</p>
<p><strong>综上可知：判断一个算法的效率时，我们只需观察最高阶项，而函数中的常数和其他次要项往往可以忽略不计！</strong></p>
<h3 id="算法的时间复杂度"><a href="#算法的时间复杂度" class="headerlink" title="算法的时间复杂度"></a>算法的时间复杂度</h3><p>使用O（）来体现算法时间复杂度的记法。</p>
<p>推导大O阶：</p>
<p>1.用常数1取代运行时间中的所有加法常数。</p>
<p>2.在修改后的运行次数函数中，只保留最高阶项。</p>
<p>3.如果最高阶项存在且不是1，则去除与这个项相乘的常数。</p>
<p><strong>得到的结果就是大O阶！</strong></p>
<h4 id="常数阶"><a href="#常数阶" class="headerlink" title="常数阶"></a>常数阶</h4><p>常数阶不论运行了10次20次100次都只能记作O(1)不能记作O(3)O(10)，初学者常常犯这样的错误</p>
<p><strong>对于分支结构而言，无论是真是假，时间复杂度都是O(1)</strong></p>
<h4 id="线性阶"><a href="#线性阶" class="headerlink" title="线性阶"></a>线性阶</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线性阶的时间复杂度时O(n)</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对数阶"><a href="#对数阶" class="headerlink" title="对数阶"></a>对数阶</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(count&lt;n)&#123;</span><br><span class="line">	count = count * <span class="number">2</span>;			<span class="comment">//因为2^x=n，所以x=log2(n),即O(logn)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="平方阶"><a href="#平方阶" class="headerlink" title="平方阶"></a>平方阶</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#平方阶的时间复杂度是O(n^<span class="number">2</span>)</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个比较常见的时间复杂度判断</span></span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(j=i;j&lt;n;j++)&#123;		<span class="comment">//当i=0，执行n次，当i=1，执行n-1次...总执行次数是等差数列求和问题，n(n+1)/2=n^2/2 + n/2,所以O(n^2).</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数列知识点（做题的基础）"><a href="#数列知识点（做题的基础）" class="headerlink" title="数列知识点（做题的基础）"></a>数列知识点（做题的基础）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//等差数列的计算：前n项和等于n(n+1)/2</span></span><br><span class="line"><span class="comment">//等比数列的前n项和：(a1-an*q)/(1-q)</span></span><br></pre></td></tr></table></figure>

<h4 id="时间复杂度所耗费的时间"><a href="#时间复杂度所耗费的时间" class="headerlink" title="时间复杂度所耗费的时间"></a>时间复杂度所耗费的时间</h4><p>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>要做好大O阶时间复杂度的题目，要学好数列的相关知识</p>
<h3 id="算法的空间复杂度"><a href="#算法的空间复杂度" class="headerlink" title="算法的空间复杂度"></a>算法的空间复杂度</h3><p>算法空间复杂度的计算公式为S(n) = O(f(n))，其中n为问题的规模，f(n)是n所占存储空间的函数。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构--线性表</title>
    <url>/2022/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="线性表的基础内容及应用"><a href="#线性表的基础内容及应用" class="headerlink" title="线性表的基础内容及应用"></a>线性表的基础内容及应用</h1><span id="more"></span>

<h2 id="基础知识（重点！！）"><a href="#基础知识（重点！！）" class="headerlink" title="基础知识（重点！！）"></a>基础知识（重点！！）</h2><p>1.ElemType是你<strong>自己定义</strong>的数据类型，想用什么用什么，使用typedef定义，如<strong>typedef int ElemType</strong></p>
<p>2.数组的静态分配和动态分配：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态分配,很好理解</span></span><br><span class="line">ElemType data[MAXSIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态分配，难理解！</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">ElemType *data;</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;sqList;</span><br><span class="line"><span class="comment">//接着上面的，在动态分配的固定的函数给他分配内存！</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line">sqList L;</span><br><span class="line">L.data = (ElemType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType)*MaxSize);<span class="comment">//其中ElemType*表示强制类型转换，因为在定义的时候是指针类型的！</span></span><br></pre></td></tr></table></figure>

<p>3.接上！内存分配函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下列三个函数都是要在加载头文件&lt;stdlib.h&gt;的前提下</span></span><br><span class="line"><span class="comment">//malloc(m)函数:开辟m字节长度的地址空间，并返回这段空间的首地址！</span></span><br><span class="line"><span class="comment">//sizeof(x)函数:计算变量x的长度</span></span><br><span class="line"><span class="comment">//free(p)函数:释放指针p所指变量的存储空间，即删除一个变量</span></span><br></pre></td></tr></table></figure>

<p>4.C++的动态存储分配：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建空间--new</span></span><br><span class="line"><span class="keyword">new</span> 类型名（初值列表）</span><br><span class="line">    功能：</span><br><span class="line">    	申请用于存放T类型对象的内存空间，并赋予初值</span><br><span class="line">    结果值：</span><br><span class="line">    	成功：T类型的指针，指向新分配的内存</span><br><span class="line">    	失败：<span class="number">0</span> </span><br><span class="line"><span class="comment">//如int *p1 = new int;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//删除空间--delete</span></span><br><span class="line">    <span class="keyword">delete</span> 指针P</span><br><span class="line">    功能：</span><br><span class="line">    	释放指针P所指向的内存，P必须是<span class="keyword">new</span>操作的返回值</span><br></pre></td></tr></table></figure>



<h3 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h3><p>线性表：<strong>零个或多个</strong>数据元素的<strong>有限序列</strong></p>
<p>线性表中的元素有且只有一个直接前驱和直接后继（除了线性表中的第一个和最后一个元素）</p>
<p><strong>线性表元素的个数n定义为线性表的长度为n。当n=0时，线性表为空表！</strong></p>
<p>在比较复杂的线性表当中，一个数据元素可以由若干个数据项组成！</p>
<h3 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的抽象数据类型</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADT 线性表(List)</span><br><span class="line">Data</span><br><span class="line">	线性表的数据对象的集合为&#123;a1,a2,..,an&#125;,每个元素的类型均为DataType，其中，除了第一个元素a1外，每个元素有且只有一个直接前驱元素，除了最后一个元素an外，每个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。</span><br><span class="line">Operation</span><br><span class="line">    <span class="title function_">InitList</span><span class="params">(*L)</span>:初始化操作，建立一个空的线性表L。</span><br><span class="line">    <span class="title function_">DestroyList</span><span class="params">(*L)</span>:销毁一个线性表。</span><br><span class="line">    <span class="title function_">ListEmpty</span><span class="params">(L)</span>:判断线性表是否为空表，若线性表为空，返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。</span><br><span class="line">    <span class="title function_">CleanList</span><span class="params">(*L)</span>:将线性表清空。</span><br><span class="line">    <span class="title function_">GetElem</span><span class="params">(L,i,*e)</span>:将线性表L中的第i个元素值返回给e。</span><br><span class="line">    <span class="title function_">LocateElem</span><span class="params">(L,e)</span>:在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则返回0表示失败！</span><br><span class="line">    <span class="title function_">priorElem</span><span class="params">(L,cur_e,*pre_e)</span>:如果cur_e不是线性表中的第一个元素，那么返回它的直接前驱，否则操作失败！</span><br><span class="line">    <span class="title function_">NextElem</span><span class="params">(L,cur_e,*next_e)</span>:如果cur_e不是线性表中的最后一个元素，那么返回它的直接后继，否则操作失败！</span><br><span class="line">    <span class="title function_">ListInsert</span><span class="params">(*L,i,e)</span>:在线性表L中的第i个位置插入新元素e。</span><br><span class="line">    <span class="title function_">ListDelete</span><span class="params">(*L,i,*e)</span>:删除在线性表L中第i个位置元素，并用e返回其值。</span><br><span class="line">    <span class="title function_">ListLength</span><span class="params">(L)</span>:返回线性表L的元素个数。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>



<h3 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h3><p>顺序存储的定义：在逻辑结构上相邻的数据储存在物理位置也相邻的地方</p>
<h4 id="顺序表中存储位置的计算（重点！）"><a href="#顺序表中存储位置的计算（重点！）" class="headerlink" title="顺序表中存储位置的计算（重点！）"></a>顺序表中存储位置的计算（重点！）</h4><p>如果每个元素占用8个存储单元，已知ai的存储位置是2000，问a（i+1）的存储位置</p>
<p>答：a(i+1) = ai + 8  = 2008</p>
<p>假设每个元素占用L个存储单元，已知第一个元素的位置，求第i个元素的位置：</p>
<p>*<em>LOC(ai) = LOC(a1) + (i-1)<em>L</em></em></p>
<h4 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">long</span> num;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">char</span> gender;</span><br><span class="line">	<span class="type">float</span> score;</span><br><span class="line">&#125;stu=&#123;<span class="number">01</span>;<span class="string">&quot;dgz&quot;</span>;<span class="string">&#x27;男&#x27;</span>;<span class="number">90</span>&#125;   <span class="comment">//这里使用了尾随法来给结构体类型赋值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">p</span>;</span>    <span class="comment">//创建一个结构体指针</span></span><br><span class="line">p = &amp;stu;			<span class="comment">//这个结构体指针指向的是结构体变量stu</span></span><br><span class="line"><span class="comment">//现在我们想使用指针调用结构体变量stu中的num变量，有三种方法</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>,stu.num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>,*p.num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>,p -&gt; num);</span><br></pre></td></tr></table></figure>



<h4 id="顺序结构的代码-very-very-important"><a href="#顺序结构的代码-very-very-important" class="headerlink" title="顺序结构的代码(very very important!!!)"></a>顺序结构的代码(very very important!!!)</h4><p><strong>标准格式(下面所有的代码全部以他为依据！)</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;sqList;</span><br></pre></td></tr></table></figure>

<p><strong>用e返回线性表L中的第i个元素</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line">Status <span class="title function_">GetElem</span><span class="params">(sqList L,<span class="type">int</span> i,ElemType *e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;L-&gt;length<span class="number">-1</span> || i&lt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=<span class="number">1</span> &amp;&amp; i&lt;=L-&gt;length<span class="number">-1</span>)&#123;</span><br><span class="line">        e = L-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="顺序结构的插入（重点！）"><a href="#顺序结构的插入（重点！）" class="headerlink" title="顺序结构的插入（重点！）"></a>顺序结构的插入（重点！）</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始条件：L存在，1&lt;=i&lt;=ListLength(L)</span></span><br><span class="line"><span class="comment">//操作结果：在L中第i个位置之前插入新的元素e，L长度加一</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status</span><br><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(SqList *L,<span class="type">int</span> i,ElemType *e)</span>&#123;</span><br><span class="line">	<span class="type">int</span> k;</span><br><span class="line">	<span class="keyword">if</span>(L-&gt;length==MAXSIZE)		<span class="comment">//如果线性表满了插不进去</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L-&gt;length+<span class="number">1</span>)	<span class="comment">//如果元素在线性表外，也插不进去</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=<span class="number">1</span> &amp;&amp; i&lt;=length+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(k=L-&gt;length<span class="number">-1</span>;k&gt;=i<span class="number">-1</span>;k--)&#123;</span><br><span class="line">            data[k+<span class="number">1</span>] = data[k];</span><br><span class="line">        &#125;</span><br><span class="line">        L-&gt;length = L-&gt;length+<span class="number">1</span>;</span><br><span class="line">        L-&gt;data[i<span class="number">-1</span>] = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="顺序结构的删除"><a href="#顺序结构的删除" class="headerlink" title="顺序结构的删除"></a>顺序结构的删除</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除i位置的元素，并用</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line">ListDelete(sqList *L,<span class="type">int</span> i,ElemType *e)&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;length==<span class="number">0</span> || i&lt;<span class="number">1</span> || i&gt;L-&gt;length)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    *e = L-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;length&gt;i &amp;&amp; i&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(k=i;k&lt;=L-&gt;length<span class="number">-1</span>;k++)&#123;</span><br><span class="line">            L-&gt;data[k<span class="number">-1</span>] = L-&gt;data[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;length--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="插入和删除的时间复杂度"><a href="#插入和删除的时间复杂度" class="headerlink" title="插入和删除的时间复杂度"></a>插入和删除的时间复杂度</h5><p>最简单的情况：插在最后一个元素位置，时间复杂度是O（1）</p>
<p>最复杂的情况：插在第一个元素位置，时间复杂度是O（n）</p>
<p>平均下来的时间复杂度是：(n+1)/2，即O（n）</p>
<h4 id="线性表顺序存储的优缺点"><a href="#线性表顺序存储的优缺点" class="headerlink" title="线性表顺序存储的优缺点"></a>线性表顺序存储的优缺点</h4><p>优点：1.无需为表中元素之间的逻辑关系而增加额外的存储空间；</p>
<p>​            2.可以快速的查找任意元素的位置</p>
<p>缺点：1.插入和删除操作需要移动大量的元素</p>
<p>​            2.当线性表长度变化太大时，难以确定存储空间的变化！</p>
<p>​            3.造成存储空间的“碎片化”。</p>
<h3 id="线性表的链式存储"><a href="#线性表的链式存储" class="headerlink" title="线性表的链式存储"></a>线性表的链式存储</h3><h4 id="链式存储的定义"><a href="#链式存储的定义" class="headerlink" title="链式存储的定义"></a>链式存储的定义</h4><p>​    为了表示ai和ai+1之间的关系，对于ai来说，除了存储本身的数据，还需要存储一个指向下一个数据元素的指针，我们把ai中存储数据的域叫做<strong>数据域</strong>，把存储指针的域叫做<strong>指针域</strong>，把指针域中的数据叫做<strong>指针或链</strong>，这两部分信息组成数据元素ai的存储映像，称为<strong>结点</strong>。</p>
<p>​    n个结点链接成一个链表，即为线性表的链式存储，每个结点中值包含一个指针域，称为<strong>单链表</strong>。</p>
<p>​    链表中第一个结点的存储位置称为<strong>头指针</strong></p>
<p>​    链表中最后一个结点的存储位置为空，用<strong>NULL或者^</strong>表示</p>
<p>​    <strong>如a|b -&gt; c|d -&gt; e|f    这个案例中a|b就是头结点，b就是头指针。头节点中的数据域a一般不存放数据</strong></p>
<p>​    如果线性表为空表，那么头结点的指针为空指针</p>
<h4 id="链式存储的代码（重点！）"><a href="#链式存储的代码（重点！）" class="headerlink" title="链式存储的代码（重点！）"></a>链式存储的代码（重点！）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线性表单链表的存储结构（一切的基础！）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">LinkList</span>;</span></span><br></pre></td></tr></table></figure>

<p>假设p是指向下一个元素的指针，那么下一个元素的数据域表示为<strong>p-&gt;data</strong>，下一个元素的指针域表示为<strong>p-&gt;next</strong>，那么<strong>p-&gt;next-&gt;data</strong>就指向再下一个元素的数据域！</p>
<h5 id="查找元素并返回值GetElem"><a href="#查找元素并返回值GetElem" class="headerlink" title="查找元素并返回值GetElem()"></a>查找元素并返回值GetElem()</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链式存储中的用e返回第i个位置的元素操作！</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line">Status <span class="title function_">GetElem</span> <span class="params">(LinkList L,<span class="type">int</span> i,ElemType *e)</span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    LinkList p;			<span class="comment">//声明指针</span></span><br><span class="line">    p = L-&gt;next;		<span class="comment">//p指向线性表的第一个结点</span></span><br><span class="line">    k = <span class="number">1</span>;				<span class="comment">//k为计数器</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; k&lt;i)		<span class="comment">//p不为NULL且k没等于i时，循环继续</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;	<span class="comment">//p指向下一个结点,在最后一次循环的时候，其实指向的是第i-1个元素</span></span><br><span class="line">        ++k;			<span class="comment">//k递增</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!p || k&gt;i)&#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR；</span><br><span class="line">    &#125;</span><br><span class="line">    *e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//核心思想是指针的后移，这也是很多算法的实现方法。</span></span><br></pre></td></tr></table></figure>

<h5 id="不知道要循环多少次的循环别使用for，用while"><a href="#不知道要循环多少次的循环别使用for，用while" class="headerlink" title="不知道要循环多少次的循环别使用for，用while"></a>不知道要循环多少次的循环别使用for，用while</h5><h5 id="链式表的插入操作"><a href="#链式表的插入操作" class="headerlink" title="链式表的插入操作"></a>链式表的插入操作</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先进行元素位置i的查找，找到时候进行插入新的元素e的赋值操作！</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(LinkList *L,<span class="type">int</span> i,ElemType e)</span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    LinkList p,s;</span><br><span class="line">    p = *L</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; k&lt;=i)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!p || k&gt;i)&#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    s = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">//生成新结点（C标准函数）</span></span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="链式表的删除操作"><a href="#链式表的删除操作" class="headerlink" title="链式表的删除操作"></a>链式表的删除操作</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">ListDelete</span><span class="params">(LinkList *L,<span class="type">int</span> i,ElemType *e)</span>&#123;</span><br><span class="line">	<span class="type">int</span> k=<span class="number">1</span>;</span><br><span class="line">	LinkList p,q;</span><br><span class="line">	p = *L;</span><br><span class="line">	<span class="keyword">while</span>(p-&gt;next &amp;&amp; k&lt;i)</span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		k++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!(p-&gt;next) || k&gt;i)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	q = p-&gt;next;			<span class="comment">//令q为要删除的结点</span></span><br><span class="line">	p-&gt;next = q-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(q);				<span class="comment">//释放q的空间</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="单链表的整表创建"><a href="#单链表的整表创建" class="headerlink" title="单链表的整表创建"></a>单链表的整表创建</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 随机产生n个元素的值，建立带表头结点的单链线性表L(头插法) */</span><br><span class="line">void CreateListHead(LinkList *L,int n)</span><br><span class="line">&#123;</span><br><span class="line">	LinkList p;</span><br><span class="line">	int i;</span><br><span class="line">	srand(time(0));				//初始化随机数种子</span><br><span class="line">	*L = (LinkList)malloc(sizeof(Node));</span><br><span class="line">	(*L)-&gt;next = NULL;</span><br><span class="line">	for(i=0;i&lt;n;i++)&#123;</span><br><span class="line">		p=(LinkList)malloc(sizeof(Node));</span><br><span class="line">		p-&gt;data = rand() % 100+1;</span><br><span class="line">		p-&gt;next = (*L)-&gt;next;</span><br><span class="line">		(*L)-&gt;next=p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习-- Matplotlib库</title>
    <url>/2022/03/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-Matplotlib%E5%BA%93/</url>
    <content><![CDATA[<p>Matplotlib库用来创建图表</p>
<span id="more"></span>

<p>在使用Matplotlib库的时候要导入matpltlib库</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>

<p>常用的图形函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#绘制折线图</span></span><br><span class="line">plt.plot()</span><br><span class="line"><span class="comment">#绘制柱形图</span></span><br><span class="line">plt.bar()</span><br><span class="line"><span class="comment">#绘制饼图</span></span><br><span class="line">plt.pie()</span><br></pre></td></tr></table></figure>

<h3 id="绘制基本的图表"><a href="#绘制基本的图表" class="headerlink" title="绘制基本的图表"></a>绘制基本的图表</h3><h4 id="绘制折线图"><a href="#绘制折线图" class="headerlink" title="绘制折线图"></a>绘制折线图</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">y = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">plt.plot(x,y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h4 id="绘制柱形图"><a href="#绘制柱形图" class="headerlink" title="绘制柱形图"></a>绘制柱形图</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">y = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">plt.bar(x,y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h4 id="绘制散点图"><a href="#绘制散点图" class="headerlink" title="绘制散点图"></a>绘制散点图</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.random.rand(<span class="number">10</span>)		<span class="comment">#生成10个位于0~1之间的数</span></span><br><span class="line">y = np.random.rand(<span class="number">10</span>)</span><br><span class="line">plt.scatter(x,y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h4 id="绘制直方图"><a href="#绘制直方图" class="headerlink" title="绘制直方图"></a>绘制直方图</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data = np.random.randn(<span class="number">10000</span>)	<span class="comment">#生成10000个服从标准正态分布的随机数</span></span><br><span class="line">plt.hist(data,bins=<span class="number">40</span>,edgecolor=<span class="string">&#x27;black&#x27;</span>)   <span class="comment">#绘制直方图的函数,bins为直方图的数量（颗粒度），edgecolor为柱形图的边框颜色</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><h4 id="添加文字"><a href="#添加文字" class="headerlink" title="添加文字"></a>添加文字</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">y = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">plt.plot(x,y)</span><br><span class="line">plt.title(<span class="string">&#x27;TITLE&#x27;</span>)		<span class="comment">#设置图标上面的标题</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;X&#x27;</span>)			<span class="comment">#设置横坐标的值</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;Y&#x27;</span>)			<span class="comment">#设置纵坐标的值</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h4 id="添加图例"><a href="#添加图例" class="headerlink" title="添加图例"></a>添加图例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">plt(x,y,lable=<span class="string">&#x27;x+y&#x27;</span>)	<span class="comment">#只是在之前的条件后面添加一个label参数</span></span><br><span class="line">plt.legend(loc=<span class="string">&#x27;upper left&#x27;</span>)	<span class="comment">#这是用来把图例设置在图表的左上方</span></span><br></pre></td></tr></table></figure>

<h4 id="设置图表大小"><a href="#设置图表大小" class="headerlink" title="设置图表大小"></a>设置图表大小</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.rcParams[<span class="string">&#x27;figure.figsize&#x27;</span>] = (<span class="number">8</span>,<span class="number">6</span>)		<span class="comment">#其中8是长度，6是宽度</span></span><br></pre></td></tr></table></figure>

<h4 id="设置x轴刻度的问题"><a href="#设置x轴刻度的问题" class="headerlink" title="设置x轴刻度的问题"></a>设置x轴刻度的问题</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.xticks(rotation=<span class="number">45</span>)</span><br></pre></td></tr></table></figure>

<h4 id="解决中文显示问题ax"><a href="#解决中文显示问题ax" class="headerlink" title="解决中文显示问题ax"></a>解决中文显示问题ax</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pylot <span class="keyword">as</span> plt</span><br><span class="line">plt.rcParams[fort.sans-serif] = [<span class="string">&#x27;SimHei&#x27;</span>]	<span class="comment">#用来正常显示中文标签</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span>	<span class="comment">#解决符号显示为方块的问题</span></span><br></pre></td></tr></table></figure>

<h4 id="绘制多图"><a href="#绘制多图" class="headerlink" title="绘制多图"></a>绘制多图</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Matplotlib库中的figure作为画布，axes作为子图，一个画布中可以有多张子图，绘制多图常用subplot()函数和subplots()函数.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#subplot函数，他的参数为三位整数，分别表示子图的行数列数和当前子图的序号。</span></span><br><span class="line">ax = plot.subplot(<span class="number">221</span>)</span><br><span class="line">plt.plot([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])	<span class="comment">#表示这个两行两列的子图绘制折线图。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#subplots函数，表示生成几行几列的子图</span></span><br><span class="line">fig,axes = plt.subplots(<span class="number">2</span>,<span class="number">2</span>)	<span class="comment">#表示生成两行两列的一共四个的子图,fig是画布参数，axes是子图参数</span></span><br><span class="line">ax1,ax2,ax3,ax4 = axes.flatten()	<span class="comment">#这个语句将子图变量赋值给ax1,ax2,ax3,ax4</span></span><br><span class="line"><span class="comment">#之后就可以使用subplot在子图中画图</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习-- numpy库</title>
    <url>/2022/03/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-numpy%E5%BA%93/</url>
    <content><![CDATA[<p>学习numpy库的主要目的是为了后面学习pandas库打下基础</p>
<span id="more"></span>

<h3 id="python中数组、元组、列表的区别"><a href="#python中数组、元组、列表的区别" class="headerlink" title="python中数组、元组、列表的区别"></a>python中数组、元组、列表的区别</h3><p><strong>首先要知道python中是没有数组的</strong></p>
<p>列表和元组的区别：列表中可以append元素，可以pop元素，而元组做不到，只能对元组元素进行索引而不能对它赋值！</p>
<p><strong>创建数组的第一种方式</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]  <span class="comment">#创建一个列表a</span></span><br><span class="line">b = np.array([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])   <span class="comment">#</span></span><br><span class="line"><span class="built_in">print</span>(a)	<span class="comment">#[1,2,3]-&gt;这是列表的表现形式</span></span><br><span class="line"><span class="built_in">print</span>(b)	<span class="comment">#[4 5 6]-&gt;这是数组的表现形式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))	<span class="comment">#class = list</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b))	<span class="comment">#class = numpy.ndarray</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#数组和列表的切片都遵循左闭右开的元组</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">b = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>:<span class="number">2</span>]) 	<span class="comment">#因为左闭右开所以是[1,2]</span></span><br><span class="line"><span class="built_in">print</span>(b[<span class="number">0</span>:<span class="number">2</span>])	<span class="comment">#因为左闭右开所以是[1 2],注意和列表的表达形式不一样</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#数组*2</span></span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])*<span class="number">2</span>		<span class="comment">#[2,4,6]</span></span><br><span class="line">b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]					<span class="comment">#[1,2,3,1,2,3]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#二维数组</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]]) <span class="comment">#生成的结构是二维的，即不止一行</span></span><br><span class="line"><span class="comment">#对应的列表中的就是小列表了</span></span><br><span class="line">y = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]]			  <span class="comment">#就产生一行而已</span></span><br></pre></td></tr></table></figure>

<p><strong>创建数组的第二种方式</strong>（arange通过步长来创建）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用np.arange可以传递1~3个参数</span></span><br><span class="line"><span class="comment">#1个参数,那么这个参数就是终止值，起始值默认是0，步长默认是1</span></span><br><span class="line">x = np.arange(<span class="number">5</span>)	<span class="comment">#相当于np.arange(0,5,1)</span></span><br><span class="line"><span class="comment">#2个参数，第一个参数是初始值，第二个参数是终止值，步长默认为1</span></span><br><span class="line">x = np.arange(<span class="number">5</span>,<span class="number">10</span>)	<span class="comment">#相当于np.arange(5,10,1)</span></span><br><span class="line"><span class="comment">#3个参数，第一个参数是初始值，第二个参数是终止值，第三个参数是步长</span></span><br><span class="line">x = np.arange(<span class="number">5</span>,<span class="number">10</span>,<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>

<p><strong>创建数组的第三种方式</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用np.random可以创建随机一维数组</span></span><br><span class="line"><span class="comment">#例如使用np.random.randn(n)可以创建n个服从标准正态分布(均值为0，标准差为1)的随机数</span></span><br><span class="line">np.random.randn(<span class="number">3</span>)	<span class="comment">#创建服从标准正态分布的3个随机数</span></span><br><span class="line"><span class="comment">#如果把randn改成rand（n），即为创建n个处于0~1的随机数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#想要转换成二维随机数，可以用创建一维数组的arange和转变成二维数组的reshape来实现。</span></span><br><span class="line">a = np.arange(<span class="number">20</span>).reshape(<span class="number">4</span>,<span class="number">5</span>)	<span class="comment">#reshape的第一个参数是行数，第二个参数是列数，如这个例子就是创建3行4列的二维数组</span></span><br><span class="line"><span class="comment">#np.random.randint用于创建随机整数</span></span><br><span class="line">np.random.randint(<span class="number">0</span>,<span class="number">10</span>,(<span class="number">4</span>,<span class="number">4</span>))	<span class="comment">#第一个参数是初始值，第二个参数是终止值，（4，4）则是创建为4X4的二维向量</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>machine leaning</category>
      </categories>
      <tags>
        <tag>machine leaning</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学 -- 导论</title>
    <url>/2022/03/04/%E7%BB%9F%E8%AE%A1%E5%AD%A6-%E5%AF%BC%E8%AE%BA/</url>
    <content><![CDATA[<h3 id="统计数据的类型"><a href="#统计数据的类型" class="headerlink" title="统计数据的类型"></a>统计数据的类型</h3><span id="more"></span>

<h4 id="计量尺度分类"><a href="#计量尺度分类" class="headerlink" title="计量尺度分类"></a>计量尺度分类</h4><p><strong>1.分类数据：</strong></p>
<p>​    分类数据是只能归于某一类别的数据，通常把数据划分为不同的数据类型，如：金融业，制造业，计算机业等等。</p>
<p><strong>2.数值数据：</strong><br>    结果表现为具体的数值。数值数据又分为离散数值和连续数值，离散数值是一个个单独的数据不连贯的，连续数值是连起来的，通常不能一一列举！</p>
<h4 id="收集方法分类"><a href="#收集方法分类" class="headerlink" title="收集方法分类"></a>收集方法分类</h4><p><strong>1.观测数据：</strong></p>
<p>​    是通过调查或者观察从而得到的数据，这类数据通常没有人为参与和控制。</p>
<p><strong>2.实验数据：</strong></p>
<p>​    在实验中控制实验对象从而得到的实验数据，自然科学领域大多数都是实验数据。</p>
<h4 id="现象与时间关系分类"><a href="#现象与时间关系分类" class="headerlink" title="现象与时间关系分类"></a>现象与时间关系分类</h4><p><strong>1.截面数据：</strong></p>
<p>指在同一时间或者是相隔很近的时间点上收集的数据。这类数据通常是在不同的时空上收集的，描述某一时刻的某事务的变化情况。</p>
<p><strong>2.时间序列数据：</strong></p>
<p>是在不同时间收集的数据，表现事务随着时间的变化情况。如2012-2022年我国的人均GDP情况就是时间序列数据。</p>
<h3 id="总体和样本"><a href="#总体和样本" class="headerlink" title="总体和样本"></a>总体和样本</h3><p><strong>1.总体：</strong></p>
<p>​    是包含所研究的全部个体（数据）的集合，通常由多个个体组成。</p>
<p><strong>2.样本：</strong><br>    样本是从总体中抽取的一部分元素的集合，构成样本的元素的数目称为<strong>样本量</strong>。</p>
<h3 id="参数和统计量"><a href="#参数和统计量" class="headerlink" title="参数和统计量"></a>参数和统计量</h3><p><strong>1.参数：</strong><br>    用来描述总体特征的数字度量。是观察者想要了解的某种特征值。</p>
<p><strong>2.统计量：</strong></p>
<p>​    用来描述样本特征的数字度量。表示样本的特征值。</p>
<h3 id="变量和其分类"><a href="#变量和其分类" class="headerlink" title="变量和其分类"></a>变量和其分类</h3><p><strong>1.变量：</strong>指某种<strong>特征</strong>的概念，如商品的销售额可以是五十万或者六十万。</p>
<p>2.变量的分类：</p>
<p>​    （1）分类变量：如客户的满意程度可以分类成：“很好”，“还行”，“一般”，“较差”，“很差”。</p>
<p>​    （2）数值变量：可以用数值表示的变量：生活费支出，骰子的点数。</p>
<h3 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h3><p>1.任何一个总体中都包含一个非随机变量，例如调查广西大学的学生，那么其中都是广西大学的学生，这个变量（来自广西大学）就是一个非随机变量。</p>
<p>2.<strong>总体单位=个体！！</strong></p>
<p>3.<strong>统计指标反映总体数量特征概念</strong>，分为两类：</p>
<p>​    （1）数量指标-&gt;总体GDP</p>
<p>​    （2）质量指标-&gt;人均GDP</p>
<p>4.统计指标的构成如下：时间限制，空间限制，计算方法，指标名称，数值，计量单位</p>
]]></content>
      <categories>
        <category>统计学</category>
      </categories>
      <tags>
        <tag>统计学</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学-- 数据的搜集</title>
    <url>/2022/03/08/%E7%BB%9F%E8%AE%A1%E5%AD%A6-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%90%9C%E9%9B%86/</url>
    <content><![CDATA[<h3 id="数据的分类"><a href="#数据的分类" class="headerlink" title="数据的分类"></a>数据的分类</h3><p>1.原始数据：调查，观察实验。</p>
<p>2.次级数据：已被做好的，统计年鉴，期刊等等。</p>
<h3 id="概率抽样和非概率抽样"><a href="#概率抽样和非概率抽样" class="headerlink" title="概率抽样和非概率抽样"></a>概率抽样和非概率抽样</h3><p>1.概率抽样（随机抽样）：</p>
<p>​    （1）简单随机抽样：（需要<strong>抽样框</strong>，<strong>抽样框</strong>通常包括所有总体单位的信息，如小区用户信息，住户门牌号等）从包括总体N个单位的抽样框中一个个的抽取n个单位作为样本，抽中每个样本的概率是相等的。</p>
<p>​    （2）分层抽样：把总体按照某种特征或某种规则划分成多层，然后从不同的层中抽取样本，然后将这些样本结合起来。</p>
<p>​    （3）整群抽样：总体中若干个单位合并为<strong>群</strong>，抽样的时候直接抽取群，然后对选中的群全部进行调查，称为<strong>整群抽样</strong>。</p>
<p>​    （4）系统抽样：将所有单位按一定的顺序排好，在规定的范围内随机抽取一个单位作为初始单位。然后按照一定的规则确定其他的样本单位。</p>
<p>​    （5）多阶段抽样：先进行整群抽样，然后再从群里面抽取若干个单位进行调查。</p>
<p>2.非概率抽样：</p>
<p>​    （1）方便抽样：调查过程中调查员依据方便的原则</p>
<p>​    （2）判断抽样：研究人员根据经验，判断等，有目标的选择对象进行研究</p>
<p>​    （3）自愿抽样：自愿者自愿参与</p>
<p>​    （4）滚雪球抽样：先选择一组样本，然后由这个样本提供其他的样本，故称为滚雪球</p>
<p>​    （5）配额抽样：类似于概率抽样中的分层抽样</p>
<p>​    </p>
]]></content>
      <categories>
        <category>统计学</category>
      </categories>
      <tags>
        <tag>统计学</tag>
      </tags>
  </entry>
</search>
