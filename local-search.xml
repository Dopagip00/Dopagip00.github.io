<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>大数据导论</title>
    <link href="/2022/11/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/"/>
    <url>/2022/11/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="大数据的定义"><a href="#大数据的定义" class="headerlink" title="大数据的定义"></a>大数据的定义</h2><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><h2 id="数据的定义"><a href="#数据的定义" class="headerlink" title="数据的定义"></a>数据的定义</h2><p>1.<strong>指大小超出了典型数据库软件的采集、存储、管理和分析等能力的数据集</strong></p><p>2.<strong>大数据是数据、技术、人才等的综合体</strong></p><h2 id="为什么是“大”数据"><a href="#为什么是“大”数据" class="headerlink" title="为什么是“大”数据"></a>为什么是“大”数据</h2><p>判断数据是否为“大数据”，通常遵循业界公认的4V标准：</p><p>Volume-&gt;体积大</p><p>Variety-&gt;形态多</p><p>Velocity-&gt;速度快</p><p>Value-&gt;价值高，但是密度低</p><h2 id="数据模型定义"><a href="#数据模型定义" class="headerlink" title="数据模型定义"></a>数据模型定义</h2><p><strong>数据</strong>：是有根据的数，是客观事实的一种表征形式。</p><p><strong>模型</strong>：指对于某个实际问题或客观事物、规律进行抽象后的一种形式化表达</p><p><strong>任何模型都由 变量、目标和关系三部分组成。</strong></p><p><strong>变量</strong>：是事物在幅度、强度和程度上变化的特征，可以用各种数据的大小来表征各种变量。</p><p><strong>目标</strong>：也就说这个模型是干什么用的。</p><p><strong>关系</strong>：确定目标，并确定影响目标的各种变量之后，还需要进一步研究各变量之间的关系。关系即为数据之间的逻辑结构。</p><h2 id="舍恩伯格的三个学术观点"><a href="#舍恩伯格的三个学术观点" class="headerlink" title="舍恩伯格的三个学术观点"></a>舍恩伯格的三个学术观点</h2><p>1.要分析与某事物相关的所有数据，而非依靠分析少量的数据样本</p><p>2.接受数据的纷繁复杂，而不再追求精确性</p><p>3.不再追寻难以捉摸的因果，传而关注事物的相关性</p><h2 id="数据科学的第四范式"><a href="#数据科学的第四范式" class="headerlink" title="数据科学的第四范式"></a>数据科学的第四范式</h2><p><strong>数据密集范式</strong>理应从第三范式中分离出来，成为一个独特的科学研究范式，也就是第四范式。</p><h2 id="大数据的价值"><a href="#大数据的价值" class="headerlink" title="大数据的价值"></a>大数据的价值</h2><p>大数据的价值主要体现在它的<strong>驱动效应</strong>上，即通过带动相关的科研和产业发展，提高各行各业通过数据分析解决困难问题和增值的能力。</p><h2 id="大数据分析架构层（八层）"><a href="#大数据分析架构层（八层）" class="headerlink" title="大数据分析架构层（八层）"></a>大数据分析架构层（八层）</h2><h3 id="文件系统层"><a href="#文件系统层" class="headerlink" title="文件系统层"></a>文件系统层</h3><p>文件系统是计算机操作系统的一部分，它提供一种存储、组织计算机数据的的方法。</p><h3 id="数据存储层"><a href="#数据存储层" class="headerlink" title="数据存储层"></a>数据存储层</h3><p>存储数据的地方，要保证成千上万的用户同时访问和修改数据。毫无疑问，<a href="https://so.csdn.net/so/search?q=%E6%9E%B6%E6%9E%84&spm=1001.2101.3001.7020">架构</a>的最底层是数据，数据支撑着整个架构。数据库和存储器厂商在这一层竞争激烈。具有创新性的hadoop在数据层的影响力不可小觑。</p><h3 id="资源管理层"><a href="#资源管理层" class="headerlink" title="资源管理层"></a>资源管理层</h3><p>任何一个大数据系统，计算资源、存储资源都不是无限的，需要资源分配能效最大化。</p><h3 id="计算协调层"><a href="#计算协调层" class="headerlink" title="计算协调层"></a>计算协调层</h3><p>协调多进程间的服务并进行状态管理，从而使得在分布式环境下，计算可以无误进行。</p><h3 id="计算框架层"><a href="#计算框架层" class="headerlink" title="计算框架层"></a>计算框架层</h3><p>计算框架可理解为一种通用目的的技术平台，它通过协调计算资源，可以让数据中心或集群工作起来如同一台计算机一样。</p><h3 id="数据分析层"><a href="#数据分析层" class="headerlink" title="数据分析层"></a>数据分析层</h3><p>主要提供描述性的、预测性的或统计性的数据分析功能及机器学习模块。其中主要包括数据分析工具和一些数据处理函数库。</p><h3 id="数据集成层"><a href="#数据集成层" class="headerlink" title="数据集成层"></a>数据集成层</h3><p>主要包括管理数据分析工作流中用到的各种工具。</p><h3 id="操作框架层"><a href="#操作框架层" class="headerlink" title="操作框架层"></a>操作框架层</h3><p>用来构建一套衡量标准和测试基准，从而评价各种计算框架的性能优劣；提供高扩展的性能监测管理器。</p><h1 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h1><p><img src="/2022/11/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/image-20221119203621315.png" alt="image-20221119203621315"></p><p><img src="/2022/11/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/image-20221119203634116.png" alt="image-20221119203634116"></p><p><img src="/2022/11/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/image-20221119203648753.png" alt="image-20221119203648753"></p><p><img src="/2022/11/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/image-20221119202800201.png" alt="image-20221119202717491"></p><p><img src="/2022/11/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/image-20221119202811873.png" alt="image-20221119202811873"></p><h1 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h1><p><img src="/2022/11/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/image-20221119203809152.png" alt="image-20221119203809152"></p><p><img src="/2022/11/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/image-20221119203821811.png" alt="image-20221119203821811"></p><p><img src="/2022/11/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/image-20221119203835003.png" alt="image-20221119203835003"></p><p><img src="/2022/11/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/image-20221119203853174.png" alt="image-20221119203853174"></p><p><img src="/2022/11/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/image-20221119203907915.png" alt="image-20221119203907915"></p><p><img src="/2022/11/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/image-20221119203921357.png" alt="image-20221119203921357"></p><p><img src="/2022/11/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/image-20221119203933182.png" alt="image-20221119203933182"></p><h1 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h1><p><img src="/2022/11/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/image-20221119202151897.png" alt="image-20221119202151897"></p><p><img src="/2022/11/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/image-20221119202221296.png" alt="image-20221119202221296"></p><p><img src="/2022/11/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/image-20221119202243619.png" alt="image-20221119202243619"></p><p><img src="/2022/11/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/image-20221119202311634.png" alt="image-20221119202257711"></p><p><img src="/2022/11/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/image-20221119202356195.png" alt="image-20221119202335904"></p><p><img src="/2022/11/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/image-20221119202410756.png" alt="image-20221119202410756"></p><p><img src="/2022/11/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/image-20221119202423704.png" alt="image-20221119202423704"></p><h1 id="2-4"><a href="#2-4" class="headerlink" title="2.4"></a>2.4</h1><p><img src="/2022/11/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/image-20221119202848871.png" alt="image-20221119202848871"></p><p><img src="/2022/11/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/image-20221119202904238.png" alt="image-20221119202904238"></p><p><img src="/2022/11/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/image-20221119202916821.png" alt="image-20221119202916821"></p><p><img src="/2022/11/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/image-20221119202932404.png" alt="image-20221119202932404"></p><p><img src="/2022/11/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/image-20221119202945847.png" alt="image-20221119202945847"></p><p><img src="/2022/11/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/image-20221119203000499.png" alt="image-20221119203000499"></p><p><img src="/2022/11/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/image-20221119203529593.png" alt="image-20221119203529593"></p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理--中断</title>
    <link href="/2022/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%AD%E6%96%AD/"/>
    <url>/2022/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%AD%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%AD%E6%96%AD/image-20221021114609777.png" alt="image-20221021114609777"></p>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理--总线</title>
    <link href="/2022/10/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%80%BB%E7%BA%BF/"/>
    <url>/2022/10/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%80%BB%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/10/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%80%BB%E7%BA%BF/image-20221020120558930.png" alt="image-20221020120558930"></p>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理--流水线</title>
    <link href="/2022/10/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
    <url>/2022/10/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<p>数据冲突的解决方法</p><p>1.硬件堵塞 Stall</p><p><img src="/2022/10/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20221020084954945.png" alt="image-20221020084954945"></p><p>2.软件堵塞 NOP</p><p><img src="/2022/10/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20221020085102315.png" alt="image-20221020085102315"></p>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>罗马史（更新中）</title>
    <link href="/2022/10/03/%E7%BD%97%E9%A9%AC%E5%8F%B2/"/>
    <url>/2022/10/03/%E7%BD%97%E9%A9%AC%E5%8F%B2/</url>
    
    <content type="html"><![CDATA[<p>一切古代文明的起源都和神话脱不了关系，罗马也不例外</p><p>​    传说<strong>伊尼阿斯</strong>渡海到意大利，并娶当地国王拉丁努斯之女拉维尼来为妻。<strong>伊尼阿斯</strong>死后，其子<strong>阿斯卡尼阿斯</strong>在<a href="https://baike.baidu.com/item/%E6%8B%89%E4%B8%81%E5%A7%86/2451255?fromModule=lemma_inlink">拉丁姆</a>建阿尔巴·隆加城成。此后王位代代相传，当传到<strong>努米托尔</strong>的时候，王位被其弟<strong>阿穆利乌斯</strong>篡夺。阿穆利乌斯为确保王位，强迫努米托尔之女<strong>西尔维娅</strong>作<a href="https://baike.baidu.com/item/%E7%BB%B4%E6%96%AF%E5%A1%94%E8%B4%9E%E5%A5%B3/6888346?fromModule=lemma_inlink">维斯塔贞女</a>（罗马侍奉圣火维塔斯女神的女祭司，罗马给予了这些女祭司很大的权力，在社会上也有一定的地位）。可是<strong>西尔维娅</strong>为战神所爱，生了一对孪生子。<strong>阿穆利乌斯</strong>命令将这对孪生兄弟扔入第伯河中。河水将孩子漂到了岸边。后来被一位牧人（名叫法斯图鲁斯）抚养长大。哥哥名叫<strong>罗穆卢斯</strong>（即罗马第一任君主），弟弟则叫列莫斯。兄弟俩杀死阿穆利乌斯，并将王位归还其外祖父，自己在别处建城。在建城过程中，兄弟间发生争吵，结果兄杀其弟，并以自己的名字命名该城，罗马城由此产生，罗马王政时期由此开始。</p><h1 id="神话的开始–罗马王政时期"><a href="#神话的开始–罗马王政时期" class="headerlink" title="神话的开始–罗马王政时期"></a>神话的开始–罗马王政时期</h1><h2 id="第一任国王–罗穆卢斯–开启了一代传奇"><a href="#第一任国王–罗穆卢斯–开启了一代传奇" class="headerlink" title="第一任国王–罗穆卢斯–开启了一代传奇"></a>第一任国王–罗穆卢斯–开启了一代传奇</h2><h3 id="兄弟间的分歧以及罗马的建立"><a href="#兄弟间的分歧以及罗马的建立" class="headerlink" title="兄弟间的分歧以及罗马的建立"></a>兄弟间的分歧以及罗马的建立</h3><p>​    罗穆卢斯和列莫斯对国王的分配产生了争执，难以决定谁当国王，于是他们分而治之，罗穆卢斯在帕拉提尼山，列莫斯在阿文庭山，有一天由于列莫斯越过了两山的分界线，两兄弟起了争端。最终罗穆卢斯杀死了列莫斯，成为了罗马的王。此后，他在帕拉提尼山建立围墙，举行了隆重的仪式，给众神奉上祭品。这一天是B.C 753年4月21日，此后一千年，这个日子成为了罗马必不可少的节日。这一年罗穆卢斯18岁，在他和3000多名拉丁人的努力下，终于把罗马建成了国家。在建成罗马之后，罗穆卢斯并没有实施独裁统治，而是把权力分成三个机构：<strong>国王、元老院和库利亚大会</strong>，三方共同治理罗马，国王由库利亚大会投票选举产生。</p><h3 id="与萨宾人的恩恩怨怨"><a href="#与萨宾人的恩恩怨怨" class="headerlink" title="与萨宾人的恩恩怨怨"></a>与萨宾人的恩恩怨怨</h3><p>​    刚刚诞生的罗马的市民中，绝大多数都是单身男人。因此，罗穆路斯决定掠夺女人。罗穆路斯热情邀请了居住在附近的萨宾人参加罗马的祭祀活动。当时，在祭祀诸神的日子里，一切战斗都是禁止的。萨宾人于是接受罗穆路斯的邀请，全体出动来到了罗马。就在祭祀活动达到高潮的时候，罗穆路斯一声令下，罗马的年轻人向萨宾人的年轻姑娘们发起了突然袭击。毫无防备的萨宾男人只能护着自己的妻儿老小逃回自己的部落。萨宾人自然不甘屈辱，他们不会忍气吞声地接受这一事实。他们强烈要求罗马归还被抢的姑娘们。而罗穆路斯对于这一要求自然是一口回绝。他告诉对方说罗马的男人将和这些女孩子正式结婚，娶她们为妻。似乎是为了作表率作用，他还第一个举行了婚礼。</p><p>​    不甘受辱的萨宾人依然无法平息心中的怒气，他们向罗马宣战了。罗马和萨宾人之间共发生了四次战斗，几乎都是罗马占上风。事情出现转机是在第四次战斗正打得难分难解的时候，被罗马人抢去的萨宾女人突然闯入战场。她们纷纷表示对于丈夫和亲兄弟之间的相互杀戮不能再坐视不管了。这些女人知道，虽然自己是被抢去的，但是她们并没有被逼为奴。她们不仅享有充分的作为妻子的权利，而且从罗马人丈夫那里得到了爱情。罗马国王罗穆路斯和萨宾国王塔提乌斯一致认为应该听取这些女人的意见。两个部族于是开始了和平共处。罗穆路斯向萨宾人提出了一个和平建议。不是建议在相互尊重的基础上和平共处，而是建议两个部族合并起来。这个建议实际上是要萨宾人放弃自己的领地，移居到罗马。而七个山丘之一的奎里尔诺山被提供给他们作为新的居处。萨宾人接受了这一建议。并非罗马人吞并萨宾人。合并后的罗马由萨宾国王塔提乌斯和罗穆路斯共同治理。于是，罗马有了两个王。两个部族合并后，萨宾全体自由人享有和罗马人完全相同的市民权利。在保证他们有关私有财产的种种权利的同时，他们也享有在市民大会上的投票权。而且，罗穆路斯还为萨宾长老提供了在元老院的席位。</p><h3 id="国王的失踪"><a href="#国王的失踪" class="headerlink" title="国王的失踪"></a>国王的失踪</h3><p>​    公元前715年，这一天，罗穆路斯和以往一样正在检阅军队。突然天空乌云密布，一场暴风骤雨倾泻而至。倾盆大雨遮住了人们的视线，震耳欲聋的雷鸣声压倒了一切。等到雨过天晴，人们看到国王的座位空了，哪儿都不见罗穆路斯的身影。于是人们纷纷传言国王被神召到天上去了。对于罗穆路斯的功绩，所有人都很认同。所以当不幸突然降临时，人们在悲痛欲绝之余，决定认罗穆路斯为罗马国家之父，作为神来祭拜。</p><h2 id="第二任国王–努马–规章制度的完善者"><a href="#第二任国王–努马–规章制度的完善者" class="headerlink" title="第二任国王–努马–规章制度的完善者"></a>第二任国王–努马–规章制度的完善者</h2><h3 id="努马的升官路"><a href="#努马的升官路" class="headerlink" title="努马的升官路"></a>努马的升官路</h3><p>​    罗穆路斯在位期间，罗马和萨宾合并后，有大量萨宾人移居罗马。而萨宾人<strong>努马</strong>坚持留在祖先留下的土地上。他是一个读书人，晴天下地劳动，雨天在家学习，农耕之余努力探索知识。其道德之高尚、教养之深厚，罗马人早有所闻。对拉丁派和萨宾派之间的王位之争束手无策的罗马元老院一致同意推荐努马为罗马国王。长老们来到萨宾的领地，找到努马，向他转达了元老院的决定，请求他继承罗马王位。最初努马拒绝接受这一请求，因为此时的他已年届40岁。在当时，40岁的年龄已经不再适合开启新的人生了。然而，经不住长老们一次又一次的劝说，努马最终还是答应下来，随他们一起来到了罗马。努马进罗马城的时候，没有穿军装，也没有卫兵手举束棒斧的国王权杖跟随其后，而是用托加遮住头部的神官形象。</p><h3 id="新秩序的建立"><a href="#新秩序的建立" class="headerlink" title="新秩序的建立"></a>新秩序的建立</h3><p>​    就任王位后的努马，试图对依靠武力和战争打下建国基础的罗马进行立法和习俗的改革。这里所谓的立法改革，不是要制定全新的法律，而是要建立秩序，要让当时喜欢逞强好胜的罗马人懂得做人的礼法。在了解自身力量的局限性的同时，让他们懂得要对超越自身极限心存畏惧。</p><p>​    努马为诸神设立了等级制度，整顿了神官组织。神官专门为保护罗马人的诸神服务。神官阶级之长由最高神祇官担任，下设5至10位神祇官。此外还有负责保护圣火的神子，她们要连续工作30年，其间必须保持处女之身。另外，还设了十来位祭司，根据鸟飞的样子和啄食的方式等，来占卜国事的吉凶。每次作战前，祭司都要占卜。</p><p>​    努马为雅驽斯修建了一座神殿。大概是因为<strong>雅驽斯表示出和入的意思</strong>(后文有解释)，他的雕像有两个脑袋，分别面向前后两个方向。在雅驽斯神殿完工后，努马向人们展示了神殿的前后两个门。他说，这两个门要在战时打开，和平时期关闭。在努马统治罗马的43年间，据说这扇大门始终都是关闭的。但是，在努马死后，这扇大门几乎都是开着的，很少关闭。努马认为除了为防御的需要而战之外，这一时期的罗马不需要战争。他集中力量致力于振兴农业和畜牧业。目的是为了将来在战争取得胜利后，即使不对失败者进行掠夺也能做到自给自足（非常有远见）。努马还对罗马市民进行了职业分工，让每个人归属于有独立保护神的团体。为此，罗马出现了许多团体，如木工公会、铁匠公会、染色工公会、陶艺工公会等。建立这些职业团体的目的，不仅让人们对自己的职业充满自豪感，还可以防止拉丁人和萨宾人之间的部族对立。当时的罗马，除了这两个部族，还有其他民族的人大量涌入。伊特鲁里亚人（古意大利西北部的古老种族）甚至还成立了自治团体。罗马从建国之初就是一个多民族国家，在这样的国度，摩擦极易发生，如果没有一些预防措施，国家很难有所作为。</p><p>努马为了使人们的日常生活变得有序，还进行了历法改革。罗穆路斯时代的罗马，每年的总天数不固定。为此，努马根据月亮的盈亏，把一年分成了12个月，规定总天数为355天。余下的天数每隔20年作一次调整。努马制定的历法延续了650年，规范了人们的日常生活。努马对一年中每个月的顺序也作了调整。例如，原来的3月是每年的第一个月，努马把它换到了第三个月；原来的11月和12月调到最前面，变成1月和2月。只是，对每个月份的称呼没有进行大的改动。努马还规定了一年中的节日和休息日。每个月的<strong>第九天和第十五天</strong>为集市日。对罗马人来说，这两天就是休息日，他们会从田间劳作中解脱出来，拿着各自的作物前去赶集。除此之外，还有祭祀诸神的祭祀日。据说全年节假日共有45个。在这些节假日里，所有公务一律停止。</p><p>努马在统治罗马43年后，大概是受到了女神们的邀请，安详地去了另一个世界。</p><p><strong>P.S:在罗马神话中，雅努斯（Janus）有两副面孔：一个在前，一个在脑后；一副看着过去，一副看着未来。雅努斯也是天宫的守门人，他每天把天空的大门打开，让阳光普照大地；黄昏时就把门关上，黑夜也随之降临了。所以古罗马人就把雅努斯当作大门和出入口的保护神供奉，很多古建筑物上都有“门神”雅努斯的形象，最著名的就是史书中记载的古罗马雅努斯神殿</strong></p><p><img src="https://p1.itc.cn/q_70/images01/20210702/ae23eef891a549a3931dc30c010a110d.jpeg" alt="img"></p><h2 id="第三任国王–托里斯·奥斯蒂吕斯–开启了对外扩张的道路"><a href="#第三任国王–托里斯·奥斯蒂吕斯–开启了对外扩张的道路" class="headerlink" title="第三任国王–托里斯·奥斯蒂吕斯–开启了对外扩张的道路"></a>第三任国王–托里斯·奥斯蒂吕斯–开启了对外扩张的道路</h2><p>​    托里斯·奥斯蒂吕斯是拉丁系罗马人，和罗穆路斯一样，是个崇尚对外进攻的男人。通过努马的改革和整顿，内部得到充实的罗马，在这个男人的率领下，迎来了向外扩张的时代。</p><p>​    国王托里斯把进攻的第一个目标放在了阿尔巴。因为这里被认为是拉丁民族的发祥地，所以也是罗马人的祖先之地。要找一个开战的理由很简单。当时生活在两国国境线附近的农民之间时有争端。掠夺了对方的财物，阿尔巴方面拒绝作出赔偿。这就是开战的理由。</p><p>​    托里斯借口强大的伊特鲁里亚就在附近，无谓的流血对两国都没有好处，因此他建议双方各派代表，以决斗的形式决定胜负。两军都有三兄弟同时从军的士兵。他们是荷拉斯家的三个年轻人和居里亚斯家的三个人，分别代表各自的祖国和对方展开决斗。双方约定决斗失败的一方将无条件地接受获胜方的统治。</p><p>​    6个人之间的决斗开始了，罗马方面有一人首先倒下，接着又有一人阵亡。剩下的唯一一个罗马人惊恐万状，他逃离了决斗现场。他边跑边向后看，发现与阿尔巴人之间的距离也在不断拉大。于是，他瞅准时机勒住缰绳，转身打倒了第一个追来的阿鲁巴人，接着又成功撂倒第二个对手。这时对方也只剩一个人，双方进行了一番激斗，最后荷拉斯取得了胜利。但是阿尔巴王无法接受这一结果。他不仅没有遵守承诺，还煽动邻近部族起来反对罗马。为此，罗马不得不应付邻近各部族的挑衅，暂时顾不上要求阿尔巴王履行诺言了。其间，阿尔巴王态度暧昧，一味地静观战局的发展，而这一极其愚蠢的错误最终导致了阿尔巴的灭亡。战况在罗马占绝对优势的状态下发展。但是托里斯真正的目标不是眼前这些部族。罗马打败邻近各部族，成功制伏了他们之后的罗马军，一举向阿尔巴发起了进攻。几乎不费吹灰之力，罗马军就占领了阿尔巴，阿尔巴王被生擒活捉，处以极刑。阿尔巴城遭到了毁灭性的破坏，居民们被强行移居到罗马。</p><p>托里斯率领这一支军队一次又一次出征，取得了比罗穆路斯更加辉煌的军事战绩。他的统治历时32年。</p>]]></content>
    
    
    <categories>
      
      <category>历史</category>
      
    </categories>
    
    
    <tags>
      
      <tag>历史</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>极乐迪斯科人物梳理</title>
    <link href="/2022/10/02/%E6%9E%81%E4%B9%90%E8%BF%AA%E6%96%AF%E7%A7%91%E4%BA%BA%E7%89%A9%E6%A2%B3%E7%90%86/"/>
    <url>/2022/10/02/%E6%9E%81%E4%B9%90%E8%BF%AA%E6%96%AF%E7%A7%91%E4%BA%BA%E7%89%A9%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>加尔特-餐厅经理</p><p><strong>柯尔特</strong>-餐厅经理</p><p><strong>塞维尔</strong>-酒保</p><p><strong>金曷城</strong>-一位警官，也是本作的主角之一</p><p><strong>让 维克玛</strong>-主角的搭档</p><p><strong>麦克托森</strong> 和 <strong>切斯特麦克莱恩</strong> 是搭档</p><p>主角：马伦</p>]]></content>
    
    
    <categories>
      
      <category>极乐迪斯科</category>
      
    </categories>
    
    
    <tags>
      
      <tag>极乐迪斯科</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>股价对公司的影响</title>
    <link href="/2022/09/30/%E8%82%A1%E4%BB%B7%E5%AF%B9%E5%85%AC%E5%8F%B8%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
    <url>/2022/09/30/%E8%82%A1%E4%BB%B7%E5%AF%B9%E5%85%AC%E5%8F%B8%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
    
    <content type="html"><![CDATA[<p>1.股价对公司并不会造成直接影响，反而是公司盈利或亏损会对股价造成影响，而且很多股东可能因此套现</p><p>2.股价上涨到一定程度时，银行会主动找你，假设上涨到发行价的十倍，那么你只需要花费原来十分之一的代价即可获得原来的条件</p>]]></content>
    
    
    <categories>
      
      <category>金融</category>
      
    </categories>
    
    
    <tags>
      
      <tag>金融</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络--物理层</title>
    <link href="/2022/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <url>/2022/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>1.连续变化的信号（数据）称为模拟信号（模拟数据）</p><p>​    取值仅为优先的离散值的数据（信号）称为数字数据（数据信号）</p><p>2.数据的传输方式：串行，并行</p><p>​    串行是指1比特1比特的排队传输</p><p>​    并行是指若干个比特经过若干条通道同时进行传输</p><p>3.码元：用一个固定时长的信号波形（数字脉冲）表示一位k进制数字，其中信号称为k进制码元，时长称为码元宽度</p><p>4.信源：信号源头；信道：信号传输的通道；信宿：信号的终点</p><p>5.通信系统一般是双向的，包括一条发送信道和一条接收信道</p><p>6.基带信号：将数字信号用0和1表示</p><p>​    宽带信号：将基带信号调制后，形成复用模拟信号</p><p>7.信道：</p><p>​    双向信道：只有一个方向的通信</p><p>​    半双工信道：双方都可以发送接收信息，但是其中一个不能同时接收和发送</p><p>​    全双工信道：双方都可以同时发送和接收</p><p>8.速率可以用“码元传输速率”和“信息传输速率”表示</p><p>​    单位：b/s</p><p>9.带宽表示从一点到另一点的数据率，单位是b/s</p><h1 id="奈奎斯特，香农定理"><a href="#奈奎斯特，香农定理" class="headerlink" title="奈奎斯特，香农定理"></a>奈奎斯特，香农定理</h1><p>1.w：理想低通信道的带宽</p><p>​    v：每个码元离散电平数（有多少种不同的码元），如：有16种不同的码元，有4个二进制位，传输速率是码元速率的4倍</p><p>​    低通信道下的极限数据速率：2wlog2v（单位b/s）</p><p>2.香农：在带宽受限，且有高斯噪声下，极限传输速率</p><p>​    速率：wlog2(1+S/N)，单位：b/s</p><p>​    w：带宽；S:信号的平均功率，N：高斯噪声功率</p><p>​    S/N为信噪比，信噪比=10log10(S/N)，当S/N=10，信噪比：10</p><p>​                                                                          当S/N=1000，信噪比：30</p><p>​    <strong>只要传输速率小于极限传输速率，就能消除误差</strong></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络--网络体系结构和参考模型</title>
    <link href="/2022/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络的分层结构"><a href="#计算机网络的分层结构" class="headerlink" title="计算机网络的分层结构"></a>计算机网络的分层结构</h1><p>一、各层相互独立，灵活性好</p><p>二、计网的第一层常称为物理层，第n层的活动元素称为第n层<strong>实体</strong></p><p>​    不同机器的同一层称为对等层，同一层的实体称为对等实体</p><p>​    第n层实体提供的服务提供给n+1层所利用</p><p>​    n层为服务提供者，第n+1层服务于用户</p><p>三、每一层中的报文分成两部分：数据部分（SDU）；控制信息部分（PCI）</p><p>​    <strong>SDU：为完成所要求的功能而传送数据，第n层称为n-SDU</strong></p><p>​    <strong>PCI：控制协议操作的信息。第n层控制信息记为n-PCI</strong></p><p>​    <strong>PDU：对等层数之间传送的数据单位</strong></p><p>​    <strong>每层的PDU都有俗称</strong></p><p>四、关系：</p><p><strong>n-SDU+n-PCI=n-PDU=(n-1)-SDU</strong></p><p>五.协议、接口、服务</p><p>1.协议：由语法 语义 同步三部分组成</p><p>​    a.语法：传输格式</p><p>​    b.语义：要完成神功能</p><p>​    c.同步：事件实现顺序的详细说明</p><p>2.接口：</p><p>​    同一结点内相邻两层间交换信息的连接点，只能为紧邻的层次间提供接口</p><p>3.服务：</p><p>​    下层为紧邻层提供的功能调用</p><p>​    上层使用下层提供的服务必须与下层交换一些命令，再OSI参考模型中称作服务原语：</p><p>​        a.请求：用户-&gt;提供者，请求服务完成</p><p>​        b.指示：提供者-&gt;用户，指示用户做某事</p><p>​        c.相应：用户-&gt;提供者，对指示的相应</p><p>​        d.证实：提供者-&gt;用户，对请求的证实</p><p><strong>用户只能看见服务，看不见协议，即下面的协议对上面的用户是透明的</strong></p><p><strong>在一层内完成的全部功能并不能全部叫做服务，只有被上一层看得见的才叫做服务</strong></p><h2 id="计算机网络提供的服务分类"><a href="#计算机网络提供的服务分类" class="headerlink" title="计算机网络提供的服务分类"></a>计算机网络提供的服务分类</h2><h3 id="面向连接服务和无连接服务"><a href="#面向连接服务和无连接服务" class="headerlink" title="面向连接服务和无连接服务"></a>面向连接服务和无连接服务</h3><p>面向连接服务：通信之前双方必须先建立连接，分配资源。再传输结束之后释放连接和资源。例子：TCP是面向连接服务                             的协议</p><p>无连接服务：通信前双方不需要先建立连接，要发送数据时直接发送即可，不能保证通信的可靠性例如：IP、UDP就是无                         连接服务的协议</p><h3 id="可靠服务和不可靠服务"><a href="#可靠服务和不可靠服务" class="headerlink" title="可靠服务和不可靠服务"></a>可靠服务和不可靠服务</h3><p>可靠服务：网络具有纠错、应答的能力，能保证数据正确，可靠的传送到目的地</p><p>不可靠服务：只能尽量使数据正确，可靠的传送到目的地，但是不能保证</p><h3 id="有应答服务和无应答服务"><a href="#有应答服务和无应答服务" class="headerlink" title="有应答服务和无应答服务"></a>有应答服务和无应答服务</h3><p>有应答服务：接收方在接收到发送方发送的数据后，给出相应的应答，这种应答不是人为的，而是机器自动应答。有肯定                         应答也有否定应答，通常在接收到错误的信息后给出的就是否定应答。</p><p>无应答服务：指接收方收到数据后不自动给出应答。</p><h1 id="参考模型"><a href="#参考模型" class="headerlink" title="参考模型"></a>参考模型</h1><h2 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h2><p>开放系统互连参考模型（OSI）有七层（由下至上）：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层</p><p><strong>记忆：物联网叔会使用</strong></p><p><strong>物理层，数据链路层，网络层 称为通信子网</strong></p><p><strong>会话层，表示层，应用层 称为资源子网</strong>‘</p><p><img src="https://bkimg.cdn.bcebos.com/pic/54fbb2fb43166d2259d200b3442309f79052d26b?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U5Mg==,g_7,xp_5,yp_5/format,f_auto" alt="img"></p><p><img src="/2022/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/image-20220919170312999.png" alt="image-20220919170312999"></p><h3 id="物理层（Physical-Layer）"><a href="#物理层（Physical-Layer）" class="headerlink" title="物理层（Physical Layer）"></a>物理层（Physical Layer）</h3><p><strong>传输单位：比特</strong></p><p>定义了数据终端设备DTE和数据通信设备DCE的物理和逻辑的连接方法</p><h3 id="数据链路层（Data-Link-Layer）"><a href="#数据链路层（Data-Link-Layer）" class="headerlink" title="数据链路层（Data Link Layer）"></a>数据链路层（Data Link Layer）</h3><p><strong>传输单位：帧</strong></p><p><strong>任务：将网络层传来的IP数据组装成帧</strong></p><p><strong>差错控制功能：如果传输信号A代表了数字1，在传输的过程中信号A收到干扰变成了信号B，而信号B恰好也代表了数字1，如果两个结点之间规定了数据链路层协议，那么可以检测出这个错误并且将错误丢弃，称为差错控制功能。</strong></p><p><strong>流量控制：如果A端发送的速度大于B端接收的速度，会造成传输效率的下降，为了使得传输效率相当，可以采取“流量控制”的方法，使得发送端速率等于接收端速率。</strong></p><p><strong>典型的数据链路层协议：SDLC，HDLC，PPP，STP</strong></p><h3 id="网络层（Network-Layer）"><a href="#网络层（Network-Layer）" class="headerlink" title="网络层（Network Layer）"></a>网络层（Network Layer）</h3><p><strong>传输单位：数据报</strong></p><p><strong>主要任务：把网络层的协议数据单元从源端传到目的端，为分组交换网上的不同主机提供通信服务</strong></p><p><strong>网络层的协议有：IP，IPX，ICMP，IGMP，ARP</strong></p><h3 id="传输层（Transport-Layer）"><a href="#传输层（Transport-Layer）" class="headerlink" title="传输层（Transport Layer）"></a>传输层（Transport Layer）</h3><h3 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h3><p><strong>向表示层实体提供建立连接上有序的传输数据</strong></p><h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><p><strong>用于处理在两个通信系统之间的交换信息的方式</strong></p><h4 id="数据格式变换（翻译官）"><a href="#数据格式变换（翻译官）" class="headerlink" title="数据格式变换（翻译官）"></a>数据格式变换（翻译官）</h4><p>如把二进制数据翻译成jpg文件</p><h4 id="数据加密解密"><a href="#数据加密解密" class="headerlink" title="数据加密解密"></a>数据加密解密</h4><p>我的微信密码是XXX，到了接收端会解密</p><h4 id="数据压缩和恢复"><a href="#数据压缩和恢复" class="headerlink" title="数据压缩和恢复"></a>数据压缩和恢复</h4><p><strong>主要协议：JPEG，ASCII</strong></p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p><strong>指能和用户交互，并且产生流量的程序</strong></p><p><strong>经典应用层协议：文件传输（FTP），电子邮件（SMTP），万维网（HTTP）</strong></p><h2 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h2><p>1.由ARPA在研究ARPAnet时提出的TCP/IP模型</p><p>2.四层：网络接口层（OSI中物理，数据链路层），网际层，传输层，应用层（OSI中的会话层，表示层，应用层）</p><p>3.网际层将分组发往任何网络，为之选择出独立的路由器，定义了标准的分组协议，目前是第四版IPV4，下一版本是IPV6</p><p>4.传输层使发送端主机与接收端主机对话，主要协议有：</p><p>​    有连接的-&gt;TCP协议；无连接的-&gt;UDP协议</p><p>5.应用层：与用户进行对话，协议有FTP,SMTP,HTTP</p><h3 id="与OSI模型的区别"><a href="#与OSI模型的区别" class="headerlink" title="与OSI模型的区别"></a>与OSI模型的区别</h3><p>1.OSI精确的定义了三个概念：协议，服务，接口，而TCP/IP没有确切的定义</p><p>2.TCP/IP是后来者，不会出现协议与模型不匹配的情况。</p><p><strong>传输层的SDU+PTC=传输层的PDU，下放到网络层，变成网络层的SDU，发送端逐级包起来</strong></p><h2 id="协议和服务的区别"><a href="#协议和服务的区别" class="headerlink" title="协议和服务的区别"></a>协议和服务的区别</h2><p>1.协议实现保证了能向上一层提供服务</p><p>2.协议是<strong>水平</strong>的，服务是<strong>垂直</strong>的</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>1.数据链路层有流量控制，差错校验，物理寻址的功能</p><p>2.物理层不参加封装工作</p><p>3.TCP/IP 模型的网络层提供“无连接不可靠的数据报服务”</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-- 排序</title>
    <link href="/2022/09/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/09/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="排序的基本概念与分类"><a href="#排序的基本概念与分类" class="headerlink" title="排序的基本概念与分类"></a>排序的基本概念与分类</h1><p>假设有n个记录的序列{r1,r2,…,rn}，对应的关键字{k1,k2,…,kn}，确定一种排列p1,p2,…,pn,使其关键字满足Kp1&lt;Kp2&lt;…&lt;Kpn,使得序列成为按关键字有序的序列{rp1,rp2,…,rpn}</p><span id="more"></span><h2 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h2><p>假设ki=kj(1&lt;=i&lt;=n,0,=j&lt;=n,i!=j)，且在排序前ri&lt;rj.若排序后ri&lt;rj，说明排序方法是稳定的，否则排序方法不稳定</p><h2 id="内排序和外排序"><a href="#内排序和外排序" class="headerlink" title="内排序和外排序"></a>内排序和外排序</h2><p>1.内排序：需要排序的记录全部在内存中</p><p>​    外排序：内存放不下这么多记录，需要在内外存中多次交换数据才可以实现</p><p>2.算法的性能受以下三个方面影响</p><p>​    a.时间性能：高效的性能算法应减少比较次数，和尽可能少去移动</p><p>​    b.辅助空间：指除了存储排序所需的空间外，执行算法所需要的时间</p><p>​    c.算法的复杂度（不是时间复杂度）：把内排序分为：插入排序，交换排序，选择排序，归并排序</p><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>七种排序算法：</p><p><strong>简单算法：</strong>冒泡排序，简单选择排序，直接插入排序</p><p><strong>改进算法</strong>：希尔排序，堆排序，归并排序，块首排序</p><p>1.排序所用到的结构函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 30</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">int</span> r[MAXSIZE+<span class="hljs-number">1</span>];<span class="hljs-comment">//排序数组</span><br>    <span class="hljs-type">int</span> length;<br>&#125;SqList<br></code></pre></td></tr></table></figure><p>2.交换元素的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(SqList *L,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<span class="hljs-comment">//交换i和j的元素</span><br><span class="hljs-type">int</span> temp=L-&gt;r[i];<br>    L-&gt;r[i]=L-&gt;r[j];<br>    L-&gt;r[j]=temp;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="冒泡函数"><a href="#冒泡函数" class="headerlink" title="冒泡函数"></a>冒泡函数</h2><p>1.思想：两两比较相邻的记录的关键字，如果反序就交换，知道无反序为止</p><p>​    有三种方法：</p><h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">BubbleSort1</span><span class="hljs-params">(SqList *L)</span>&#123;<br>    <span class="hljs-type">int</span> i,j;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;L-&gt;Length<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-keyword">for</span>(j=i+<span class="hljs-number">1</span>;j&lt;L-&gt;Length;i++)<br>            <span class="hljs-keyword">if</span>(r[i]&gt;r[j])<br>                swap(L,i,j);<span class="hljs-comment">//交换</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">BubbleSort</span><span class="hljs-params">(SqLisy=t *L)</span>&#123;<br>    <span class="hljs-type">int</span> i,j;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;L-&gt;Length;i++)&#123;<br>        <span class="hljs-keyword">for</span>(j=L-&gt;Length<span class="hljs-number">-1</span>;j&gt;=i;j--)&#123;<br>            <span class="hljs-keyword">if</span>(L-&gt;r[j]&gt;L-&gt;r[i+<span class="hljs-number">1</span>])<br>                swap(L,j,j+<span class="hljs-number">1</span>);<span class="hljs-comment">//交换j和j+1的值</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//此时i从前往后，j从后往前！</span><br><span class="hljs-comment">//当i=1时，j从Length-1循环并交换并交换到1位置，后面也是如此</span><br></code></pre></td></tr></table></figure><h3 id="第三种方法（冒泡排序优化）"><a href="#第三种方法（冒泡排序优化）" class="headerlink" title="第三种方法（冒泡排序优化）"></a>第三种方法（冒泡排序优化）</h3><p>如果只是循环的第一遍就所有的排序正常了，那么就需要一个条件来跳出循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">BubbleSort</span><span class="hljs-params">(SqList *L)</span>&#123;<br>    <span class="hljs-type">int</span> i,j;<br>    Status flag==FALSE;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;L-&gt;Length<span class="hljs-number">-1</span>;j&lt;<span class="hljs-number">1</span>;j--)&#123;<br>        <span class="hljs-keyword">if</span>(L-&gt;r[j]&gt;L-&gt;r[j<span class="hljs-number">-1</span>])&#123;<br>            swap(L,j+<span class="hljs-number">1</span>,j);<br>            flag=TRUE;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>冒泡排序的时间复杂度O(n+n(n-1)/2)=O(n^2/2+n/2)=O((n^2+n)/2)=O(n^2)</p><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><p>1.代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">SelectSort</span><span class="hljs-params">(SqList *L)</span>&#123;<br><span class="hljs-type">int</span> i,j,min;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;L-&gt;Length;i++)&#123;<br>        min=i;<br>        <span class="hljs-keyword">for</span>(j=i+<span class="hljs-number">1</span>;j&lt;=L-&gt;Length;j++)&#123;<span class="hljs-comment">//找出最小值</span><br>        <span class="hljs-keyword">if</span>(L-&gt;r[min]&gt;L-&gt;r[j])<br>                min=j;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i!=min)<br>            swap(L,i,min);<span class="hljs-comment">//把i变为最小值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.简单选择排序的复杂性O(n^2)</p><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>1.代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InsertSort</span><span class="hljs-params">(SqList *L)</span>&#123;<br><span class="hljs-type">int</span> i,j;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i&lt;L-&gt;Length;i++)&#123;<span class="hljs-comment">//从2开始是假设第一个已经放在表里了</span><br>    <span class="hljs-keyword">if</span>(L-&gt;r[i]&lt;L-&gt;r[i<span class="hljs-number">-1</span>])&#123;<br>            L-&gt;r[<span class="hljs-number">0</span>]=L-&gt;r[i];<span class="hljs-comment">//哨兵</span><br>            <span class="hljs-keyword">for</span>(j=i<span class="hljs-number">-1</span>;L-&gt;r[j]&gt;L-&gt;r[<span class="hljs-number">0</span>];j--)<br>                L-&gt;r[j+<span class="hljs-number">1</span>]=L-&gt;r[j];<span class="hljs-comment">//后移</span><br>            L-&gt;r[j+<span class="hljs-number">1</span>]=L-&gt;r[<span class="hljs-number">0</span>];<span class="hljs-comment">//插入正确位置</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.直接插入排序的时间复杂度O(n^2)</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>1.基本有序：小的基本上在前面，大的基本上在后面，大体上不出问题即可。将相距某个“增量”的记录组成子序列，才能保证直接插入后结果有序</p><p>2.代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">ShellSort</span><span class="hljs-params">(SqList *L)</span>&#123;<br>    <span class="hljs-type">int</span> i,j;<br>    <span class="hljs-type">int</span> increment=L-&gt;Length;<br>    <span class="hljs-keyword">do</span>&#123;<br>        increment=(increment/<span class="hljs-number">3</span>)+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(i=increment+<span class="hljs-number">1</span>;i&lt;L-&gt;Length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(L-&gt;r[i]&lt;L-&gt;i-increment)&#123;<span class="hljs-comment">//把L-&gt;r[i]插入子表</span><br>            L-&gt;r[<span class="hljs-number">0</span>]=L-&gt;r[i];<br>                <span class="hljs-keyword">for</span>(j=i-increment;j&gt;<span class="hljs-number">0</span>&amp;&amp;L-&gt;r[<span class="hljs-number">0</span>]&lt;L-&gt;r[j];j=j-increment)<br>                    L-&gt;r[j+increment]=L-&gt;r[<span class="hljs-number">0</span>];<span class="hljs-comment">//插入</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(increment&gt;<span class="hljs-number">1</span>);<span class="hljs-comment">//increment=1时停止循环</span><br>&#125;<br></code></pre></td></tr></table></figure><p>3.增量一般在总长度的一半左右</p><p>4.时间复杂度为O(nlogn)</p><p>5.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">shell_Sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[];<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> i,j,inc,key;<br>    <span class="hljs-comment">//初始增量n/2，每趟之后除2</span><br>    <span class="hljs-keyword">for</span>(inc=n/<span class="hljs-number">2</span>;inc&gt;=<span class="hljs-number">1</span>;inc=inc/<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-comment">//每一趟采用插入排序，前面的</span><br>        <span class="hljs-keyword">for</span>(i=inc;i&lt;n;i++)&#123;<span class="hljs-comment">//i=inc是因为从第二个元素开始插入</span><br>        key=arr[i];<span class="hljs-comment">//要插入的元素</span><br>            <span class="hljs-keyword">for</span>(j=i;j&gt;=inc&amp;&amp;key&lt;arr[j-inc];j-=inc)&#123;<span class="hljs-comment">//内部实现</span><br>                <br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>1.堆排序（Heap Sort）是对简单选择排序的改进</p><p>2.堆：每个结点的值都<strong>大于</strong>或等于其左右孩子结点的值，称为大顶堆</p><p>​            每个结点的值都<strong>小于</strong>或等于其左右孩子结点的值，称为小堆顶</p><p>3.堆满足以下条件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">ki&gt;=k2i(大于左孩子)ki&lt;=k2i(小于左孩子)<br>    或其中<span class="hljs-number">1</span>&lt;=i&lt;=n/<span class="hljs-number">2</span> 向下取整<br>ki&gt;=k2i+<span class="hljs-number">1</span>(大于右孩子)ki&lt;=k2i+<span class="hljs-number">1</span>(小于右孩子)<br></code></pre></td></tr></table></figure><p>4.对顺序表L进行堆排序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HeapSort</span><span class="hljs-params">(SqList *L)</span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=L-&gt;Length/<span class="hljs-number">2</span>;i&gt;<span class="hljs-number">0</span>;i--)<span class="hljs-comment">//把L中的r构建成大顶堆</span><br>        HeapAdjust(L,i,L-&gt;Length);<br>    <span class="hljs-keyword">for</span>(i=L-&gt;Length;i&gt;<span class="hljs-number">1</span>;i--)&#123;<br>        swap(L,<span class="hljs-number">1</span>,i);<span class="hljs-comment">//将堆顶与子序列最后一个元素对调</span><br>        HeapAdjust(L-,<span class="hljs-number">1</span>,i<span class="hljs-number">-1</span>);<span class="hljs-comment">//将除了最后一个元素另外的元素进行大堆排序</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>5.HeapAdjust算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HeapAdjust</span><span class="hljs-params">(SqList *L,<span class="hljs-type">int</span> s;<span class="hljs-type">int</span> m)</span>&#123;<span class="hljs-comment">//m是length，s=m/2向下取整</span><br><span class="hljs-type">int</span> temp,j;<br>    temp=L-&gt;r[s];<br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">2</span>*s;j&lt;=m;j*=<span class="hljs-number">2</span>)&#123;<span class="hljs-comment">//沿着关键字较大的孩子结点向下筛选</span><br>        <span class="hljs-keyword">if</span>(j&lt;m&amp;&amp;L-&gt;r[j]&lt;L-&gt;r[j+<span class="hljs-number">1</span>])<br>            ++j;<br>        <span class="hljs-keyword">if</span>(temp&gt;=L-&gt;r[j])<br>            <span class="hljs-keyword">break</span>;<br>        L-&gt;r[s]-&gt;L-&gt;r[j];<br>        s=j;<br>    &#125;<br>    L-&gt;r[s]=temp;<span class="hljs-comment">//插入</span><br>&#125;<br></code></pre></td></tr></table></figure><p>6.堆排序的时间复杂度O(nlogn)</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>1.归并即把多个数值归类称两两结合或者三三结合再进行比较</p><p>2.Merging Sort原理：设初始序列由n个记录，可以看成有n个有序的子序列，得到n/2(向上取整)和长度为2或1的有序子序列，再两两归并，直至得到一个长度为n的有序序列为止。</p><p>3.Merging Sort 代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MergingSort</span><span class="hljs-params">(SqList *L)</span><br><span class="hljs-title function_">MSort</span><span class="hljs-params">(L-&gt;r,L-&gt;r,<span class="hljs-number">1</span>,L-&gt;Length)</span><br></code></pre></td></tr></table></figure><p>4.MSort算法（将SR[s…t]归并排序为TR[]）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MSort</span><span class="hljs-params">(<span class="hljs-type">int</span> SR[],<span class="hljs-type">int</span> TR1[],<span class="hljs-type">int</span> s;<span class="hljs-type">int</span> t)</span>&#123;<span class="hljs-comment">//s起点，t终点</span><br><span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> TR2[MAXSIZE+<span class="hljs-number">1</span>];<span class="hljs-comment">//TR2是空数组</span><br>    <span class="hljs-keyword">if</span>(s==t)<span class="hljs-comment">//如果只有一个元素</span><br>        TR1[s]=SR[s];<br>    <span class="hljs-keyword">else</span>&#123;<br>        m=(s+t)/<span class="hljs-number">2</span>;<span class="hljs-comment">//将SR[s...t]平分为SR[s...m]和SR[m+1...t]</span><br>        MSort(SR,TR2,s,m);<br>        MSort(SR,TR2,m+<span class="hljs-number">1</span>,t);<span class="hljs-comment">//递归将SR[m+1,t]归并为由有序TR2[m+1,t]</span><br>        Merge(TR2,TR1,s,m,t);<span class="hljs-comment">//把TR2[s...m]和TR2[m+1,t]归并到TR1[s...t]</span><br>        <span class="hljs-comment">//Merge的作用就是把有序的TR2合并为TR1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>5.Merge函数的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Merge</span><span class="hljs-params">(<span class="hljs-type">int</span> SR[];<span class="hljs-type">int</span> TR[];<span class="hljs-type">int</span> s;<span class="hljs-type">int</span> m;<span class="hljs-type">int</span> n)</span>&#123;<br><span class="hljs-type">int</span> j,k,l;<span class="hljs-comment">//j,k用于循环</span><br><span class="hljs-keyword">for</span>(j=m+<span class="hljs-number">1</span>,,k=i;i&lt;=m&amp;&amp;j&lt;=n;k++)&#123;<br>        <span class="hljs-keyword">if</span>(SR[i]&lt;SR[j])<br>            TR[k]=SR[i++];<br>        <span class="hljs-keyword">else</span><br>            TR[k]=SR[j++];<br>    &#125;<br>    <span class="hljs-keyword">if</span>(i&lt;=m)&#123;<br>        <span class="hljs-keyword">for</span>(l=<span class="hljs-number">0</span>;l=m-i;l++)<br>            TR[k+<span class="hljs-number">1</span>]=SR[i+<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">if</span>(j&lt;=n)&#123;<br>        <span class="hljs-keyword">for</span>(l=<span class="hljs-number">0</span>;l&lt;=n-j;l++)<br>            TR[k+<span class="hljs-number">1</span>]=SR[j+<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据采集--数据采集及清洗概念</title>
    <link href="/2022/08/30/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86-%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%8F%8A%E6%B8%85%E6%B4%97%E6%A6%82%E5%BF%B5/"/>
    <url>/2022/08/30/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86-%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%8F%8A%E6%B8%85%E6%B4%97%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据采集</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据采集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构--查找</title>
    <link href="/2022/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9F%A5%E6%89%BE/"/>
    <url>/2022/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="关于查找的基本概念，其中二叉排序树要重点掌握"><a href="#关于查找的基本概念，其中二叉排序树要重点掌握" class="headerlink" title="关于查找的基本概念，其中二叉排序树要重点掌握"></a>关于查找的基本概念，其中二叉排序树要重点掌握</h1><span id="more"></span><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>1.查找表（Search Table）是由同一类型数据元素构成的集合</p><p>2.关键字是数据元素中某个数据项的值</p><p>​    若关键字可以唯一的标识一个记录，那称为主关键字</p><p>​    对于可以识别多个记录的关键字称为次关键字</p><p>3.操作表分为两大类：静态操作表 and 动态操作表</p><p>​    a.静态操作表：只做查找操作的查找</p><p>​    b.动态查找表：在查找的同时可以进行添加，删除等操作</p><h1 id="顺序表查找"><a href="#顺序表查找" class="headerlink" title="顺序表查找"></a>顺序表查找</h1><p>1.按照从第一个到最后一个的顺序挨个查找，若全部没有对应，则查找失败</p><p>2.顺序查找代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//a为数组,n为要查找数组长度，key为要查找的关键字</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Sequental_Search</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> key)</span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]==key)<br>            <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.优化版顺序查找</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//有哨兵版</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Sequential_Search_remark</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> key)</span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    a[<span class="hljs-number">0</span>]=key;<span class="hljs-comment">//a[0]为哨兵</span><br>    i=n;<span class="hljs-comment">//循环从数组尾部开始</span><br>    <span class="hljs-keyword">while</span>(a[i]!=key)<br>        i--;<br>    <span class="hljs-keyword">return</span> i;<span class="hljs-comment">//返回0说明查找失败</span><br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度为O(n)</p><h1 id="有序表查找"><a href="#有序表查找" class="headerlink" title="有序表查找"></a>有序表查找</h1><p>一、折半查找（Binary Search）</p><p>1.线性表必须用顺序表存储</p><p>2.例：对于数组{0,1,16,24,35,47,59,62,73,88,99},查找是否有62这个数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Binary_Search</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> key)</span>&#123;<br><span class="hljs-type">int</span> low,high,mid;<br>    low=<span class="hljs-number">1</span>;<span class="hljs-comment">//首位1</span><br>    high=n;<span class="hljs-comment">//末位n</span><br>    <span class="hljs-keyword">while</span>(low&lt;=high)&#123;<br>        mid=(high+low)/<span class="hljs-number">2</span>;<span class="hljs-comment">//折半</span><br>        <span class="hljs-keyword">if</span>(key&lt;a[mid])<span class="hljs-comment">//查找值小于中值</span><br>            high=mid<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key&gt;a[mid])<span class="hljs-comment">//查找值大于中值</span><br>            low=mid+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.折半查找时复杂度O(logn)</p><h1 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h1><p>1.在折半查找时，mid=(high+low)/2=low+(high-low)/2</p><p>​    可以改为mid=low+(key-a[low])*(high-low)/(a[high]-a[low])</p><p>2.插值查找的时间复杂度也为O(logn)</p><h1 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Fibonacci_Search</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> key)</span>&#123;<br>    <span class="hljs-type">int</span> low,high,mid,i,k;<br>    low=<span class="hljs-number">1</span>;<span class="hljs-comment">//最低位置为1</span><br>    high=n;<span class="hljs-comment">//最高位置为n</span><br>    k=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(n&gt;F[k]<span class="hljs-number">-1</span>)<span class="hljs-comment">//计算n在斐波那契数列中的位置</span><br>        k++;<span class="hljs-comment">//此时，k是n在数列中下标</span><br>    <span class="hljs-keyword">for</span>(i=n;i&lt;F[k]<span class="hljs-number">-1</span>;i++)<br>        a[i]=a[n];<span class="hljs-comment">//都用最后一个数补全</span><br>    <span class="hljs-keyword">while</span>(low&lt;=high)&#123;<br>        mid=low+F[k<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>;<span class="hljs-comment">//当前分隔的下标</span><br>        <span class="hljs-keyword">if</span>(key&lt;a[mid])&#123;<br>            high=mid<span class="hljs-number">-1</span>;<span class="hljs-comment">//跟折半一样</span><br>            --k;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key&gt;a[mid])&#123;<br>            low=mid+<span class="hljs-number">1</span>;<br>            k=k<span class="hljs-number">-2</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(mid&lt;=n)<br>                <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> n;<span class="hljs-comment">//补全数组，返回n</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="线性索引查找"><a href="#线性索引查找" class="headerlink" title="线性索引查找"></a>线性索引查找</h1><p>一、索引：把一个关键字和它对应的记录相关联</p><p>二、线性索引：把所有变为线性表存储，有三种线性存储方式</p><h2 id="稠密索引"><a href="#稠密索引" class="headerlink" title="稠密索引"></a>稠密索引</h2><p>关键码后面有一个指针用于索引。</p><h2 id="分块索引"><a href="#分块索引" class="headerlink" title="分块索引"></a>分块索引</h2><p>对数据进行分块，再对每一块进行索引</p><p>a.对应“块”有以下两个特点：</p><p>​    <strong>不要求块内有序，因为块内有序所要求的空间时间多</strong></p><p>​    <strong>块间有序，如第二块中所有关键字均大于第一块中所有关键字</strong></p><p>b.对于索引项结构分以下三个数据项</p><p>​    <strong>存储最大关键码，为了对比下一个项中的最小关键码，使得前一项的最大关键码大于后一项的最小关键码</strong></p><p>​    <strong>存储块中的记录个数，便于循环</strong></p><p>​    <strong>用于指向块首数据元素的指针，方便遍历</strong></p><p>c.分块索引的步骤：</p><p>​    <strong>使用折半/插值等方法找到要查找关键的位置</strong></p><p>​    <strong>顺序查找块中的关键码</strong></p><hr><p>设n个记录被分成m份，每份有t条记录,有n=m*t</p><p>设lb为块间平均查找长度，lb=(m+1)/2,设Lw为块内平均查找长度，Lw=(t+1)/2</p><p>所以分块索引查找的平均长度：ASLw=(m+1)/2+(t+1)/2=n/2t+t/2+1</p><p>当m=t时，情况最佳，n=m*t=t^2,此时ASLw=(1/2 *2t)+1=t+1=根号n+1</p><p>时间复杂度为O(根号n) </p><h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p>与正向索引的区别：</p><p><strong>正向索引：</strong>  <strong>当用户发起查询时（假设查询为一个关键词），搜索引擎会扫描索引库中的所有文档，找出所有包含关键词的文档，这样依次从文档中去查找是否含有关键词的方法叫做正向索引</strong></p><p>如果说正向索引是由文件索引关键字，那么倒排索引就是从关键字来索引文件</p><h1 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h1><p>1.二叉排序树(Binary Sort Tree)有四种情况：</p><p><strong>一棵空树</strong></p><p><strong>左子树不空，且左子树中的所有结点均小于根节点</strong></p><p><strong>右子树不空，且右子树中的所有结点均大于根节点</strong></p><p><strong>它的左右子树也分别是二叉排序树</strong></p><p>2.定义二叉树结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span>&#123;</span><br><span class="hljs-type">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTree</span> *<span class="hljs-title">lchild</span>,*<span class="hljs-title">rchild</span>;</span><br>&#125;BiTNode,*BiTree;<br></code></pre></td></tr></table></figure><p>3.二叉排序树的查找算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">SearchBST</span><span class="hljs-params">(BiTree T,<span class="hljs-type">int</span> key,BiTree f,BiTree *p)</span>&#123;<span class="hljs-comment">//f初始化为NULL</span><br><span class="hljs-comment">//指针f指向T的双亲，若成功，则p指向该元素结点，未成功访问最后一个结点</span><br>    <span class="hljs-keyword">if</span>(!T)&#123;<span class="hljs-comment">//成功</span><br>    *p=f;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key==T-&gt;data)&#123;<br>        *p=T;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key&lt;T-&gt;data)<span class="hljs-comment">//小于，网左子树找</span><br>        <span class="hljs-keyword">return</span> SearchBST(T-&gt;lchild,key,T,p);<span class="hljs-comment">//此时必有f=T\</span><br><span class="hljs-comment">    else//大于，往右子树找</span><br>        <span class="hljs-keyword">return</span> SearchBST(T-&gt;rchild,key,T,p);<br>&#125;<br></code></pre></td></tr></table></figure><p>4.二叉排序树的插入：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//当树中不存在等于key的元素时插入key，返回TRUE，否则返回FALSE</span><br>Status <span class="hljs-title function_">InsertBST</span><span class="hljs-params">(BiTree *T,<span class="hljs-type">int</span> key)</span>&#123;<br>    BiTree p,s;<span class="hljs-comment">//s是key的结点</span><br>    <span class="hljs-keyword">if</span>(!SearchBST(*T,key,<span class="hljs-literal">NULL</span>,&amp;p))&#123;<span class="hljs-comment">//查找失败，要把key加进去</span><br>    s=(BiTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BiTree));<br>        s-&gt;data=key;<br>        s-&gt;lchild=s-&gt;rchild=<span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span>(!p)<span class="hljs-comment">//看前面SearchBST</span><br>            *T=s;<span class="hljs-comment">//s为树的根结点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &lt; p-&gt;data)<br>            p-&gt;lchild=s;<br>        <span class="hljs-keyword">else</span><br>            p-&gt;rchild=s;<br>        <span class="hljs-keyword">return</span> TRUE;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> FALSE;<span class="hljs-comment">//树中已有关键字相同元素</span><br>&#125;<br></code></pre></td></tr></table></figure><p>5.构建二叉排序树</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i;<br><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">62</span>,<span class="hljs-number">88</span>,<span class="hljs-number">58</span>,<span class="hljs-number">47</span>,<span class="hljs-number">35</span>,<span class="hljs-number">73</span>,<span class="hljs-number">51</span>,<span class="hljs-number">99</span>,<span class="hljs-number">37</span>,<span class="hljs-number">93</span>&#125;;<br>BiTree T=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//根是空</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>    InsertBST(&amp;T,a[i]);<br>&#125;<br></code></pre></td></tr></table></figure><p>6.删除二叉树结点</p><p>​    1.用直接前去/直接后继来代替刚刚删除的结点，<strong>先替换，再删除</strong></p><p>​    2.算法代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//若二叉排序树中存在等于key的数据元素，将其删除，并返回true、</span><br><span class="hljs-comment">//其实就是相当于递归，不停的往左子树或者右子树找，直到找到等于key的关键字为止</span><br>Status <span class="hljs-title function_">DeleteBST</span><span class="hljs-params">(BiTree *T,<span class="hljs-type">int</span> key)</span>&#123;<br><span class="hljs-keyword">if</span>(!*T)<span class="hljs-comment">//不存在关键字等于key的元素</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span>(key==(*T)-&gt;data)<br>            <span class="hljs-keyword">return</span> Delete(T);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key&lt;(*T)-&gt;data)<br>            <span class="hljs-keyword">return</span> DeleteBST(&amp;(*T)-&gt;lchild,key);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> DeleteBST(&amp;(*T)-&gt;rchild,key);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>7.解释6中提到的Delete代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">Delete</span><span class="hljs-params">(BiTree *p)</span><span class="hljs-comment">//删除p结点，并重接它的左右子树</span><br>&#123;<br>    BiTree q,s;<br>    <span class="hljs-keyword">if</span>((*p)-&gt;rchild==<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//右子树空，只重接左子树</span><br>    q=*p;<span class="hljs-comment">//q保存p的内容</span><br>        *p=(*p)-&gt;lchild;<span class="hljs-comment">//p的位置用左孩子代替</span><br>        <span class="hljs-built_in">free</span>(q);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((*p)-&gt;rchild=<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//左子树空，只需要重接右子树</span><br>    q=*p;<br>        *p=(*p)-&gt;rchild;<br>        <span class="hljs-built_in">free</span>(q);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//左右子树都不空</span><br>    q=*p;<br>        s=(*p)-&gt;rchild;<br>        <span class="hljs-keyword">while</span>(s-&gt;rchild)&#123;<br>            q=s;<br>            s=s-&gt;rchild;<span class="hljs-comment">//向右到尽头，找到待删除的结点的前驱</span><br>        &#125;<br>        *p-&gt;data=s-&gt;data;<span class="hljs-comment">//把s的值传到p的位置</span><br>        <span class="hljs-keyword">if</span>(q!=*p)<br>            q-&gt;rchild=s-&gt;lchild;<span class="hljs-comment">//重接q右子树</span><br>        <span class="hljs-keyword">else</span><br>            q-&gt;lchild=s-&gt;lchild;<span class="hljs-comment">//重接q左子树</span><br>        <span class="hljs-built_in">free</span>(q)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><h2 id="平衡二叉树的定义"><a href="#平衡二叉树的定义" class="headerlink" title="平衡二叉树的定义"></a>平衡二叉树的定义</h2><p>1.其每个结点的左子树和右子树高度至多等于1</p><p>2.将二叉树上的结点的左子树深度减去右子树深度的值称为平衡因子BF(Balance Factor)，平衡因子的是只可能是-1，0，1</p><p>3.最小不平衡子树：找到距离插入结点最近的，第一个不满足左子树深度减右子树深度小于等于1的</p><p>例子：</p><p><img src="/2022/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9F%A5%E6%89%BE/image-20220830153324088.png" alt="image-20220830153324088"></p><p><img src="/2022/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9F%A5%E6%89%BE/image-20220830153407404.png" alt="image-20220830153407404"></p><h2 id="平衡二叉树的存储结构"><a href="#平衡二叉树的存储结构" class="headerlink" title="平衡二叉树的存储结构"></a>平衡二叉树的存储结构</h2><p>用一个bf来存储平衡因子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//用二叉链表来定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span>&#123;</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-type">int</span> bf;<span class="hljs-comment">//平衡因子</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchild</span>,*<span class="hljs-title">rchild</span>;</span><span class="hljs-comment">//左右孩子结点</span><br>&#125;BiTNode,*BiTree;<br></code></pre></td></tr></table></figure><h2 id="右旋操作"><a href="#右旋操作" class="headerlink" title="右旋操作"></a>右旋操作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//以p为根的二叉排序树作右旋操作，作处理后p指向之前左子树的根节点</span><br><span class="hljs-type">void</span> R-Rotate(BiTree *P)&#123;<br>    BiTree L;<br>    L=(*P)-&gt;lchild;<span class="hljs-comment">//L是左子树的根节点，p是根节点</span><br>    (*P)-&gt;lchild=L-&gt;rchild;<span class="hljs-comment">//p的左孩子等于p左结点的右孩子</span><br>    L-&gt;rchild=(*P);<span class="hljs-comment">//画图可知</span><br>    *P=L;<span class="hljs-comment">//p指向根节点，即L</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="左旋操作"><a href="#左旋操作" class="headerlink" title="左旋操作"></a>左旋操作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">L_Rotate</span><span class="hljs-params">(BiTree *p)</span>&#123;<br>    BiTree R;<br>    R=(*p)-&gt;rchild;<br>    (*p)-&gt;rchild=R-&gt;lchild;<br>    R-&gt;lchild=*p;<br>    *p=R;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="左平衡旋转处理"><a href="#左平衡旋转处理" class="headerlink" title="左平衡旋转处理"></a>左平衡旋转处理</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LH +1<span class="hljs-comment">//左高</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RH -1<span class="hljs-comment">//右高</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EH 0<span class="hljs-comment">//等高</span></span><br><span class="hljs-comment">//以指针T所指结点为根的二叉树作左平衡旋转处理</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">LeftBalance</span><span class="hljs-params">(BiTree *T)</span>&#123;<br>    BiTree L,Lr;<br>    L=(*T)-&gt;lchild;<span class="hljs-comment">//L指向根节点的左子树结点</span><br>    <span class="hljs-keyword">switch</span>(L-&gt;bf)&#123;<span class="hljs-comment">//检查左子树的平衡度</span><br>    <span class="hljs-keyword">case</span> LH;<span class="hljs-comment">//在左孩子的左子树上，要右旋</span><br>            (*T)-&gt;bf=L-&gt;bf=EH;<span class="hljs-comment">//先定义为等高，避免后面误判</span><br>            R_Rotate(T);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> RH:<span class="hljs-comment">//新结点在左孩子的右子树上，要双旋</span><br>            Lr=L-&gt;rchild;<span class="hljs-comment">//r指向L的右子树根</span><br>            <span class="hljs-keyword">switch</span>(Lr-&gt;bf)&#123;<br>            <span class="hljs-keyword">case</span> LH;<br>                    (*T)-&gt;bf=RH;<span class="hljs-comment">//T右高</span><br>                    L-&gt;bf=EH;<span class="hljs-comment">//L等高</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> EH:<br>                    (*T)-&gt;bf=L-&gt;bf=EH;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> RH:<br>                    (*T)-&gt;bf=EH;<br>                    L-&gt;bf=LH;<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>            Lr-&gt;bf=EH;<br>            L_Rotate(&amp;(*T)-&gt;lchild);<br>            R_Rotate(T);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//如果不存在和e有相同关键字的结点则插入，布尔变量taller反映树长高与否</span><br>Status <span class="hljs-title function_">InsertAVL</span><span class="hljs-params">(BiTree *T,<span class="hljs-type">int</span> e,Status *taller)</span>&#123;<br>    <span class="hljs-keyword">if</span>(!*T)&#123;<span class="hljs-comment">//插入新节点，使树长高，taller=true</span><br>    *T=(BiTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BiTNode));<br>        (*T)-&gt;data=e;<span class="hljs-comment">//插入e到T处</span><br>        (*T)-&gt;lchild=(*T)-&gt;rchild=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//左右都设为空</span><br>        (*T)-&gt;bf=EH;<br>        *taller=TRUE;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(e==(*T))&#123;<span class="hljs-comment">//已存在和e相同的结点，不需插入</span><br>            *taller=FALSE;<br>            <span class="hljs-keyword">return</span> FALSE;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(e&lt;(*T)-&gt;data)&#123;<span class="hljs-comment">//e小于根节点的值，于是在T的左边找</span><br>        <span class="hljs-keyword">if</span>(!InsertAVL(&amp;(*T)-&gt;lchild,e,taller))<span class="hljs-comment">//没插入</span><br>                <span class="hljs-keyword">return</span> FALSE;<br>            <span class="hljs-keyword">if</span>(*taller)&#123;<span class="hljs-comment">//长高了说明插入了左子树中</span><br>            <span class="hljs-keyword">switch</span>((*T)-&gt;bf)&#123;<span class="hljs-comment">//检查T的平衡度</span><br>                    <span class="hljs-keyword">case</span> LH:<span class="hljs-comment">//左子树比右子树高，需要左平衡</span><br>                        LeftBalance(T);<br>                        *taller=FALSE;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> EH:<span class="hljs-comment">//原来等高，现在左子树高</span><br>                        (*T)-&gt;bf=LH;<br>                        *taller=TRUE;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> RH:<span class="hljs-comment">//原来右子树高，现在等高</span><br>                        (*T)-&gt;bf=EH;<br>                        *taller=FALSE;<br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//在T的右子树继续查找</span><br>        <span class="hljs-keyword">if</span>(!InsertAVL(&amp;(*T)-&gt;rchild,e,taller))<span class="hljs-comment">//未插入</span><br>                <span class="hljs-keyword">return</span> FALSE;<br>            <span class="hljs-keyword">if</span>(*taller)&#123;<span class="hljs-comment">//已插入到T的右子树且右子树长高</span><br>            <span class="hljs-keyword">switch</span>((*T)-&gt;bf)&#123;<br>                    <span class="hljs-keyword">case</span> LH:<span class="hljs-comment">//原来左边高，现在等高</span><br>                (*T)-&gt;bf=EH;<br>                *taller=FALSE;<br>                <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> EH:<span class="hljs-comment">//原等高，现右高</span><br>                        (*T)-&gt;bf=RH;<br>                        *taller=TRUE;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> RH:<br>                        RightBalance(T);<br>                        *taller=FALSE;<br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="生成树代码"><a href="#生成树代码" class="headerlink" title="生成树代码"></a>生成树代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i;<br><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>&#125;;<br>BiTree T=<span class="hljs-literal">NULL</span>;<br>Status taller;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>    InsertAVL(&amp;T,a[i],&amp;taller);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="多路查找树（B树）"><a href="#多路查找树（B树）" class="headerlink" title="多路查找树（B树）"></a>多路查找树（B树）</h1><p>每个结点的孩子树可以多于两个，且每个结点可以存储多个元素，有四种特殊形式：2-3树，2-3-4树，B树，B+树</p><h2 id="2-3树：DH-345"><a href="#2-3树：DH-345" class="headerlink" title="2-3树：DH-345"></a>2-3树：DH-345</h2><p>1.其中每个结点都具有两个孩子，或者三个孩子</p><p>2.一个2结点包含一个元素和两个孩子（或者无孩子）</p><p>   一个3结点包含一小一大两个元素和三个孩子（或无孩子）</p><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>1.B树是一种平衡的多路查找树</p><p>2.结点最大的孩子树称为B树的阶（order），2-3是3阶B树，2-3-4是4阶B树，一个m阶B树应该具备以下条件：</p><p>​    a.若根节点不是叶节点，则其至少有2棵子树</p><p>​    b.每一个非根节点（叶子结点）都有k-1个元素和k个孩子，m/2&lt;=k&lt;=m</p><p>​    c.所有叶子结点都位于同一层</p><p>​    d.包含下列信息：n A0 k0 A1 k1 ……  An Kn</p><p>在n个关键字（k0..kn）的B树上查找时从跟到关键字结点不超过log(m/2)(n+3/2)，其中m/2向上取整。</p><h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><h2 id="散列表查找（哈希表）"><a href="#散列表查找（哈希表）" class="headerlink" title="散列表查找（哈希表）"></a>散列表查找（哈希表）</h2><p>1.前面讲过的LOC（ai）=LOC（a1）+（i-1）* c</p><p>​    第一个内存的存储位置加上i-1个位置之后的位置，最后得到的第i个位置的地址</p><p>2.散列技术：在存储位置和它的关键字之间建立关系f，使得每个关键字key对应一个存储位置f（key）</p><p>3.我们把f称为哈希Hash函数</p><p>4.若把记录存储在一块连续的存储空间红，那么这空间成为哈希表（散列表）</p><p>5.散列技术既是一种存储方法，亦是一种查找方法</p><p>6.散列（哈希适合查找已有给定值的记录）</p><p>7.若出现：key1不等于key2，但f(key1)=f(key2)的情况，我们称之为冲突Collision，并把key1和key2称为这个散列函数的同义词。</p><h2 id="散列函数的构造"><a href="#散列函数的构造" class="headerlink" title="散列函数的构造"></a>散列函数的构造</h2><p>1.直接定址法：可以去关键字的某个线性函数值为散列地址</p><p>f(key)=a*key+b(a,b为常数)</p><p>2.数字分析法</p><p>使用一部分的挂念子来计算散列存储的位置，用到了<strong>抽取</strong></p><p>3.平方取中法：</p><p>​    关键字为1234，它的平方时1522756，抽取其中的三位是227，把227作为存储地址即可</p><p>4.折叠法：</p><p>​    把关键字割成相等的及部分（最后一部分可以短一点）然后将他们叠加求和</p><p>​    如：124617896，分成3部分：124，617，896，把它们相加等于1637，所以地址为1637</p><p>5.保留余数法</p><p>​    a.对于散列表长m的散列公式为f(key)=key mod p(p&lt;=m)</p><p>​    b.可以直接取模，也可以折叠，平方取中后取模</p><p>​    c.对于p的选取要求较高，p的选取不好，会产生同义词</p><p>​    d.专家建议：若散列长m，通常选p值接近m，如p=12，m取11</p><p>6.f(key)=random(key)</p><p>​    使用不同散列函数的影响因素：</p><p>​    a.计算散列地址所需的时间</p><p>​    b.关键字的长度</p><p>​    c.散列表的大小</p><p>​    d.关键字的分布情况</p><p>​    f.记录查找的频率</p><h2 id="处理散列冲突的方法"><a href="#处理散列冲突的方法" class="headerlink" title="处理散列冲突的方法"></a>处理散列冲突的方法</h2><p>1.开放定址法</p><p>​    a.一旦发生了冲突，就去求下一个空的散列地址</p><p>​    b.fi(key)=(f(key)+di) MOD m(di=1,2,3,…,m-1)</p><p>​    例：表长为12，关键字集合为{12,67,56,16,25,37,22,29,15,47,48,34},用散列函数f(key)=key mod 12</p><p>​    c.重点就在+di的部分</p><p>​    d.若48与37这种远不是同义词而争夺一个地址的情况，称为“堆积”</p><p>​    e.二次探测法：fi(key)=(f(key)+di) MOD m(di=1^2,(-1)^2,2^2,(-2)^2,…,q^2,(-q)^2)</p><p>​    f.随机探测法：fi(key)=(f(key)+di) MOD m(di是一个随机数列)</p><p>2.再散列函数法</p><p>​    事先多准备一个散列函数 fi(key) = RHi(key)(i=1,2,…,n)</p><p>​    这里RHi就是不同的散列函数</p><p>3.链地址法</p><p>​    将所有的同义词记录再一个单链表中（mod值都相同）</p><p>4.公共溢出区法</p><p>​    把所有冲突的全部抓走放进公共的溢出区</p><h2 id="散列表查找算法实现"><a href="#散列表查找算法实现" class="headerlink" title="散列表查找算法实现"></a>散列表查找算法实现</h2><p>1.首先要定义散列表结构以及一些相关的常数，结构定义（散列表）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> HASHSIZE 12</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULLKEY -32768</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">int</span> *elem;<span class="hljs-comment">//数据存储基址，动态分配数组</span><br>    <span class="hljs-type">int</span> count;<span class="hljs-comment">//当前数据元素</span><br>&#125;HashTable;<br><span class="hljs-type">int</span> m=<span class="hljs-number">0</span>;<span class="hljs-comment">//散列表表长，全局变量</span><br></code></pre></td></tr></table></figure><p>2.散列表的初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">InitHashTable</span><span class="hljs-params">(HashTable *H)</span>&#123;<span class="hljs-comment">//初始化</span><br><span class="hljs-type">int</span> i;<br>m = HashSIZE;<span class="hljs-comment">//先定义m</span><br>    H-&gt;count=m;<span class="hljs-comment">//把H的数量定义为最大</span><br>    H-&gt;elem=(<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(m*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>        H-&gt;elem[i]=NULLKEY;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.散列函数定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Hash</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span>&#123;<br><span class="hljs-keyword">return</span> key%m;<span class="hljs-comment">//保留余数法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>4.对散列表进行插入操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InsertHash</span><span class="hljs-params">(HashTable *H,<span class="hljs-type">int</span> key)</span>&#123;<br><span class="hljs-type">int</span> addr=Hash(key);<span class="hljs-comment">//addr是地址</span><br><span class="hljs-keyword">while</span>(H-&gt;elem[addr]!=NULLKEY)<br>addr=(addr+<span class="hljs-number">1</span>)%m;<span class="hljs-comment">//探测</span><br>H-&gt;elem[addr]=key;<span class="hljs-comment">//插入空位</span><br>&#125;<br></code></pre></td></tr></table></figure><p>5.散列表查找关键字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">Search</span><span class="hljs-params">(HashTable H;<span class="hljs-type">int</span> key;<span class="hljs-type">int</span> *addr)</span>&#123;<br>    *addr=Hash(key);<br>    <span class="hljs-keyword">while</span>(H.elem[*addr]!=key)&#123;<span class="hljs-comment">//冲突</span><br>        *addr=(*addr+<span class="hljs-number">1</span>)%m;<span class="hljs-comment">//往下一个</span><br>        <span class="hljs-keyword">if</span>(H.elem[*addr]==NULLKEY||*addr==Hash(key))<span class="hljs-comment">//回到原点</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络--计算机网络概述</title>
    <link href="/2022/08/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
    <url>/2022/08/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="计算机网络的基本概念"><a href="#计算机网络的基本概念" class="headerlink" title="计算机网络的基本概念"></a>计算机网络的基本概念</h2><span id="more"></span><h2 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h2><p>1.计算机网络是互联的，自治的计算机系统的集合</p><p>2.广义观点：能实现远程信息处理的系统或者能进一步达到资源共享的系统</p><p>3.资源共享观点： a.目的–资源共享</p><p>​                                 b.组成单元–分布在不同地理位置的堕胎独立的自治计算机</p><p>​                                 c.网络中的计算机必须遵循同意的规则–网络协议</p><h2 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h2><p>1.组成部分：硬件，软件，协议</p><p>2.工作方式：边缘部分：由所有主机构成</p><p>​                        核心部分：有大量的网络和路由器组成</p><p>3.功能组成：通信子网（设备+网络协议）+资源子网（硬件资源，软件资源）</p><p><strong>通信子网：传输介质，通信设备，网络协议</strong></p><p><strong>资源子网：主要是计算机中的共享软件和硬件（缺一不可）</strong></p><h2 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h2><h3 id="按分布范围分类"><a href="#按分布范围分类" class="headerlink" title="按分布范围分类"></a>按分布范围分类</h3><p>1.广域网（WAN）：长距离通信（最长距离），远程网，因特网的核心，使用交换技术</p><p>2.地域网（MAN）：覆盖街区以及城市，使用以太网技术</p><p>3.局域网（LAN）：用广播技术，覆盖范围小</p><p>4.个人区域网（PAN）：用自己的平板，手机的网络，也称为无线个人区域网（WPAN）</p><p><strong>域网的划分条件：作用范围的不同</strong></p><p><strong>广域网使用的是交换技术（点对点技术），局域网使用的是广播技术。也即域网之间的协议不同</strong></p><p><strong>若中央处理器之间的距离特别近，则一般称为多处理器系统，而不称为计算机网络</strong></p><h3 id="按传输技术分类"><a href="#按传输技术分类" class="headerlink" title="按传输技术分类"></a>按传输技术分类</h3><h4 id="广播式技术（一对多）"><a href="#广播式技术（一对多）" class="headerlink" title="广播式技术（一对多）"></a>广播式技术（一对多）</h4><p>所有电脑共享一个公共通道，当一台计算机共享信息时候，其他所有的计算机都可以收到信息</p><h4 id="点对点技术、交换技术（一对一）"><a href="#点对点技术、交换技术（一对一）" class="headerlink" title="点对点技术、交换技术（一对一）"></a>点对点技术、交换技术（一对一）</h4><p>使用中间商来传递信息</p><h3 id="按拓扑结构分类"><a href="#按拓扑结构分类" class="headerlink" title="按拓扑结构分类"></a>按拓扑结构分类</h3><p>1.网络拓扑结构是指网中结点（路由器，主机等）与通信线路（网线）之间的几何关系（总线形，环形）表示网络结构，主要指通信子网的拓扑结构</p><p><strong>总线形，星形，环形网络多用于局域网，网状网络多用于广域网</strong></p><h4 id="总线形网络"><a href="#总线形网络" class="headerlink" title="总线形网络"></a><strong>总线形网络</strong></h4><p><strong>用单根传输线把计算机连接起来，优点是建网容易，增减节点方便，节省线路，缺点是重负载时通信效率不高，总线任意一处对故障敏感</strong></p><h4 id="星形网络"><a href="#星形网络" class="headerlink" title="星形网络"></a>星形网络</h4><p>每个终端结点都有单独的线路与中央设备相连接，中央设备早期时计算机，现在一般是交换机或者路由器</p><h4 id="环形网络"><a href="#环形网络" class="headerlink" title="环形网络"></a>环形网络</h4><p>所有计算机接口连接成为一个环，环可以是单环也可以是双环，环中信号是单向传输的</p><h4 id="网状网络"><a href="#网状网络" class="headerlink" title="网状网络"></a>网状网络</h4><p>每个结点至少有两条路径与其他结点相连，多用在广域网中，有规则型和非规则型两种，其优点是可靠性高，缺点是控制复杂，线路成本太高</p><h3 id="按使用者分类"><a href="#按使用者分类" class="headerlink" title="按使用者分类"></a>按使用者分类</h3><p><strong>公用网</strong>（Public Network）：指电信公司创建的大型网络，“公用”的意思是指所有的人只要愿意交钱给电信就可以用他们的网络。</p><p><strong>专用网</strong>（Private Network）:指某个部门为了满足本单位的特殊业务而建造的网络，这种网络不向本单位以外的人提供。</p><h3 id="按交换技术分类"><a href="#按交换技术分类" class="headerlink" title="按交换技术分类"></a>按交换技术分类</h3><p>1.电路交换网络：在源结点和目的结点之间建立一条专用的通路用于传输数据，包括建立连接，传输数据，断开连接三个阶段。</p><p>2.报文交换网络：用户数据加上源地址，目的地址，校验码等辅助信息，然后包装成报文，整个报文传输到相邻结点，全部存储后转发到下一个相邻结点，直至到最后一个结点为止。每一个结点都可以自己选择到最终结点的路径。<strong>优点</strong>：可以实现不同链路之间不同数据传输速率的转换，可以实现格式转换，可以实现一对多，多对一的访问。缺点：增大了资源开销，增加了缓冲时延。</p><p>3.分组交换网络：把数据分成较短固定长度的数据块，每个数据块中加上目的地址，源地址等辅助信息组成包，以存储，转发方式传输。不仅具有报文交换网络的优点，还有<strong>缓冲易于管理，包的平均时延更小，网络占用的平均缓冲区更少，更易于标准化</strong></p><h3 id="按传输介质分类"><a href="#按传输介质分类" class="headerlink" title="按传输介质分类"></a>按传输介质分类</h3><p>可以分为有线网络和无线网络两大类</p><h2 id="计算机网络的标准化工作"><a href="#计算机网络的标准化工作" class="headerlink" title="计算机网络的标准化工作"></a>计算机网络的标准化工作</h2><p>因特网的所有标准都要以RFC（Request for Comments）的形式在因特网上发布，但并非每个RFC都是因特网标准，RFC要上升为因特网标准需要经过以下四个步骤：<br>1.因特网草案（Internet Draft）这个阶段还不是RFC文档。</p><p>2.建议标准（Proposed Standard）这个阶段就开始成为RFC文档</p><p>3.草案标准（Draft Standard）</p><p>4.因特网标准（Internet Standard）</p><p><img src="/2022/08/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6LaF57qn5aSn6LaF6LaK,size_15,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>制定网络标准化的组织主要有：</p><p><strong>国际标准化组织</strong>（<strong>ISO</strong>）</p><p><strong>国际电信联盟</strong>（<strong>ITU</strong>）</p><p><strong>国际电器电子工程师协会</strong>（IEEE）</p><h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h2><h3 id="带宽（Bandwidth）"><a href="#带宽（Bandwidth）" class="headerlink" title="带宽（Bandwidth）"></a>带宽（Bandwidth）</h3><p>单位是赫兹HZ，表示网络的通信线路所能传送数据的能力</p><h3 id="时延（Delay）"><a href="#时延（Delay）" class="headerlink" title="时延（Delay）"></a>时延（Delay）</h3><p>指数据从网络的一端传送到另一端所需要的总时间，由四部分构成：<strong>发送时延</strong>，<strong>传播时延</strong>，<strong>处理时延</strong>，<strong>排队时延</strong>。</p><h4 id="发送时延"><a href="#发送时延" class="headerlink" title="发送时延"></a>发送时延</h4><p>指结点将分组中的所有bit发送完的时间，即从第一个bit发出去开始计算时间，到最后一个bit发送完毕所经历的时间。</p><p><strong>发送时延=分组长度/信道宽度</strong></p><h4 id="传播时延"><a href="#传播时延" class="headerlink" title="传播时延"></a>传播时延</h4><p>bit在传播的过程中需要花费时间，从一个结点到另一个结点所需要花费的时间称为传播时延</p><p><strong>传播时延=信道长度/电磁波在信道上的传播速率</strong></p><h4 id="处理时延"><a href="#处理时延" class="headerlink" title="处理时延"></a>处理时延</h4><p>数据在交换结点以及处理信息的过程中所花费的时间。</p><h4 id="排队时延"><a href="#排队时延" class="headerlink" title="排队时延"></a>排队时延</h4><p>在路由器的输入端口需要排队等待处理，在输出队列中需要排队等到转发。</p><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><p>指发送端发送的第一个结点准备到达终点时，发送端已经发送了多少个bit的信息。</p><p><strong>时延带宽积=时延*带宽</strong></p><h3 id="往返带宽"><a href="#往返带宽" class="headerlink" title="往返带宽"></a>往返带宽</h3><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>1.1986年6月：ARPAnet（阿帕网）是世界上最早的计算机网络</p><p>2.计算机网络包含三个关键点：自治计算机，互联，集合体</p><p>3.计算机网络最基本，最重要的功能：数据通信</p><p>4.计算机网络可以不存在数据库系统</p><p>5.广域网和局域网之间是由<strong>路由器</strong>相连的</p><p>6.计算机网络的拓扑结构取决于通信子网</p><p>7.广域网使用网状结构</p><p>8.分组交换的缺点是开销高昂</p><p>9.带宽=分组大小/延时；B/miu s=MB/s=8Mb/s</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构--图论</title>
    <link href="/2022/08/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE%E8%AE%BA/"/>
    <url>/2022/08/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="图的基本概念和知识点"><a href="#图的基本概念和知识点" class="headerlink" title="图的基本概念和知识点"></a>图的基本概念和知识点</h2><span id="more"></span><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>1.定义：Graph是由顶点的有穷非空集合和顶点之间的边构成，表示为G（V，E），G表示一个图，V是图G中顶点的集合，E也是G中边的集合。</p><p>2.线性表中的元素；树中结点；图中结点</p><p>3.不允许图中不存在顶点，即G（V，E）中的V是有穷非空的</p><p>4.图中任意两个顶点都可能有关系，顶点之间的逻辑关系用边来表示</p><!--more--><h2 id="各种图的定义"><a href="#各种图的定义" class="headerlink" title="各种图的定义"></a>各种图的定义</h2><p>1.无向边，无向图：V0和V1两个顶点之间没有方向，称V0和V1为无向边，可表示为（V0，V1），也可以表示为(V1,V0)，如果途中所有的边都是无向边，那么称这个图为无向图。</p><p>2.有向边：A，B有方向（A指向B，A-&gt;B），那么用&lt; A -&gt; B &gt;来表示，有向边A，B，A是弧尾，B是弧头</p><p>3.简单图：不出现顶点到其他自身的边（A指向A自己），且同一条边不从夫出现时（A指向B，B也指向A），称图为简单图。</p><p>4.在无向图中，如果任意两个顶点之间都存在边，则称之为无向完全图，n个顶点的无向完全图有n*(n-1)/2条边</p><p>5.有向图中，如果然一两个顶点之间都存在方向相反的两条弧，称之为有向完全图，n个顶点的有向完全图有n*（n-1）条边。</p><p>6.设图G（V，E）和图G’(V’,E’),若V‘属于V，E’属于E，称G‘是G的子图</p><p>7.对于无向图，边数是顶点度数和的一半</p><p>8.对于有向图，顶点的度为出度和入度之和，degree = indegree + outdegree ,TD(V)=ID(V)+OD(V)</p><p>   有向图中所有出度==所有入度和</p><p>9.路径的长度是边的数目</p><p>10.第一个结点和最后一个结点相同的路径称为回路或者环。</p><p>11.连通图：任意两个顶点之间都是联通的有路径的，称之为连通图。</p><p>12.联通分量：要子图，子图要连通，连通子图含有极大顶点数。</p><p>13.连通分量：在连通图中分离出来的</p><p>14.强连通图：对于vi到vj和vj到vi都存在路径，那么G是强连通图</p><p>15.强连通图概念与连通子图概念一致</p><p>16.若有一个图有n个顶点和n-1条边，那么是非连通图，如果超过n-1条边，则必定构成环。</p><p>17.有向图有一个顶点入度0，其余顶点入度1，则是有向权图</p><h2 id="图的结构定义"><a href="#图的结构定义" class="headerlink" title="图的结构定义"></a>图的结构定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">ADT <span class="hljs-title function_">Graph</span><span class="hljs-params">(图)</span><br>Data<br>    顶点的有穷非空集合和边的集合<br>Operation<br>    <span class="hljs-title function_">CreateGraph</span><span class="hljs-params">(*G,V,VR)</span>:按顶点集V和边弧集VR，构造图G<br>    <span class="hljs-title function_">DestoryGraph</span><span class="hljs-params">(*G)</span>:若G存在将其销毁<br>    <span class="hljs-title function_">LocateVex</span><span class="hljs-params">(G,u)</span>:若G中存在顶点u，返回u的位置<br>    <span class="hljs-title function_">GetVex</span><span class="hljs-params">(G,V)</span>:返回G中V的值<br>    <span class="hljs-title function_">PutVex</span><span class="hljs-params">(G,v,value)</span>:将G中v结点赋value值<br>    <span class="hljs-title function_">FirstAdjust</span><span class="hljs-params">(G,*v)</span>:返回顶点v的一个邻接矩阵，若无返回则<span class="hljs-literal">NULL</span><br>    <span class="hljs-title function_">NextAdjust</span><span class="hljs-params">(G,v,*w)</span>:返回顶点v相对于顶点w的下一个邻接顶点，若w是v的最后一个元素，返回null<br>    <span class="hljs-title function_">InsertVex</span><span class="hljs-params">(*G,v)</span>:在G中插入新顶点v<br>    <span class="hljs-title function_">DeleteArc</span><span class="hljs-params">(*G,v,w)</span>:在G中删除弧&lt;v,w&gt;,若无向图，同时删除&lt;v,w&gt;和&lt;w,v&gt;<br>    <span class="hljs-title function_">DFSTraverse</span><span class="hljs-params">(G)</span>:对G进行深度优先遍历，每个顶点进行调用<br>    <span class="hljs-title function_">HFSTraverse</span><span class="hljs-params">(G)</span>:对G进行广度优先遍历，每个顶点进行调用<br>    endADT<br></code></pre></td></tr></table></figure><h2 id="五种图的不同存储结构"><a href="#五种图的不同存储结构" class="headerlink" title="五种图的不同存储结构"></a>五种图的不同存储结构</h2><p>一、邻接矩阵<br>1.用两个数组来表示图，一个一维数组存储图中的顶点信息，一个二维数组（邻接矩阵）存储边/弧信息</p><p>2.设图G有n个顶点矩阵则是n*n的方阵</p><p>3.arc[i] [j] = 1,若(vi,vj)属于E或者&lt;vi,vj&gt;属于E。</p><p>   arc[i] [j] = 0，else</p><p>4.对称矩阵：以左上到右下的对角线为轴，右上和左下的对应元素是相等的，即aij=aji</p><p>5.求某顶点的度，看他在矩阵中对应行列的数字之和。</p><p><strong>对于有向图</strong></p><p>1.v0到v1有弧：a[v0] [v1]=1,v1到v0没有弧，a[v1] [v0]=0</p><p>2.行数为出度，列数为入度</p><p>3.arc[i] [j] = wij,若（vi,vj）属于E或&lt;vi,vj&gt;属于E</p><p>   arc[i] [j] = 0，若i=j</p><p>   arc[i] [j] = 无穷，else</p><h2 id="邻接矩阵的结构定义"><a href="#邻接矩阵的结构定义" class="headerlink" title="邻接矩阵的结构定义"></a>邻接矩阵的结构定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> VertexType;<span class="hljs-comment">//顶点类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> EdgeType;<span class="hljs-comment">//边类型</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXVEX 100 <span class="hljs-comment">//最大顶点数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INFINITY 65535 <span class="hljs-comment">//定义无穷</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    VertesType vexs[MAXSIZE];<span class="hljs-comment">//顶点表</span><br>    EdgeType arc[MAXVEX][MAXVEX];<span class="hljs-comment">//矩阵</span><br>    <span class="hljs-type">int</span> numVertexes,numEdges;<span class="hljs-comment">//顶点数和边数</span><br>&#125;MGraph;<br></code></pre></td></tr></table></figure><h2 id="无向网图建立"><a href="#无向网图建立" class="headerlink" title="无向网图建立"></a>无向网图建立</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">CreateMGraoh</span><span class="hljs-params">(MGraph *G)</span>&#123;<br>    <span class="hljs-type">int</span> i,j,k,w;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入顶点和边数：\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d,%d&quot;</span>,&amp;G-&gt;numVertexes,&amp;G-&gt;numEdges);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;G-&gt;numVertexes;i++)<br>        <span class="hljs-built_in">scanf</span>(&amp;G-&gt;vexs[i]);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;G-&gt;numVertexes;i++)<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;G-&gt;numVertexes;j++)<br>            G-&gt;arc[i][j]=INFINITY;<span class="hljs-comment">//矩阵中所有的元素都为inf</span><br>    <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;numEdges;k++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入边：(vi,vj)的下标，以及权wi&quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d,%d,%d&quot;</span>,&amp;i,&amp;j,&amp;w);<br>        G-&gt;arc[i][j] = w;<br>        G-&gt;arc[j][i] = G-&gt;arc[i][j]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度O(n^2+n+e) = O(n^2)</p><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>将顶点先用数组表示，其中存在一个指针，指向这个顶点有连接的其余顶点</p><p>对于第一个定点有data | firstedge，data存放数据，firstedge存放第一个邻接矩阵的下标</p><p>对于后面的顶点有 adjvex | next</p><h2 id="有向图的逆邻接表"><a href="#有向图的逆邻接表" class="headerlink" title="有向图的逆邻接表"></a>有向图的逆邻接表</h2><p>把原先邻接表中的弧全部倒置，如：v1-&gt;v2变为v2-&gt;v1</p><p>注意把权值加在adjvex和next的中间</p><h2 id="结点定义代码"><a href="#结点定义代码" class="headerlink" title="结点定义代码"></a>结点定义代码</h2><h3 id="定义边表结点"><a href="#定义边表结点" class="headerlink" title="定义边表结点"></a>定义边表结点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> VertexType;<span class="hljs-comment">//顶点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> EdgeType;<span class="hljs-comment">//边</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EdgeNode</span>&#123;</span><span class="hljs-comment">//结点，声名结点（边表）</span><br><span class="hljs-type">int</span> adjvex;<br>    EdgeType weight;<span class="hljs-comment">//权值</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EdgeNode</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//下一个指针</span><br>&#125;EdgeNode;<br></code></pre></td></tr></table></figure><h3 id="定义定点表结点"><a href="#定义定点表结点" class="headerlink" title="定义定点表结点"></a>定义定点表结点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VertexNode</span>&#123;</span><span class="hljs-comment">//顶点表结点</span><br>    VertexType data;<span class="hljs-comment">//顶点域</span><br>    EdgeNode *firstedge;<span class="hljs-comment">//头结点</span><br>&#125;VertexNode,AdjList[MAXVEX];<br></code></pre></td></tr></table></figure><h3 id="整体定义"><a href="#整体定义" class="headerlink" title="整体定义"></a>整体定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>AdjList adjList;<br><span class="hljs-type">int</span> numVertexes,numEdges;<span class="hljs-comment">//顶点数和边数</span><br>&#125;GraphAdjList;<br></code></pre></td></tr></table></figure><h2 id="无向图邻接表的创建"><a href="#无向图邻接表的创建" class="headerlink" title="无向图邻接表的创建"></a>无向图邻接表的创建</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">CreateLGraph</span><span class="hljs-params">(GraphAdjList *G)</span>&#123;<br><span class="hljs-type">int</span> i,j,k;<br>    EdgeNode *e;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入顶点数和边数：\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d,%d&quot;</span>,&amp;G-&gt;numVertexes,&amp;G-&gt;numEdges);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;G-&gt;numVertexes;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(&amp;G-&gt;adjList[i].data);<br>        G-&gt;adjList[i].firstedge=<span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//建立边表</span><br><span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;G-&gt;numEdges;k++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入边(vi,vj)上的定点序号:\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d,%d&quot;</span>,&amp;i,&amp;j);<br>    e = (EdgeNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(EdgeNode));<span class="hljs-comment">//分配空间</span><br>    e-&gt;adjvex=j;<span class="hljs-comment">//邻接序号为j</span><br>    e-&gt;next=G-&gt;adjList[j].firstEdge;<span class="hljs-comment">//就是在G-&gt;adjList[j]之间插入e</span><br>    G-&gt;adjList[j].firstedge=e;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h2><p>1.邻接表解决了出度的问题，逆邻接表解决了入度的问题，有一种链表可以将出度和入度结合起来，即十字链表。</p><p>2.顶点表结构如下</p><p>​    data firstin firstout</p><p>​    firstin：入边表头指针</p><p>​    firstout：出边表头指针</p><p>3.边表的结构如下</p><p>tailvex headvex headlink taillink</p><p>tailvex:弧七点在顶点表的下标</p><p>headvex：弧终点在顶点表的下标</p><p>headlink：入边表指针与指向终点等于下一条边</p><p>taillink：出边表指针与指向起点等于下一条边</p><h2 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h2><p>1.结构</p><p>ivex ilink jvex jlink</p><p>ivex和jvex时某边所依附的两个顶点在顶点表中的位置</p><p>ilink是ivex的下一条边，jlink是jvex的下一条边</p><p>2.边集数组</p><p>有两个数组组成，一个是顶点集合数组，一个是存储边的信息的数组，边的信息由三部分组成：</p><p><strong>起点下标（begin）终点下标（end）权值（weight）组成，详见后面的kruskal算法</strong></p><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><h2 id="深度优先遍历（Depth-First-Search）"><a href="#深度优先遍历（Depth-First-Search）" class="headerlink" title="深度优先遍历（Depth First Search）"></a>深度优先遍历（Depth First Search）</h2><p>1.用邻接矩阵实现深度优先遍历算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Boolean;<br>Boolean visited[MAXSIZE];<br><span class="hljs-type">void</span> <span class="hljs-title function_">DFS</span><span class="hljs-params">(MGraph G,<span class="hljs-type">int</span> i)</span>&#123;<br>    <span class="hljs-type">int</span> j;<br>    visited[i]=TRUE;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&#x27;%c&#x27;</span>,G.vexs[i]);<br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>,j&lt;G-&gt;numVertexes;j++)<br>        <span class="hljs-keyword">if</span>(G.arc[i][j]==<span class="hljs-number">1</span>&amp;&amp;!visited[j])<br>            DFS(G,j);<br>&#125;<br></code></pre></td></tr></table></figure><p>2.邻接矩阵的深度优先遍历</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">DFSTraverse</span><span class="hljs-params">(MGraph G)</span>&#123;<br><span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;G.numVertexes;i++)<br>        visited[i]=<span class="hljs-literal">false</span>;<span class="hljs-comment">//全部设置为未访问状态</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;G.numvertexes;i++)<br>        <span class="hljs-keyword">if</span>(!visited[i])<br>            DFS(T,i)<br>&#125;<br></code></pre></td></tr></table></figure><p>3.邻接表深度优先遍历操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">DFS</span><span class="hljs-params">(GraphAdjList GL,<span class="hljs-type">int</span> i)</span>&#123;<br>EdgeNode *p;<br>    visited[i]=TRUE;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&#x27;%c&#x27;</span>,GL.adjList[i].data);<br>    p=GL-&gt;adjList[i].firstedge;<br>    <span class="hljs-keyword">while</span>(p)&#123;<br>        <span class="hljs-keyword">if</span>(!visited[p-&gt;adjList])<br>            DFS(GL,p-&gt;adjvex);<br>        p=p-&gt;next<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：</p><p>邻接矩阵：O（n^2）</p><p>邻接表：O（n）</p><h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">BFSTraverse</span><span class="hljs-params">(MGraph G)</span>&#123;<br><span class="hljs-type">int</span> i,j;<br>Queue Q;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;G.numVertexes;i++)<br>        visited[i]=<span class="hljs-literal">false</span>;<br>    InitQueue(&amp;Q);<span class="hljs-comment">//初始化Q队列</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;G.numVertexes;i++)<br>        <span class="hljs-keyword">if</span>(!visited[i])&#123;<span class="hljs-comment">//若是未被访问的</span><br>        visited[i]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,G.vex[i]);<span class="hljs-comment">//打印结点</span><br>            EnQueue(&amp;Q,i);<br>            <span class="hljs-keyword">while</span>(!QueueEmpty(Q))&#123;<span class="hljs-comment">//此时队列不为空</span><br>            DeQueue(&amp;Q,&amp;i);<span class="hljs-comment">//出队列，赋值给i</span><br>                <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>,j&lt;G.numVertexes;j++)&#123;<br>                    <span class="hljs-keyword">if</span>(G.arcs[i][j]==<span class="hljs-number">1</span> &amp;&amp; !visited[j])&#123;<br>                        visited[j]=TRUE;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,G.vex[j]);<br>                        EnQueue(&amp;Q,j);<span class="hljs-comment">//入列3 </span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><h2 id="Prim方法"><a href="#Prim方法" class="headerlink" title="Prim方法"></a>Prim方法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MiniSpanTree_Prim</span><span class="hljs-params">(MGraph G)</span>&#123;<br><span class="hljs-type">int</span> min,j,i,k;<br>    <span class="hljs-type">int</span> adjvex[MAXSIZE];<span class="hljs-comment">//保存顶点下标</span><br>    <span class="hljs-type">int</span> lowcost[MAXSIZE];<span class="hljs-comment">//保存顶点权值</span><br>    lowcost[<span class="hljs-number">0</span>];<span class="hljs-comment">//将0号元素加入生成树中</span><br>    adjvex[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-comment">//第1个结点的下标为0</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;G.numVertexes;i++)&#123;<br>lowcost[i]=G.arc[<span class="hljs-number">0</span>][i];<span class="hljs-comment">//把邻接矩阵第一行元素赋值给lowcost</span><br>        adjvex[i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//全为v0下标</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;G.numVertexes;i++)&#123;<br>min=IINNFINITY;<span class="hljs-comment">//最小权值设置为无穷</span><br>        j=<span class="hljs-number">1</span>,k=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(j&lt;G.numVertexes)&#123;<br><span class="hljs-keyword">if</span>(lowcost[j]!=<span class="hljs-number">0</span> &amp;&amp; lowcost[j]&lt;min)&#123;<br>                min = lowcost[j];<br>                k=j;<span class="hljs-comment">//k保存最小值的下标</span><br>            &#125;<br>            j++;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d,%d)&quot;</span>,adjvex[k],k);<br>        lowcost[k]=<span class="hljs-number">0</span>;<span class="hljs-comment">//k已经完成任务</span><br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;G.numVertexes;j++)&#123;<br><span class="hljs-keyword">if</span>(lowcost[j]!=<span class="hljs-number">0</span> &amp;&amp; G.arc[k][j]&lt;lowcost[j])&#123;<br>                lowcost[j]!=<span class="hljs-number">0</span> &amp;&amp; G.acr[k][j];<span class="hljs-comment">//最小值存入lowcost</span><br>                adjvex[j]=k;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Kruskal方法"><a href="#Kruskal方法" class="headerlink" title="Kruskal方法"></a>Kruskal方法</h2><p>1.定义边集数组Edge结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br><span class="hljs-type">int</span> begin;<br><span class="hljs-type">int</span> end;<br><span class="hljs-type">int</span> weight;<br>&#125;Edge;<br></code></pre></td></tr></table></figure><p>2.通过邻接矩阵建立最小生成树（MAXEDGE：边数最大值，MAXVEX：顶点数最大值）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MiniSpanTree_Kruskal</span><span class="hljs-params">(MGraph G)</span>&#123;<br>    <span class="hljs-type">int</span> i,n,m;<br>    Edge edge[MAXEDGE];<br>    <span class="hljs-type">int</span> parent[MAXVAX];<span class="hljs-comment">//判断与边路是否形成环路</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;G.numVertexes;i++)<br>        parent[i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//全部初始化</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;G.numedges;i++)&#123;<span class="hljs-comment">//循环每一条边</span><br>n=Find(parent,edges[i].begin);<br>        m=Find(parent,edges[i].end);<br>        <span class="hljs-keyword">if</span>(n!=m)&#123;<span class="hljs-comment">//若m与n不相等，则不存在环路</span><br>        parent[n]=m;<span class="hljs-comment">//把终点放进起点的parent数组中</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d,%d)%d&quot;</span>,edge[i].begin,edge[i].end,edge[i].weight)<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> *parent,<span class="hljs-type">int</span> f)</span>&#123;<br>    <span class="hljs-keyword">while</span>(parent[f]&gt;<span class="hljs-number">0</span>)<br>        f=parent[f];<br>    <span class="hljs-keyword">return</span> f;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><p><strong>求v0到其余顶点的最短路径P[v]和带权路径长度D[v]</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXVEX 9<span class="hljs-comment">//最多顶点数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INFINITY 65535</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Patharc[MAXVEX];<span class="hljs-comment">//最短路径下标</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ShortPathTable[MAXVEX];<span class="hljs-comment">//最短路径权值和</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ShortestPath_Dijkstra</span><span class="hljs-params">(MGraph G,<span class="hljs-type">int</span> v0,Patharc *p;ShortTable *D)</span>&#123;<br>    <span class="hljs-type">int</span> v,w,k,min ;<br>    <span class="hljs-type">int</span> final[MAXVEX];<span class="hljs-comment">//定义数组final表示从v0到vw的最短路径</span><br>    <span class="hljs-keyword">for</span>(v=<span class="hljs-number">0</span>;v&lt;G.numVertexes;v++)&#123;<br>        final[v]=<span class="hljs-number">0</span>;<span class="hljs-comment">//初始化路径为0</span><br>        (*D)[v]=G.arc[v0][v];<span class="hljs-comment">//与v0有连线的顶点加上权值</span><br>        (*p)[v]=<span class="hljs-number">0</span>;<span class="hljs-comment">//初始化路径数组为0</span><br>    &#125;<br>    (*D)[v0]=<span class="hljs-number">0</span>;<span class="hljs-comment">//v0至v0的路径为0</span><br>    final[v0]=<span class="hljs-number">1</span>;<span class="hljs-comment">//v0至v0不需要路径</span><br>    <span class="hljs-keyword">for</span>(v=<span class="hljs-number">1</span>;v&lt;G.numVertexes;v++)&#123;<br>min=INFINITY;<span class="hljs-comment">//已知距离v0最近的路径</span><br>        <span class="hljs-keyword">for</span>(w=<span class="hljs-number">0</span>;w&lt;G.numVErtexes;w++)&#123;<br>            <span class="hljs-keyword">if</span>(!final[w]&amp;&amp;(*D)[w]&lt;min)&#123;<br>k=w;<span class="hljs-comment">//把当前最短路径下标赋值给k</span><br>                min=(*D)[w];<span class="hljs-comment">//w离v0更近</span><br>            &#125;<br>        &#125;<br>        final[k]=<span class="hljs-number">1</span>;<span class="hljs-comment">//把k设为已经找到了最短路径</span><br>        <span class="hljs-keyword">for</span>(w=<span class="hljs-number">0</span>;w&lt;G.numVertexes;w++)<span class="hljs-comment">//修正</span><br>        &#123;<br><span class="hljs-keyword">if</span>(!final[w]&amp;&amp;(min+G.arc[k][w]&lt;(*D)[w]))&#123;<br>                (*D)[w]=min+G.[k][w];<br>                (*P)[w]=k;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h2><p>1.假设点v0和v1之间经过v2的权更短，那么有：D0[v0] [v1] = min{D-1[v0] [v2] + D-1[v2] [v1]}</p><p>2.Floyd算法代码(Pathmatirx和ShortPathTable都是二维数组)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Pathmatirx[MAXVEX][MAXVEX];<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> SHortPathTable[MAXVEX][MAXVEX];<br><span class="hljs-type">void</span> <span class="hljs-title function_">ShortestPath_Floyd</span><span class="hljs-params">(MGraph G,Pathmatirx *p,ShortPathTable *D)</span>&#123;<br>    <span class="hljs-type">int</span> v,w,k;<br>    <span class="hljs-keyword">for</span>(v=<span class="hljs-number">0</span>;v&lt;G.numVertexes;++v)<span class="hljs-comment">//初始化D与P</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(w=<span class="hljs-number">0</span>;w&lt;G.numVertexes;++w)&#123;<br>            (*D)[v][w]=G.matirx[v][w];<span class="hljs-comment">//初始化D[v][w]</span><br>            (*P)[v][w]=w;<span class="hljs-comment">//初始化P[v][w]</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;G.numVertexes,++k)&#123;<br>        <span class="hljs-keyword">for</span>(v=<span class="hljs-number">0</span>;v&lt;G.numVertexes;++v)&#123;<br>            <span class="hljs-keyword">for</span>(w=<span class="hljs-number">0</span>;w&lt;G.numVertexes;++w)&#123;<br>                <span class="hljs-keyword">if</span>((*D)[v][w]&gt;(*D)[v][k]+(*D)[k][w])&#123;<br>(*D)[v][w]=(*D)[v][k]+(*D)[k][w];<br>                    (*P)[v][w]=(*P)[v][k];<span class="hljs-comment">//路径经过k</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="无环图的应用–拓扑排序"><a href="#无环图的应用–拓扑排序" class="headerlink" title="无环图的应用–拓扑排序"></a>无环图的应用–拓扑排序</h1><p>1.用顶点表示活动，用弧表示获得之间的优先关系（AOV网）</p><p>2.拓扑排序：若满足vi到vj之间有一条路径，则在顶点序列中，vi必须在vj之前，称为拓扑序列</p><p>​                        意思是在同一优先级的垫高点可以调换位置，因为它们不存在路径到达彼此</p><p>3.在有向图构造拓扑时是，若全部顶点被输出，说明无环，是拓扑，否则不是。</p><p>4.步骤：找到入度为0的顶点，将其删除并输出，直到输出所有顶点，或者不存在入度</p><p>为0的顶点时</p><p>5.结构代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EdgeNode</span>&#123;</span><span class="hljs-comment">//边表</span><br><span class="hljs-type">int</span> adjvex;<span class="hljs-comment">//存储顶点对应的下标</span><br>    <span class="hljs-type">int</span> weight;<span class="hljs-comment">//存储权值,非网图不需要</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EdgeNode</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//链域，指向下一个邻接点</span><br>&#125;EdgeNode;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VertexNode</span>&#123;</span><span class="hljs-comment">//顶点表</span><br><span class="hljs-type">int</span> in;<br>    <span class="hljs-type">int</span> data;<br>    EdgeNode *firstedge;<span class="hljs-comment">//边表头指针</span><br>&#125;VertexNode,AdjList[MAXVEX];<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>AdjList adjList;<br>    <span class="hljs-type">int</span> numVertexes,numEdges;<br>&#125;graphAdjList,*GraphAdjList;<br><br><span class="hljs-comment">//拓扑排序，若GL无回路，输出拓扑排序序列并返回OK</span><br>Status <span class="hljs-title function_">TopologicalSort</span><span class="hljs-params">(GraphAdjList GL)</span>&#123;<br>    EdgeNode *e;<br>    <span class="hljs-type">int</span> i,k,gettop;<br>    <span class="hljs-type">int</span> top =<span class="hljs-number">0</span>;<span class="hljs-comment">//栈指针下标</span><br>    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<span class="hljs-comment">//输出顶点的个数</span><br>    <span class="hljs-type">int</span>  *Stack;<span class="hljs-comment">//存储入度为0的顶点</span><br>    Stack=(<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(GL-&gt;numvertexes *<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;GL-&gt;numVertexes;i++)<br>        <span class="hljs-keyword">if</span>(GL-&gt;adjList[i].in==<span class="hljs-number">0</span>)<br>            Stack[++top]=i;<span class="hljs-comment">//将入度为0的顶点入栈</span><br>    <span class="hljs-keyword">while</span>(top!=<span class="hljs-number">0</span>)&#123;<br>gettop=Stack[top--];<span class="hljs-comment">//出栈</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-&gt;&quot;</span>,GL-&gt;adjList[gettop].data);<br>        count++;<span class="hljs-comment">//输出顶点数</span><br>        <span class="hljs-keyword">for</span>(e=GL-&gt;adjList[gettop].firstedge;e;e=e-&gt;next)&#123;<br>            k=e-&gt;adjvex;<br>            <span class="hljs-keyword">if</span>(!(--GL-&gt;adjList[k].in))<br>                Stack[++top]=k;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(count&lt;Gl-&gt;numvertexes)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h1><p>1.有向图中描述边的活动的网，称为Activity on Edge(AOE)</p><p>2.AOE网中，起始也称源点，终点边称为汇点</p><p>3.顶点表示“事件”，边表示“活动”，权值表示“活动持续时间”</p><p>4.在AOE图中，路线具有最大权值的路径称为关键路径，关键路径上的活动称为关键活动</p><p>5.事件最早发生的时间etv(earlest time of vertex)</p><p>​    时间最晚发生时间ltv(latest time of vertex)</p><p>​    活动最早发生时间ete(earlest time of edge)</p><p>​    活动最晚发生时间lte(latest time of edge)</p><p><strong>由12可求34，通过ete[k]是否等于lte[k]可以判断ak是否为关键活动</strong></p><p>6.求关键路径时，调用拓扑排序算法计算etv和拓扑排序序列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *etv,*ltv;<span class="hljs-comment">//最早指针和最晚指针</span><br><span class="hljs-type">int</span> *Stack2;<span class="hljs-comment">//存储拓扑排序的栈</span><br><span class="hljs-type">int</span> top2;<span class="hljs-comment">//用于stack2的指针</span><br></code></pre></td></tr></table></figure><p>7.拓扑排序算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">TopoLogicalSort</span><span class="hljs-params">(GraphAdjList GL)</span>&#123;<br>    EdgeNode *e;<br>    <span class="hljs-type">int</span> i,k,gettop;<br>    <span class="hljs-type">int</span> top=<span class="hljs-number">0</span>;<span class="hljs-comment">//栈下标</span><br>    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<span class="hljs-comment">//输出顶点个数</span><br>    <span class="hljs-comment">//将入度为0的顶点入栈</span><br>    <span class="hljs-type">int</span> *Stack;<br>    Stack=(<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(GL-&gt;numVertexes;i++)<br>        <span class="hljs-keyword">if</span>(Gl-&gt;adjList[i].in==<span class="hljs-number">0</span>)<br>            Stack[++i]=i;<br>    <span class="hljs-comment">//对6中的定义进行操作</span><br>    top2=<span class="hljs-number">0</span>;<br>    etv=(<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(GL-&gt;numVertexes*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;GL-&gt;numvertexes;i++)<br>        etv[i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//初始化</span><br>    Stack2=(<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(GL-&gt;numvertexes*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">while</span>(top!=<span class="hljs-number">0</span>)&#123;<br>        gettop=<span class="hljs-built_in">stack</span>[top--];<br>        count++;<br>        stack2[++top2]=gettop;<br>        <span class="hljs-keyword">for</span>(e=GL-&gt;adjList[gettop].firstedge;e;e-&gt;next)&#123;<br>            k=e-&gt;adjvex;<br>            <span class="hljs-keyword">if</span>(!(--adjList[k].in))<br>                Stack[++top]=k;<br>            <span class="hljs-keyword">if</span>((etv[gettop]+e-&gt;weight)&gt;etv[k])<br>                etv[k]=etv[gettop]+e-&gt;weight;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(count&lt;GL-&gt;numVertexes)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>8.关键路径的算法代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">CriticalPath</span><span class="hljs-params">(GraphAdjList GL)</span>&#123;<br>    EdgeNode *e;<br>    <span class="hljs-type">int</span> i,gettop,k,j;<br>    <span class="hljs-type">int</span> ete,lte;<br>    TopologicalSort(GL);<br>    ltv=(<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(GL-&gt;numVertexes*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;GL-&gt;numVertexes;i++)<br>        ltv[i]=etv[GL-&gt;numVertexes<span class="hljs-number">-1</span>];<span class="hljs-comment">//初始化ltv</span><br>    <span class="hljs-keyword">while</span>(top2!=<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//计算ltv</span><br>    gettop=stack2[top2--];<span class="hljs-comment">//将拓扑序列出栈</span><br>        <span class="hljs-keyword">for</span>(e=GL-&gt;adjList[gettop].firstedge;e;e=e-&gt;next)&#123;<br>k=e-&gt;adjvex;<br>            <span class="hljs-keyword">if</span>(ltv[k]-e-&gt;weight&lt;ltv[gettop])<br>                ltv[gettop]=ltv[k]-e-&gt;weight;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;GL-&gt;numVertexes;j++)<br>        <span class="hljs-keyword">for</span>(e=GL-&gt;adjList[j].firstedge;e;e=e-&gt;next)&#123;<br>k=e-&gt;adjvex;<br>            ete=etv[j];<br>            lte=ltv[k]-e-&gt;weight;<br>            <span class="hljs-keyword">if</span>(ete==lte)<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&lt;v%d,v%d&gt;length:%d&quot;</span>,GL-&gt;adjList[j].data,GL-&gt;adjList[k].data,e-&gt;weight);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构--树</title>
    <link href="/2022/07/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/"/>
    <url>/2022/07/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="树是数据结构中考察的重点，要多看！"><a href="#树是数据结构中考察的重点，要多看！" class="headerlink" title="树是数据结构中考察的重点，要多看！"></a>树是数据结构中考察的重点，要多看！</h2><span id="more"></span><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>1.树有n个结点，当n大于1时，其余结点可以分为m个互不相交的有限集。</p><p>2.n大于0时，根节点是唯一的；</p><p>   m大于0时，字数个数无限制，但一定是互不相交的。</p><p>3.结点拥有的子叶数称为结点的度degree，度为0称为终端节点，度不为零称为分支节点，树的度是树内各个结点的度的max值</p><p>4.结点的祖先是从根到该结点所经分支上的所有结点，</p><p>​    同理，以某结点为根的子树的任一结点都为该结点的子孙。</p><p>5.双亲在同一层的结点称为堂兄弟。</p><p>6.森林（forest）是n棵互不相交的树的集合</p><p>7.树的抽象数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">ADT Tree<br>Data<br>    树是由一个根节点和若干棵子树构成<br>Operation<br>    <span class="hljs-title function_">InitTree</span><span class="hljs-params">(*T)</span>:构造空树T<br>    <span class="hljs-title function_">DestoryTree</span><span class="hljs-params">(*T)</span>:摧毁树T<br>    <span class="hljs-title function_">CreateTree</span><span class="hljs-params">(*T,definition)</span>:按照definition定义的树来构造树T<br>    <span class="hljs-title function_">ClearTree</span><span class="hljs-params">(*T)</span>:若树T存在，清空树T<br>    <span class="hljs-title function_">TreeEmpty</span><span class="hljs-params">(T)</span>:若树T为空树，返回1，若不为空树，返回0<br>    <span class="hljs-title function_">TreeDepth</span><span class="hljs-params">(T)</span>:返回树的深度<br>    <span class="hljs-title function_">Root</span><span class="hljs-params">(T)</span>:返回T的根结点<br>    <span class="hljs-title function_">Value</span><span class="hljs-params">(T,cur_e)</span>:cur_e是树T的一个结点,返回cur_e值<br>    <span class="hljs-title function_">Assign</span><span class="hljs-params">(T,cur_e,value)</span>:cur_e是树T的一个结点cur_e赋值为value<br>    <span class="hljs-title function_">Parent</span><span class="hljs-params">(T,cur_e)</span>:若cur_e是树T非根结点，返回双亲<br>    <span class="hljs-title function_">LeftChild</span><span class="hljs-params">(T,cur_e)</span>:返回cur_e左孩子<br>    <span class="hljs-title function_">RightSibling</span><span class="hljs-params">(T,cur_e)</span>:返回cur_e的右兄弟<br>    <span class="hljs-title function_">InsertChild</span><span class="hljs-params">(*T,*p,i,c)</span>:插入c为树T中p所指结点第i个子树<br>    <span class="hljs-title function_">DeleteChild</span><span class="hljs-params">(*T,*p,i)</span>:删除T中p所指第i个子树<br>    endADT<br></code></pre></td></tr></table></figure><h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><p>1.每个结点，不一定有孩子，但一定有且仅有一个双亲</p><p>2.定义双亲结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 200</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> PTElemType;<br><span class="hljs-type">int</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PTNode</span>&#123;</span><span class="hljs-comment">//PTNode相当于ParentNode</span><br>    PTElemType data;<br>    <span class="hljs-type">int</span> parent;<span class="hljs-comment">//结点，双亲位置</span><br>&#125;PTNode;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    PTNode node[MAXSIZE];<span class="hljs-comment">//结点数组</span><br>    <span class="hljs-type">int</span> r,n;<span class="hljs-comment">//根的位置r和结点数n</span><br>&#125;PTree;<br></code></pre></td></tr></table></figure><p><strong>只要双亲相等，那么int parent相等（即同一行的元素的parent结点相等）通常把根节点的parent值设置为-1</strong></p><p>3.长子域：每个结点，若是存在长子（最左边的孩子），那么记录下它的下标，放入firstchild，否则记录-1</p><p>4.右兄弟域：每一个结点如果存在右兄弟，那么记录下右兄弟的下标，没有则记录-1，录进rightsib</p><h3 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h3><p>1.每个结点有多个指针域，每个指针指向一棵子树的根节点，这种方法叫做多重链表表示法</p><p>2.指针域的个数等于树的度 data child1 child2 child3</p><p>   其中n是树的度，一个结点有几个孩子就有几个指针</p><p>3.孩子表示法：对于每个结点的孩子结点都创建一个链表，则n个结点有n个链表，有孩子结点的放到一列:data firstchild</p><p>​    <strong>没有孩子的结点</strong>放在<strong>有孩子结点</strong>的后面，名为child next ，next指向他的兄弟</p><p>孩子表示法结构定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_Tree_SIZE 200</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CTNode</span>&#123;</span><br>    <span class="hljs-type">int</span> child;<span class="hljs-comment">//数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CTNode</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//定义结点</span><br>&#125;*childPtr;<span class="hljs-comment">//表示结点要靠他</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    TElemType data;\<br>    ChildPtr firstchild;<br>&#125;CTBox;<span class="hljs-comment">//表头</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    CTBox nodes[MAX_Tree_SIZE];<br>    <span class="hljs-type">int</span> r,n;<span class="hljs-comment">//根位置和结点数</span><br>&#125;CTree;<br></code></pre></td></tr></table></figure><p>三、孩子兄弟表示法</p><p>​    因为长子唯一，且右兄弟结点唯一，那么设计两个指针，分别指向该节点的第一个孩子和此结点的兄弟，若有其一不存在，用NULL（^）表示</p><p> data firstchild rightsib</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>1.定义：二叉树是n个结点组成的有限集合</p><p>2.特点：每个结点最多有两颗子树，所以Node的度小于等于2</p><p>​             左右子树是有顺序的，不可以颠倒</p><p>3.二叉树有5种基本形态：空二叉树，只有一个根节点，根节点有左子树，根节点有右子树，既有左子树也有右子树。</p><p>4.特殊的二叉树： a 只有左子树的二叉树叫做左斜树</p><p>​                           b 只有右孩子的二叉树的二叉树叫做右斜树</p><p>5 满二叉树的特点：</p><p>​    a.叶子只能出现在最下层，出现在其他层不行</p><p>​    b.非叶子结点的度是2</p><p>​    c.同样深度的二叉树中，满二叉树的节点最多</p><p>6.完全二叉树</p><p>   在满二叉树的条件下，保持所有节点位置不变，只减少数量</p><p>​    满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树，<strong>不能出现编号空档</strong></p><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><p>1.在二叉树的第i层至多有2的i-1次方个结点（i&gt;1）</p><p>2.深度为k的二叉树至多有2的k-1次方个结点</p><p>3.对于二叉树T，若子叶结点数为n0，度为2的结点数n2，那么n0=n2+1；</p><p>4.具有n个结点的完全二叉树深度为log2n + 1（其中log2n向下取整），</p><p>5.对于一棵有n个结点的完全二叉树（深度为log2n+1（同样log2n向下取整））的结点按顺序编号，对于任一结点i（1&lt;=i&lt;=n都有）：</p><p>​    a.如果i=1，i是二叉树的根，无双亲，若i&gt;1，则双亲是结点i/2（向下取整）</p><p>​    b.如果2i&gt;n，则i无左孩子，i是叶子结点，否则左孩子是2i</p><p>​    c.如果2i+1&gt;n，则i无右孩子，否则右孩子是2i+1</p><p>6.对于n个结点的二叉树，二叉链表中有2n个指针，其中n-1个指针指向孩子结点，同样有n-1个指针指向双亲结点。</p><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><p>一、树的顺序存储结构</p><p>1.用一维数组存储二叉树的结点</p><p><strong>数据</strong> A B C D E F G H </p><p><strong>下标</strong> 1 2 3  4 5 6  7 8</p><p>对于一般的二叉树，下标不用变，只需要把不存在的节点变为^即可</p><p>2.但是这和存储方式在一般的树中会造成很大的空间浪费，所以只适用于完全二叉树</p><p>二、二叉链表</p><p>1.二叉链表是有两个指针的，一个指向左孩子，一个指向右孩子</p><p> lchild data rchild</p><p>2.二叉链表的结构定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span>&#123;</span><br>TElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchild</span>,*<span class="hljs-title">rchild</span>;</span><span class="hljs-comment">//左右孩子指针</span><br>&#125;BiTNode,BiTree;<br></code></pre></td></tr></table></figure><h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><p>一、定义：从根节点出发，按照某种次序依次访问二叉树的所有结点，使得每个结点被访问一次且仅被访问一次。</p><p>二、遍历方法：</p><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>先前序遍历左子树，再前序遍历后子树</p><p>算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">PreOrderTraverse</span><span class="hljs-params">(BiTree T)</span>&#123;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,T-&gt;data);<span class="hljs-comment">//显示结点数据</span><br>    PreOrderTraverse(T-&gt;lchild);<span class="hljs-comment">//先遍历左子树</span><br>    PreOrderTraverse(T-&gt;rchild);<span class="hljs-comment">//再遍历右子树</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>算法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InOrderTraverse</span><span class="hljs-params">(BiTree T)</span>&#123;<br><span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> ;<span class="hljs-comment">//返回空</span><br>    InOrderTraverse(T-&gt;lchild);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,T-&gt;data);<br>    InorderTraverse(T-&gt;rchild);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">TailOrderTraverse</span><span class="hljs-params">(BiTree T)</span>&#123;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> ;<br>    TailOrderTraverse(T-&gt;lchild);<br>    TailOrderTraverse(T-&gt;rchild);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,T-&gt;data);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：后序遍历在回退的时候，不能直接打印，要看该结点是否有右节点，如果有要先遍历到右节点再打印</p><h4 id="根据已知顺序推导"><a href="#根据已知顺序推导" class="headerlink" title="根据已知顺序推导"></a>根据已知顺序推导</h4><p>已知前序/后序和中序可以推导整棵树</p><p>已知前序和后序无法推导中序</p><h3 id="二叉树的建立"><a href="#二叉树的建立" class="headerlink" title="二叉树的建立"></a>二叉树的建立</h3><p>1.拓展二叉树，对于每个结点的空的孩子都建立一个虚结点#；</p><p>2.生成二叉树算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">CreateBiTree</span><span class="hljs-params">(BiTree *T)</span>&#123;<br>    TElemType ch;<span class="hljs-comment">//键盘输入</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,ch);<br>    <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;#&#x27;</span>)<span class="hljs-comment">//如果键盘输入为0</span><br>        *T=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        *T=(BiTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BiTNode));<span class="hljs-comment">//给T赋予内存</span><br>        <span class="hljs-keyword">if</span>(!*T)<span class="hljs-comment">//即当T等于NULL的时候</span><br>            <span class="hljs-built_in">exit</span>(OVERFLOW);<br>        (*T)-&gt;data=ch;<span class="hljs-comment">//生成结点</span><br>        CreateBiTree(&amp;(*T)-&gt;lchild);<span class="hljs-comment">//递归，生成左孩子</span><br>        CreateBiTree(&amp;(*T)-&gt;rchild);<span class="hljs-comment">//递归，生成右孩子</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>1.把指向前去和后继指针称为线索，加上线索的二叉链表称为线索二叉树（Threaded Binary Tree）</p><p>2.增加布尔类型的标志域放在指针中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">lchild ltag data rtag rchild<br><span class="hljs-comment">//当ltag=0，指向左孩子，当ltag=1，指向前驱</span><br><span class="hljs-comment">//当rtag=0，指向右孩子，当rtag=1，指向后继</span><br></code></pre></td></tr></table></figure><p><strong>注意：是在二叉树中空闲的指针才会用来指向前驱和后继，不能影响正常的左右孩子的表达</strong></p><p>3.线索二叉树的结构实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span>&#123;</span>Link,Thread&#125; PointerTag;<br><span class="hljs-comment">//Link=0表示指向左右孩子结点，Thread==1表示指向前驱后继结点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiThrNode</span>&#123;</span><span class="hljs-comment">//二叉树线索存储结点</span><br>    TElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiThrNode</span> *<span class="hljs-title">lchild</span>,*<span class="hljs-title">rchild</span>;</span><br>    PointTag LTag;<br>    PointTag RTag;<br>&#125;BiThrNode,*BiThrTree;<span class="hljs-comment">//线索树</span><br></code></pre></td></tr></table></figure><p>4.线索化就是在遍历的过程中，一遍遍历一边修改空指针。</p><p>5.中序遍历线索化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">BiThrTree pre;<span class="hljs-comment">//指向刚访问过的节点</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InThreading</span><span class="hljs-params">(BiTheTree p&#123;</span><br><span class="hljs-params"><span class="hljs-keyword">if</span>(p)&#123;</span><br><span class="hljs-params">        InThreading(p-&gt;lchild);<span class="hljs-comment">//递归左子树线索化</span></span><br><span class="hljs-params">        <span class="hljs-keyword">if</span>(!p-&gt;lchild)&#123;<span class="hljs-comment">//无左孩子</span></span><br><span class="hljs-params">        p-&gt;ltag=Thread;<span class="hljs-comment">//前驱线索</span></span><br><span class="hljs-params">            p-&gt;lchild=pre;<span class="hljs-comment">//左孩子指向前驱</span></span><br><span class="hljs-params">        &#125;</span><br><span class="hljs-params">        <span class="hljs-keyword">if</span>(!pre-&gt;rchild)&#123;</span><br><span class="hljs-params">            pre-&gt;rtag=Thread;</span><br><span class="hljs-params">            pre-&gt;rchild=p;</span><br><span class="hljs-params">        &#125;</span><br><span class="hljs-params">        pre=p;</span><br><span class="hljs-params">        InThreading(p-&gt;child);<span class="hljs-comment">//递归右子树线索化</span></span><br><span class="hljs-params">    &#125;   </span><br><span class="hljs-params">&#125;</span><br></code></pre></td></tr></table></figure><p>6.线索树中的头结点</p><p>头结点 的左孩子指针指向树的根节点，右孩子指向中序遍历的最后一个结点。</p><p>然后，令中序的第一个元素和最后一个元素的lchild和rchild结点指向根节点</p><p>7.在6的基础上，代码如下：（中序遍历）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">InOrderTraverse_Thr</span><span class="hljs-params">(BiThrTree T)</span>&#123;<br>BiTree p;<span class="hljs-comment">//树中结点</span><br>p=T-&gt;lchild;<span class="hljs-comment">//树的头结点的左孩子是p，即p指向根节点</span><br><span class="hljs-keyword">while</span>(p!=T)&#123;<br><span class="hljs-keyword">while</span>(p-&gt;LTag==Link)<span class="hljs-comment">//结束条件p.LTag==Thr</span><br>p=p-&gt;child;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,p-&gt;data);<span class="hljs-comment">//中序的第一个结点</span><br>        <span class="hljs-keyword">while</span>(p-&gt;RTag==Thread&amp;&amp;p-&gt;rchild!=T)&#123;<br>            p=p-&gt;rchild;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,p-&gt;data);<br>        &#125;<br>    &#125;<br>    p=p-&gt;rchild;<span class="hljs-comment">//p进至右子树根</span><br>&#125;<br></code></pre></td></tr></table></figure><p>8.中序遍历的时间复杂度为O(n)，适用于遍历，查找结点时需要前去或者后继。</p><h2 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h2><h3 id="树转二叉树"><a href="#树转二叉树" class="headerlink" title="树转二叉树"></a>树转二叉树</h3><p>1.加线，在所有兄弟结点之间加一条连线。</p><p>2.去线，对树中的每一个结点，只保留它与first child 的连线。</p><p>3.调整使得层次分明</p><h3 id="森林转二叉树"><a href="#森林转二叉树" class="headerlink" title="森林转二叉树"></a>森林转二叉树</h3><p>1.把每棵树转化为二叉树。</p><p>2.第一棵树位置不变，第二棵树插入第一棵树根节点的右孩子。</p><h3 id="二叉树转树"><a href="#二叉树转树" class="headerlink" title="二叉树转树"></a>二叉树转树</h3><p>1.X的左孩子的所有右孩子结点都与X相连接。</p><p>2.删除所有左孩子和右孩子的连线</p><p>3.层次调整</p><h3 id="二叉树转森林"><a href="#二叉树转森林" class="headerlink" title="二叉树转森林"></a>二叉树转森林</h3><p><strong>判断：二叉树的根节点是否有右孩子，如果有可变森林，没有不可变森林</strong></p><p>1.删除所有与右孩子的连线！</p><p>2.再将每棵分离后的二叉树转化为树</p><h3 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h3><h4 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h4><p>1.先根遍历：从根出发，一次遍历每个子树</p><p>2.后根遍历：从子树出发，最后遍历根</p><h4 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h4><p>1.前序遍历：对没棵树从前往后先根遍历</p><p>2.后序遍历：对每棵树从前往后后根遍历</p><h2 id="赫夫曼树及其运用"><a href="#赫夫曼树及其运用" class="headerlink" title="赫夫曼树及其运用"></a>赫夫曼树及其运用</h2><p>1.定义：假设有n个权值{w1,w2,….,wn},构造一棵有n个叶子结点的二叉树，每个叶子结点带权wk，每个叶子结点路径长为lk，带权路径长度WPL=w1* l1+ w2 * l2 + … + wk * lk 最小的二叉树，称为赫夫曼树</p><p>2.寻找最优赫夫曼树</p><p>a.先把有权值的叶子结点从小到大排序成有序序列，A5,E10,B15,D30.</p><p>b.取两个最小权值结点作为新结点N1的两个子结点，小在左，大在右</p><p>c.将N1替换A与E，有N1:15,B:15,D:30,C:40</p><p>d.将N1与B作为新结点N2，……，权值N2=N1+B=30</p><p>…</p><p>最后C：40，N3：60，将C与N3作为T的结点，T就是赫夫曼树的根节点</p><h3 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h3><p>左0右1</p><h2 id="二叉树递归三步"><a href="#二叉树递归三步" class="headerlink" title="二叉树递归三步"></a>二叉树递归三步</h2><p>1.递归函数的参数和返回值</p><p>2.终止条件</p><p>3.单层递归的逻辑</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构--串</title>
    <link href="/2022/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%B2/"/>
    <url>/2022/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="数据结构中串的基本概念和知识点"><a href="#数据结构中串的基本概念和知识点" class="headerlink" title="数据结构中串的基本概念和知识点"></a>数据结构中串的基本概念和知识点</h2><span id="more"></span><p>1.串是由0个或者多个字符组成的有限序列，又名字符串。</p><p>2.零个字符串的串称为“空串”（null String）它的长度为0，可用““””来表示</p><p>3.名词解释：</p><p>​    a.空格串：只包含有空格的字符串，与空串是不一样的</p><p>​    b.子串和主串：串中任意个数的字符组成的子序列称为该串的子串</p><p><strong>子串在主串中的位置即子串的第一个字母在主串的位置（序号）</strong></p><p>4.在C语言中比较两个串是否相等时，必须是长度和各个位置的内容都相等的时候才算相等。s</p><p>   即”a1a2a3a4a5a6”和”b1b2b3b4b5b6”，当且仅当m=n，且a1=b1,a2=b2,…,an=bn时才相等。</p><p>5.当前几个字符都相同，只有最后的字符不相同时，谁的ASCII码大，谁就大。如happy和happen对比y&gt;e，所以happy&gt;happen。</p><p>6.串的抽象数据类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">ADT String<br>Data<br>    串的元素仅由一个字符组成，相邻元素有前驱和后继的关系。<br>Operation<br>    <span class="hljs-title function_">StrAssign</span><span class="hljs-params">(T,*chars)</span>:生产一个值等于字符串常量chars的串T<br>    <span class="hljs-title function_">StrCopy</span><span class="hljs-params">(T,S)</span>:串S存在，由串S复制得串T<br>    <span class="hljs-title function_">ClearString</span><span class="hljs-params">(S)</span>:串S存在，将串清空<br>    <span class="hljs-title function_">StringEmpty</span><span class="hljs-params">(S)</span>:若串S为空，返回<span class="hljs-literal">true</span>，否则返回<span class="hljs-literal">false</span><br>    <span class="hljs-title function_">StrLength</span><span class="hljs-params">(S)</span>:返回S的长度<br>    <span class="hljs-title function_">StrCompare</span><span class="hljs-params">(S,T)</span>:若S&gt;T，返回值大于0，若S=T，返回值=<span class="hljs-number">0</span>，S&lt;T，返回值小于<span class="hljs-number">0</span><br>    ConCat(T,S1,S2):用T返回S1和S2链接成新的串<br></code></pre></td></tr></table></figure><p>7.Index操作(主要是通过substring函数和++i来一个一个的取)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status<br>Status <span class="hljs-title function_">Index</span><span class="hljs-params">(String S,String T,<span class="hljs-type">int</span> pos)</span>&#123;<br><span class="hljs-type">int</span> n,m,i;<br>String Sub;<br><span class="hljs-keyword">if</span>(pos&gt;<span class="hljs-number">0</span>)&#123;<br>m=StrLength(S);<br>n=StrLength(T);<br>i=pos;<br><span class="hljs-keyword">while</span>(i&lt;=m-n+<span class="hljs-number">1</span>)&#123;<br>SubString(sub,S,i,n);<br>        <span class="hljs-keyword">if</span>(StrCompare(sub,T)!=<span class="hljs-number">0</span>)<br>            ++i;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> i;<br>&#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="串的顺序存储"><a href="#串的顺序存储" class="headerlink" title="串的顺序存储"></a>串的顺序存储</h3><p>1.顺序存储是用定长数组来实现的，通常数组长度在0下标或杂合最后一个位置，也有的在串末尾用“\0”来表示结束，此时需要遍历数组才可以得知数组长度。</p><p>2.计算机中存在一个动态的自由存储区，叫做“堆”，可由C语言的动态分配函数malloc和free来管理，malloc是分配内存，free是释放内存。</p><h3 id="串的链式存储"><a href="#串的链式存储" class="headerlink" title="串的链式存储"></a>串的链式存储</h3><p>1.在不需要用到的内存位置，用#来填充。</p><p>2.串的链式存储除了在连接字符串时候有用，其余时间是不如顺序存储方便，灵活的。</p><h3 id="朴素的模式匹配算法"><a href="#朴素的模式匹配算法" class="headerlink" title="朴素的模式匹配算法"></a>朴素的模式匹配算法</h3><p>如，要匹配子串google和主串goodgoogle的位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">Index</span><span class="hljs-params">(String S,String T,<span class="hljs-type">int</span> pos)</span>&#123;<br><span class="hljs-type">int</span> i=pos;<span class="hljs-comment">//从pos往后开始遍历，pos在主串中。</span><br>    <span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;<span class="hljs-comment">//j在子串中，从1开始遍历</span><br>    <span class="hljs-keyword">if</span>(i&lt;=S[<span class="hljs-number">0</span>]&amp;&amp;j&lt;=T[<span class="hljs-number">0</span>])&#123;<span class="hljs-comment">//假定长度数据都存储在下标为0的位置</span><br>        i++;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>i=i-j+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>;<span class="hljs-comment">//i-j+1是开始的元素，再+1是下一个元素</span><br>        j=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(j&gt;T[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">return</span> i-T[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="一个极端例子"><a href="#一个极端例子" class="headerlink" title="一个极端例子"></a>一个极端例子</h4><p>​                            S=50位数：“0000…0001”</p><p>​                            T=10位数:”0000…0001”</p><p>对于这个例子，每次都要匹配到最后一位才知道匹不匹配，一次匹配配十次，一共进行了50-10+1次，时间复杂度为（50-10+1）,设LengthS=n,LengthT=m,O((n-m+1)*m)</p><h3 id="KMP匹配算法"><a href="#KMP匹配算法" class="headerlink" title="KMP匹配算法"></a>KMP匹配算法</h3><p>知识点看笔记</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>1.返回T的next数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">get_next</span><span class="hljs-params">(String T,<span class="hljs-type">int</span> *next)</span>&#123;<br><span class="hljs-type">int</span> i,j;<br>i=<span class="hljs-number">1</span>;<br>j=<span class="hljs-number">0</span>;<br>next[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i&lt;T[<span class="hljs-number">0</span>])<span class="hljs-comment">//T[0]是T的长度</span><br>&#123;<br><span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>||T[i]=T[j])<span class="hljs-comment">//T[i]是末元素，T[j]是首元素</span><br>        &#123;<br>            ++i;<br>            ++j;<br>            next[i]=j;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            j=next[j];<span class="hljs-comment">//不等就回溯</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.返回子串T在主串S中第pos个字符的位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//1&lt;=pos&lt;=StrLength(S)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Index_KMP</span><span class="hljs-params">(String S,String T,<span class="hljs-type">int</span> pos)</span>&#123;<br>    <span class="hljs-type">int</span> i=pos;<span class="hljs-comment">//i表示当前的主串的位置</span><br>    <span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;<span class="hljs-comment">//用j定义子串T的下标值</span><br>    <span class="hljs-type">int</span> next[<span class="hljs-number">255</span>];<span class="hljs-comment">//定义next数组256</span><br>    get_next(T,next);<span class="hljs-comment">//获取串T的next值</span><br>    <span class="hljs-keyword">while</span>(i&lt;=s[<span class="hljs-number">0</span>]&amp;&amp;j&lt;=T[<span class="hljs-number">0</span>])&#123;<br>        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>||s[i]==T[j])&#123;<br>            ++i;<br>            ++j;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            j=next[j];<span class="hljs-comment">//指针后退的代码，牢记</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(j&gt;T[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">return</span> i-T[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构--栈和队列(DH)</title>
    <link href="/2022/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97-DH/"/>
    <url>/2022/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97-DH/</url>
    
    <content type="html"><![CDATA[<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p><strong>栈：吃了吐；队列：吃了拉</strong></p><span id="more"></span><h2 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈-Stack"></a>栈-Stack</h2><p>1.允许插入和删除的一端是栈顶（top），另一端是栈底（bottom）不含任何元素的栈为<strong>空栈</strong>，栈是一种先进后出的数据结构（Last In First Out）称为LIFO.</p><p>2.栈的插入操作称为进栈；栈的删除操作称为出栈。</p><p>3.栈的插入（push），删除（pop）</p><p>4.当栈中存在一个元素的时候，栈顶下标为O(top=0)</p><p>5.栈的结构定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> SElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    SElemType data[MAXSIZE];<br>    <span class="hljs-type">int</span> top;<br>&#125;SqStack;<br></code></pre></td></tr></table></figure><p>6.栈的push操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">push</span><span class="hljs-params">(SqStack *S,SElemType *e)</span>&#123;<br>    <span class="hljs-keyword">if</span>(S-&gt;top==MAXSIZE<span class="hljs-number">-1</span>)<span class="hljs-comment">//记住这个条件</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    S-&gt;top++;<br>    S-&gt;data[S-&gt;top] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>7.栈的pop操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"> Status <span class="hljs-title function_">pop</span><span class="hljs-params">(SqStack *S,SElemType *e)</span>&#123; <br><span class="hljs-keyword">if</span>(S-&gt;top==<span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    *e=s-&gt;data[S-&gt;top];<br>    S-&gt;top--;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>8.两栈共享空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//注意top1是--，top2是++，并且存在StackNumber参数</span><br><span class="hljs-comment">//判断栈满的条件是：top1+1==top2，即两个指针相差为1的时候即栈满</span><br><span class="hljs-comment">//结构体</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    SElemType data[MAXSIZE];<br>    <span class="hljs-type">int</span> top1;<br>    <span class="hljs-type">int</span> top2;<br>&#125;SqDoubleStack;<br></code></pre></td></tr></table></figure><p>9.两栈共享空间的push方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">push</span><span class="hljs-params">(SqDoubleStack *S,ElemType e,<span class="hljs-type">int</span> StackNumber)</span>&#123;<br>    <span class="hljs-keyword">if</span>(S-&gt;top1+<span class="hljs-number">1</span>==S-&gt;top2)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(StackNumber==<span class="hljs-number">1</span>)<br>        S-&gt;data[++S-&gt;top1]=e;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(StackNumber==<span class="hljs-number">2</span>)<br>        S-&gt;data[++S-&gt;top2]=e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>10.两栈共享空间的pop方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">pop</span><span class="hljs-params">(SqDoubleStack *S,SElemType *e,<span class="hljs-type">int</span> StackNumber)</span><br><span class="hljs-title function_">if</span><span class="hljs-params">(StackNumber==<span class="hljs-number">1</span>)</span>&#123;<br><span class="hljs-keyword">if</span>(S-&gt;top1==<span class="hljs-number">-1</span>)<span class="hljs-comment">//到栈底了</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    *e = S-&gt;data[S-&gt;top1];<br>    S-&gt;top1--;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(StackNumber==<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">if</span>(S-&gt;top2==n)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        *e=S-&gt;data[S-&gt;top2];<br>        S-&gt;top2++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>**(important)**11.栈的链式存储的结构定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StackNode</span>&#123;</span><br>SElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StackNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;StackNode,*LinkStackPtr;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkStack</span>&#123;</span><br>    LinkStackPtr top;<br>    <span class="hljs-type">int</span> count;<br>&#125;LinkStack;<br></code></pre></td></tr></table></figure><p>12.进栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">push</span><span class="hljs-params">(LinkStack *s,SElemType e)</span>&#123;<br>    LinkStackPtr s = (LinkStackPtr)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Stack));<br>    s-&gt;data = e;<br>    s-&gt;next = S-&gt;top;<br>    s-&gt;top = s;<br>    s-&gt;length++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>13.出栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">pop</span><span class="hljs-params">(LinkStack *S,SElemType *e)</span>&#123;<br>LinkStackPtr p;<br><span class="hljs-keyword">if</span>(StackEmpty(*S))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    *e = s-&gt;top-&gt;data;<span class="hljs-comment">//e保存顶部结点数据</span><br>    p = s-&gt;top;<span class="hljs-comment">//p表示顶部结点</span><br>    s-&gt;top = s-&gt;next-&gt;top;<span class="hljs-comment">//把尾部变成下一个元素的结点</span><br>    <span class="hljs-built_in">free</span>(p);<br>    s-&gt;length--;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="栈的应用–递归"><a href="#栈的应用–递归" class="headerlink" title="栈的应用–递归"></a>栈的应用–递归</h3><p>1.斐波那契数列：前两项数字相邻之和等于后一项。</p><p>2.把直接调用自己或者间接调用自己本身函数的数列叫做递归数列；一个递归数列必须至少有一个条件使得满足条件之后退出循环；</p><p>3.后缀表达式：a.初始化空栈InitStack；</p><p>​    ·                     b.后缀表达式中的数字进栈（左边的）</p><p>​                          c.符号进栈（在下面的是被加数，在上面的是加数）</p><p>​                          d.再将运算result进栈</p><p>就像这样依次出栈计算即可。</p><p>4.中缀转后缀：是右括号或者优先级低于栈顶元素的先输出，把数字放在一边，把符号放在另一边。</p><h2 id="队列Queue"><a href="#队列Queue" class="headerlink" title="队列Queue"></a>队列Queue</h2><p>1.队列（queue）是只允许在一端进行插入操作，另一端进行删除操作。</p><p>2.队列是先进先出的线性表（First In First Out）FIFO</p><p>3.运行插入元素的称为队尾，允许删除元素的称为队头。</p><p>4.队列的抽象数据类型（ADT）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">ADT Queue<br>Data<br>同线性表，有前驱和后继元素<br>Operation<br><span class="hljs-title function_">InitQueue</span><span class="hljs-params">(*Q)</span>:初始化队列<br><span class="hljs-title function_">DestroyQueue</span><span class="hljs-params">(*Q)</span>:销毁队列<br><span class="hljs-title function_">ClearQueue</span><span class="hljs-params">(*Q)</span>:清空队列<br><span class="hljs-title function_">QueueEmpty</span><span class="hljs-params">(Q)</span>:如果队列是空的返回1，不是返回0<br><span class="hljs-title function_">GetHead</span><span class="hljs-params">(Q,*e)</span>:用e返回Q中的队头元素<br><span class="hljs-title function_">EnQueue</span><span class="hljs-params">(*Q,e)</span>:插入新元素e到Q的队尾<br><span class="hljs-title function_">DeQueue</span><span class="hljs-params">(*Q,*e)</span>:删除队头元素并复制给e<br><span class="hljs-title function_">QueueLength</span><span class="hljs-params">(Q)</span>:返回队列的元素个数<br>endADT<br></code></pre></td></tr></table></figure><p>5.队列中的出队要把后面的所有元素向前移动一位，O(n)</p><p>6.队列中有前指针front，有后指针rear</p><p>7.假溢出：如果前面元素Location是空出来的，而在添加元素的时候尾指针指向了数组外面称为假溢出。（见笔记本）</p><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>1.定义：为了reslove假溢出的问题，引出了循环队列的概念</p><p>2.（理论）队空的条件是front==rear，flag=0</p><p>  队满的条件是front==rear，flag=1    </p><p>3.（在实际做题中）队满的条件是（rear+1）%QueueSIZE==front</p><p>​                                  队空的条件是front==rear</p><p>4.当rear&gt;front时，队列长度=rear-front</p><p>   当front&gt;rear时，队列长度=（0+rear）+（QueueSize-front）=rear-front+QueueSize</p><p><strong>所以队列的通用公式是：(rear-front+QueueSize)%QueueSize</strong></p><p>5.循环队列的顺序存储结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 200</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> QElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>QElemType data[MAXSIZE];<br><span class="hljs-type">int</span> front;<br><span class="hljs-type">int</span> rear;<br>&#125;SqQueue;<br></code></pre></td></tr></table></figure><p>6.循环队列初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">InitQueue</span><span class="hljs-params">(Squeue *Q)</span>&#123;<br>Q-&gt;front = <span class="hljs-number">0</span>;<br>Q-&gt;rear = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>7.循环队列求长度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">QueueLength</span><span class="hljs-params">(SqQueue Q)</span>&#123;<br><span class="hljs-keyword">return</span>(Q-&gt;rear-Q-&gt;front+MAXSIZE)%MAXSIZE;<br>&#125;<br></code></pre></td></tr></table></figure><p>8.插入新的元素在队尾：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">EnQueue</span><span class="hljs-params">(SqQueue *Q,QElemType e)</span>&#123;<br><span class="hljs-keyword">if</span>((Q-&gt;rear+<span class="hljs-number">1</span>)%MAXSIZE == Q-&gt;front)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    Q-&gt;data[Q-&gt;rear]=e;<br>    Q-&gt;rear = (Q-&gt;rear+<span class="hljs-number">1</span>)%MAXSIZE;<span class="hljs-comment">//rear后移一位</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>9.删除元素在队头：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">DeQueue</span><span class="hljs-params">(SqQueue *Q,QElemType *e)</span>&#123;<br><span class="hljs-keyword">if</span>(Q-&gt;rear==Q-&gt;front)<span class="hljs-comment">//这个是队空的条件，一定记住。</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>*e = Q-&gt;data[Q-&gt;front];<br>Q-&gt;front=(Q-&gt;front+<span class="hljs-number">1</span>)%MAXSIZE;<span class="hljs-comment">//front向后移动一位</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="队列的链式存储"><a href="#队列的链式存储" class="headerlink" title="队列的链式存储"></a>队列的链式存储</h3><p>1.有头结点，当空队列的时候，front和rear都指向头结点</p><p>2.先定义结点指针，再定义表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> QElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span>&#123;</span><br>QElemType data[MAXSIZE];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;QNode,*QueuePtr;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    QueuePtr front,rear;<br>&#125;LinkQueue;<br></code></pre></td></tr></table></figure><p>3.插入队列元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">EnQueue</span><span class="hljs-params">(LinkQueue *Q,QElemType e)</span>&#123;<br>QueuePtr s = (LinkQueue)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(QNode));<br>    <span class="hljs-keyword">if</span>(!s)<br>        <span class="hljs-keyword">return</span> ERROR;<span class="hljs-comment">//或者exit(OVERFLOW)</span><br>    s-&gt;data=e;<br>    s-&gt;next=<span class="hljs-literal">NULL</span>;<br>    Q-&gt;rear-&gt;next=s;<br>    Q-&gt;rear=s;<span class="hljs-comment">//把s作为队尾元素</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>4.出队（主义：front是在头结点上）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">DeQueue</span><span class="hljs-params">(LinkQueue *Q,QElemType *e)</span>&#123;<br>    QueuePtr p;<span class="hljs-comment">//p结点</span><br>    <span class="hljs-keyword">if</span>(Q-&gt;front==Q-&gt;rear)<span class="hljs-comment">//队空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    *e=Q-&gt;data[Q-&gt;front-&gt;next];<span class="hljs-comment">//指向第一个结点</span><br>    p=Q-&gt;front-&gt;next;<span class="hljs-comment">//p保留准备删除的结点</span><br>    Q-&gt;front-&gt;next<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构--线性表（DH）</title>
    <link href="/2022/07/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%88DH%EF%BC%89/"/>
    <url>/2022/07/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%88DH%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><span id="more"></span><p>1.数组和线性表的区别：数组占多少内存就是多少，不能改变；而线性表是可以变化的，只需要线性表在数组当中即可。由此可以推出：length(数组)&gt;=length(线性表)</p><p>2.第i个数据元素ai的location是i-1</p><p>3.定义线性表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 200</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType data[MAXSIZE];<br>    <span class="hljs-type">int</span> length;<br>&#125;SqList;<br></code></pre></td></tr></table></figure><p>4.头结点和头指针：头结点是不必要的；而头指针是必要的。</p><p>​                                   <strong>头结点</strong>指链表中 第一个结点前面的结点，通常存放着一些重要信息。</p><p>​                                   <strong>头指针</strong>是指向第一个结点的指针</p><h2 id="顺序线性表"><a href="#顺序线性表" class="headerlink" title="顺序线性表"></a>顺序线性表</h2><p>1.顺序表的GetElem（获取元素）代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;<br>Status <span class="hljs-title function_">GetElem</span><span class="hljs-params">(SqList L,<span class="hljs-type">int</span> i,ElemType *e)</span>&#123;<br><span class="hljs-keyword">if</span>(L-&gt;length==<span class="hljs-number">0</span> || i&lt;<span class="hljs-number">1</span> || i&gt;L-&gt;length)<br><span class="hljs-keyword">return</span> ERROR;<br>    *e = L.data[i];<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.如果第i个元素是由指针p指向的，那么第i个元素也可以用p来表示，该元素的数据域是p-&gt;data，指针域是p-&gt;next。</p><p>同理，如果第i+1个元素是由指针p-&gt;next指向的，那么第i个元素用p-&gt;next来表示，该元素的数据域是p-&gt;next-&gt;data，指针域是p-&gt;next-&gt;next。</p><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>1.单链表的结构体定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><span class="hljs-comment">//和第四行结合，将结构体重命名为Node</span><br>    ElemType data;<span class="hljs-comment">//定义数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//定义结构体指针，注意类型是struct Node类型，因为这个指针指向的是Node类型的元素</span><br>&#125;Node;<br></code></pre></td></tr></table></figure><p>2.获取元素操作GetElem,<strong>运行到了最后，p是i的元素，而不是i的前一个元素，分清楚！</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;<br>Status <span class="hljs-title function_">GetElem</span><span class="hljs-params">(LinkList *L,<span class="hljs-type">int</span> i,ElemType *e)</span>&#123;<br>    LinkList p;<span class="hljs-comment">//定义指针p</span><br>    <span class="hljs-type">int</span> j;<span class="hljs-comment">//定义计数器</span><br>    j = <span class="hljs-number">1</span>;<br>    p = L-&gt;next;<span class="hljs-comment">//p指向L的第一个结点</span><br>    <span class="hljs-keyword">while</span>(p&amp;&amp;j&lt;i)&#123;<span class="hljs-comment">//当指针的指向不为0，即下一个元素不是0的时候</span><br>        p = p-&gt;next;<br>        ++j;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!p || j&gt;i)<span class="hljs-comment">//当p下一个结点为空或者j大于i的时候</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    *e = p-&gt;data;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.单链表的增加结点的操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;<br>Status <span class="hljs-title function_">ListInsert</span><span class="hljs-params">(LinkList *L,<span class="hljs-type">int</span> i,ElemType e)</span>&#123;<br>    <span class="hljs-type">int</span> j;<span class="hljs-comment">//计数器</span><br>    j = <span class="hljs-number">1</span>;<br>    LinkList p,s;<span class="hljs-comment">//注意定义s结点。</span><br>    p = *L;<span class="hljs-comment">//指向头结点</span><br>    <span class="hljs-keyword">while</span>(p&amp;&amp;j&lt;i)&#123;<br>        p = p-&gt;next;<br>        ++j;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!p || j&gt;i)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    s = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<span class="hljs-comment">//注意要生成s结点</span><br>    s-&gt;next = p-&gt;next;<br>    p-&gt;next = s;<br>    L-&gt;length++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>4.单链表的删除结点的操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">ListDelete</span><span class="hljs-params">(LinkList *L,<span class="hljs-type">int</span> i,ElemType *e)</span>&#123;<br>    <span class="hljs-type">int</span> j;<br>    j = <span class="hljs-number">1</span>;<br>    LinkList p,q;<span class="hljs-comment">//p是遍历结点，q是p-&gt;next结点</span><br>    p = *L;<span class="hljs-comment">//注意p是指向头结点的</span><br>    <span class="hljs-keyword">while</span>(p-&gt;next&amp;&amp;j&lt;i)&#123; <span class="hljs-comment">//如果p-&gt;next不为0，且j小于i</span><br>        p = p-&gt;next;<br>        ++j;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!p-&gt;next || j&lt;i)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    q = p-&gt;next;<br>    p-&gt;next = q-&gt;next;<br>    *e = q-&gt;data;<br>    <span class="hljs-built_in">free</span>(q); <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>5.单链表的整表创建：(头插法)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">CreateListHead</span><span class="hljs-params">(LinkList *L,<span class="hljs-type">int</span> n)</span>&#123;<br>    LinkList p;<br>    srand(time(<span class="hljs-number">0</span>));<br>   *L = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    (*L)-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        p = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>        p-&gt;data = rand()%<span class="hljs-number">100</span>+<span class="hljs-number">1</span>;<br>        p-&gt;next = (*L)-&gt;next;<br>        (*L)-&gt;next = p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>6.单链表的整表创建（尾插法）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">CreateListTail</span><span class="hljs-params">(LinkList *L,<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    LinkList r,p;<br>    *L = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    r = *L;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        p = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>        p-&gt;data = rand()%<span class="hljs-number">100</span>+<span class="hljs-number">1</span>;<br>        r-&gt;next = p;<br>        r = p;<br>        L-&gt;length++;<br>    &#125;<br>    r-&gt;next = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>7.单链表的整表删除：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">ClearList</span><span class="hljs-params">(LinkList *L,<span class="hljs-type">int</span> n)</span>&#123;<br>    LinkList p,q;<br>    p = (*L)-&gt;next;<span class="hljs-comment">//指向第一个结点</span><br>    <span class="hljs-keyword">while</span>(p)&#123;<br>        q = p-&gt;next;<br>        <span class="hljs-built_in">free</span>(q);<br>        p = q;<br>    &#125;<br>    (*L)-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="静态链表-需要结合书本"><a href="#静态链表-需要结合书本" class="headerlink" title="静态链表(需要结合书本)"></a>静态链表(需要结合书本)</h2><p>1.声明静态链表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 200</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType data;<br>    <span class="hljs-type">int</span> cur;<br>&#125;Component,StaticLinkList[MAXSIZE];<br></code></pre></td></tr></table></figure><p>2.<strong>数组的第一个元素的cur用来存放备用链表第一个结点的下标，</strong></p><p>​    <strong>数组的最后一个元素的cur用来存放第一个插入元素的下标，头结点</strong></p><p>3.备用链表：链表中前面的是已用链表，后面的是未用链表，未用链表也称为备用链表</p><p>4.初始化静态链表（InitStaticList）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">InitList</span><span class="hljs-params">(StaticLinkList space)</span>&#123;<br><span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;MAXSIZE<span class="hljs-number">-1</span>;i++)<span class="hljs-comment">//注意这里i是下标，所以从0开始，到</span><br>        space[i].cur=i+<span class="hljs-number">1</span>;<span class="hljs-comment">//游标永远指向下一个元素</span><br>    space[MAXSIZE<span class="hljs-number">-1</span>].cur = <span class="hljs-number">0</span>;<span class="hljs-comment">//这是最后一个元素</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>5.cur中存放的是下标，在链表中的最后一个有值元素i中，</p><p>LinkList space;</p><p>space[i-1].cur = 0;</p><p>i的游标（指针）指向0</p><p>6.StaticLinkList的Insert操作（大话数据结构P72）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//Insert Operation</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Malloc_SSL</span><span class="hljs-params">(StaticLinkList space)</span>&#123;<br>    <span class="hljs-type">int</span> i = space[<span class="hljs-number">0</span>].cur;<span class="hljs-comment">//i暂时为第一个元素指向的值</span><br>    <span class="hljs-keyword">if</span>(space[<span class="hljs-number">0</span>].cur)<br>        space[<span class="hljs-number">0</span>].cur = space[i].cur;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>7.在L中第i个元素前插入新的数据元素e</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">Ststus <span class="hljs-title function_">ListInsert</span><span class="hljs-params">(StaticLinkList *L,<span class="hljs-type">int</span> i,ElemType e)</span>&#123;<br>    <span class="hljs-type">int</span> j,k,l;<span class="hljs-comment">//j用来存放第一个空闲元素下标，k用来存放最后一个元素下标，l用来参与for循环遍历</span><br>    k = MAXSIZE - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span> || i&gt;ListLength(L)+<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    j = malloc_SSL(L);<span class="hljs-comment">//获得第一个空闲元素的下标</span><br><span class="hljs-keyword">if</span>(j)&#123;<br>        L[j].data = e;<br>        <span class="hljs-keyword">for</span>(l=<span class="hljs-number">1</span>;l&lt;i;i++)<br>            k = L[K].cur<span class="hljs-comment">//第一次的k是第一个元素，i-1次是i-1个。此时k是第i-1个元素，j是要插在k后面的元素</span><br>        L[j].cur = L[K].cur;<br>        L[K].cur = j;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>8.在静态链表中，找第i-1个元素的方法固定</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">k = MAXSIZE<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(l=<span class="hljs-number">1</span>;l&lt;i;l++)<br>    k = L[k].cur;<br><span class="hljs-comment">//此时的k就是L中的第i-1个元素</span><br></code></pre></td></tr></table></figure><p>9.删除StaticLinkList中的元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">DeleteList</span><span class="hljs-params">(StaticLinkList L,<span class="hljs-type">int</span> i)</span>&#123;<br>    <span class="hljs-type">int</span> j,k;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span> || i&gt;ListLength(L))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    k = MAXSIZE<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=i<span class="hljs-number">-1</span>;j++)<br>        k = L[k].cur;<br>    j=L[k].cur;<br>    L[k].cur = L[j].cur;<br>    free_SSl(L,j);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>10.free_SSL代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">free_SSL</span><span class="hljs-params">(StaticLinkList space,<span class="hljs-type">int</span> k)</span>&#123;<br>    <span class="hljs-comment">//k是要被删除的元素</span><br>    space[k].cur = space[<span class="hljs-number">0</span>].cur;<span class="hljs-comment">//k指向空表中第一个元素</span><br>    space[<span class="hljs-number">0</span>].cur = k;<span class="hljs-comment">//使得k成为空表第一个元素</span><br>&#125;<br></code></pre></td></tr></table></figure><p>11.Length方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">ListLength</span><span class="hljs-params">(StaticLinkList L)</span>&#123;<br>    <span class="hljs-type">int</span> i,k;<br>    k = L[MAXSIZE<span class="hljs-number">-1</span>].cur;<br>    <span class="hljs-keyword">while</span>(k)&#123;<br>        k = L[k].cur;<br>        ++j;<br>    &#125;<br>    <span class="hljs-keyword">return</span> j;<br>&#125;<br></code></pre></td></tr></table></figure><p>12.静态链表：优点：方便插入删除，只需要修改游标；</p><p>​                         缺点：不利于存储操作。</p><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>1.要把最后一个元素的rear和第一个元素的front连接起来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//rear-&gt;next是头节点，而不是第一个结点</span><br>p = rearA-&gt;next;<br>rearA-&gt;next = rearB-&gt;next-&gt;next;<span class="hljs-comment">//把A最后一个结点指向B第一个结点</span><br>q = rearB-&gt;next;<span class="hljs-comment">//q保存B头结点</span><br>rearB-&gt;next = p;<span class="hljs-comment">//B指向A的头结点</span><br><span class="hljs-built_in">free</span>(q);<br></code></pre></td></tr></table></figure><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>1.定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DulNode</span>&#123;</span><br>ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DulNode</span> *<span class="hljs-title">prior</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DulNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;DulNode,*DulLinkList;<br></code></pre></td></tr></table></figure><p>2.双向链表的插入操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">s-&gt;prior = p;<br>s-&gt;next = p-&gt;next;<br>p-&gt;next-&gt;prior = s;<br>p-&gt;next = s;<br><span class="hljs-comment">//总结：先对s前后操作,再p-&gt;next,再p</span><br></code></pre></td></tr></table></figure><p>3.双向链表删除操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">p-&gt;prior-&gt;next = p-&gt;next;<br>p-&gt;next-&gt;prior = p_prior;<br><span class="hljs-built_in">free</span>(p);<br></code></pre></td></tr></table></figure><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>1.将顺序表中所有元素逆置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Reverse</span><span class="hljs-params">(SqList *L)</span>&#123;<br>    ElemType temp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;L.length/<span class="hljs-number">2</span>;i++)&#123;<br>        L.data[i] = L.data[L.length-i<span class="hljs-number">-1</span>];<br>        L.data[L.length-i<span class="hljs-number">-1</span>] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>R-安装R语言</title>
    <link href="/2022/07/03/R-%E5%AE%89%E8%A3%85R%E8%AF%AD%E8%A8%80/"/>
    <url>/2022/07/03/R-%E5%AE%89%E8%A3%85R%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1Uv411n76i?spm_id_from=333.337.search-card.all.click&amp;vd_source=acefe4c123e2b73c9e6c4b23e6627fa8">https://www.bilibili.com/video/BV1Uv411n76i?spm_id_from=333.337.search-card.all.click&amp;vd_source=acefe4c123e2b73c9e6c4b23e6627fa8</a></p><p>需要注意的是在linux使用R的时候每次都要先激活R语言：conda activate user_R</p><p>然后使用：R 来访问R语言</p><p>使用：radian 来访问有颜色的R语言</p>]]></content>
    
    
    <categories>
      
      <category>R语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>R语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python--考试复习</title>
    <link href="/2022/06/19/python-%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    <url>/2022/06/19/python-%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><span class="hljs-comment"># 产生 1 到 10 的一个整数型随机数</span><br><span class="hljs-built_in">print</span>(random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>))<br><span class="hljs-comment"># 产生 0 到 1 之间的随机浮点数</span><br><span class="hljs-built_in">print</span>(random.random())<br><span class="hljs-comment"># 产生  1.1 到 5.4 之间的随机浮点数，区间可以不是整数</span><br><span class="hljs-built_in">print</span>(random.uniform(<span class="hljs-number">1.1</span>, <span class="hljs-number">5.4</span>))<br><span class="hljs-comment"># 从序列中随机选取一个元素</span><br><span class="hljs-built_in">print</span>(random.choice([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>]))<br><span class="hljs-comment"># 生成从1到100的间隔为2的随机整数</span><br><span class="hljs-built_in">print</span>(random.randrange(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-number">2</span>))<br><span class="hljs-comment"># 将序列a中的元素顺序打乱</span><br>a = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]<br>random.shuffle([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>])<br><span class="hljs-built_in">print</span>(a)<br></code></pre></td></tr></table></figure><h3 id="列表排序"><a href="#列表排序" class="headerlink" title="列表排序"></a>列表排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#reverse方法</span><br>a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>a.reverse()<br><span class="hljs-built_in">print</span>(a) <span class="hljs-comment">#[4,3,2,1]</span><br><br><span class="hljs-comment">#sort方法:由小到大进行排序</span><br>x = [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]<br>x.sort()<br><span class="hljs-built_in">print</span>(x) <span class="hljs-comment">#[1,2,3,4,5]</span><br><span class="hljs-comment">#还可以将根据字符串的长度进行升序排列</span><br>x = [<span class="hljs-string">&#x27;aaaaa&#x27;</span>,<span class="hljs-string">&#x27;aaa&#x27;</span>,<span class="hljs-string">&#x27;aa&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;aaaa&#x27;</span>]<br>x.sort()<br><span class="hljs-built_in">print</span>(x) <span class="hljs-comment">#[&#x27;a&#x27;,&#x27;aa&#x27;,&#x27;aaa&#x27;,&#x27;aaaa&#x27;,&#x27;aaaaa&#x27;]</span><br><br><span class="hljs-comment">#sort函数会对原列表进行修改，但是sorted函数不会进行修改,因此需要创建一个变量来存放新的列表</span><br>x = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>y = <span class="hljs-built_in">sorted</span>(x)<br><span class="hljs-built_in">print</span>(x,end=<span class="hljs-string">&#x27;  &#x27;</span>)<br><span class="hljs-built_in">print</span>(y)<br></code></pre></td></tr></table></figure><h3 id="统计字符串中不同类型字符的个数"><a href="#统计字符串中不同类型字符的个数" class="headerlink" title="统计字符串中不同类型字符的个数"></a>统计字符串中不同类型字符的个数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">character = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入任意字符：&#x27;</span>)<br>i = number = space = other = letter = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(character )):<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;a&#x27;</span> &lt;= character [i] &lt;= <span class="hljs-string">&#x27;z&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;A&#x27;</span> &lt;= character [i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>:<br>        letter += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;0&#x27;</span> &lt;= character [i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>:<br>        number += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> character [i] == <span class="hljs-string">&#x27; &#x27;</span>:<br>        space += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        other += <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;字母个数为：&quot;</span>,letter,<span class="hljs-string">&#x27;\t&#x27;</span>,<span class="hljs-string">&quot;数字个数为：&quot;</span>,number,<span class="hljs-string">&#x27;\t&#x27;</span>,<span class="hljs-string">&quot;空格个数为：&quot;</span>,space,<span class="hljs-string">&#x27;\t&#x27;</span>,<span class="hljs-string">&quot;其他字符个数为：&quot;</span>,other)<br></code></pre></td></tr></table></figure><h3 id="字符串加密"><a href="#字符串加密" class="headerlink" title="字符串加密"></a>字符串加密</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">Mes = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入一串字符：&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;加密后为:&#x27;</span>,end=<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(Mes)):<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ord</span>(Mes[i])&gt;=<span class="hljs-number">65</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">ord</span>(Mes[i])&lt;=<span class="hljs-number">87</span>) <span class="hljs-keyword">or</span> (<span class="hljs-built_in">ord</span>(Mes[i])&gt;=<span class="hljs-number">97</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">ord</span>(Mes[i])&lt;=<span class="hljs-number">119</span>):<br>        m=<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(Mes[i])+<span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">elif</span> (<span class="hljs-built_in">ord</span>(Mes[i])&gt;=<span class="hljs-number">88</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">ord</span>(Mes[i])&lt;=<span class="hljs-number">90</span>) <span class="hljs-keyword">or</span>(<span class="hljs-built_in">ord</span>(Mes[i])&gt;=<span class="hljs-number">120</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">ord</span>(Mes[i])&lt;=<span class="hljs-number">122</span>):<br>        m=<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(Mes[i])-<span class="hljs-number">23</span>)<br>    <span class="hljs-keyword">else</span>:<br>        m=Mes[i]<br>    <span class="hljs-built_in">print</span> (m,end=<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#统计一串字符中的字母，空格，数字，其他字符的数量并且输出</span><br>a = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入一个字符串：&#x27;</span>)<br>i = space = alpha = number = other = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a:<br>    <span class="hljs-keyword">if</span> i.isspace():<br>        space += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> i.isalpha():<br>        alpha += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> i.isnumeric():<br>number += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span> :<br>        other += <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(space,alpha,number,other)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#编写程序，生成一个包含20个随机整数的列表，然后对其中偶数下标的元素进行降序排列，奇数下标的元素不变</span><br><span class="hljs-keyword">import</span> random<br><span class="hljs-built_in">list</span> = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):<br>    i = random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">100</span>)<br>    <span class="hljs-built_in">list</span>.append(i)<br>oushu = []<br>jishu = []<br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>:<br>    <span class="hljs-keyword">if</span> j%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>:<br>        oushu.append[j]<br>    <span class="hljs-keyword">if</span> j%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>:<br>        jishu.append[j]<br>oushu.sort(reverse=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(jishu)<br><span class="hljs-built_in">print</span>(oushu)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#编写一个程序生成20个随机整数，前十个进行升序排序，后十个进行降序排序</span><br><span class="hljs-keyword">import</span> random<br><span class="hljs-built_in">list</span> = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):<br>i = random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">100</span>)<br>    <span class="hljs-built_in">list</span>.append(i)<br>list1 = <span class="hljs-built_in">list</span>[<span class="hljs-number">0</span>:<span class="hljs-number">9</span>]<br>list1.sort()<br>list2 = <span class="hljs-built_in">list</span>[<span class="hljs-number">10</span>:<span class="hljs-number">19</span>]<br>list2.sort(reverse=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(list1)<br></code></pre></td></tr></table></figure><p>自己的总结<br>1.导入库时候先from再import<br>2.生成随机小数的函数：random.random() 要先导入random库<br>3.python序列类型：序列类型：字符串，列表，元组，映射类型：字典，集合类型：集合<br>4.元组，列表的区别：<br>a.列表可以进行修改，元组不行<br>b.列表拥有很多元组不具有的方法，如：append()，extend(),remove(),pop()<br>c.列表可以进行切片访问和修改，元组只能进行切片访问<br>d.元组的访问速度比列表快很多<br>e.列表不能作为字典的键，但是元组可以</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#append函数和extend函数的区别</span><br>a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br><span class="hljs-built_in">list</span> = []<br><span class="hljs-built_in">list</span>.append(a) <span class="hljs-comment">#list=[[1,2]]可见是整个列表添加上去的</span><br><span class="hljs-built_in">list</span>.extend(a) <span class="hljs-comment">#list=[1,2] 可见是列表拆开之后加上去的</span><br><span class="hljs-comment">#总结：如果extend的是字符串，则字符串会被拆分成字符数组，如果extend的是字典，则字典的key会被加入到List中</span><br></code></pre></td></tr></table></figure><p>5.format函数的作用：”{0,3}”.format(“Hello”,”World”) 其中0是代表调用format括号内的第一个参数，3是当参数的字符串不足3位的时候，自动在后面补上空格<br>6.filter函数返回类型是迭代器，需要和list函数搭配使用，那么返回的就是列表，其功能和map函数类似，就是计算给定参数对应的函数值<br>7.rfind函数查找对应字符串最后一次出现的位置的第一个字符的位置！<br>8.升级pip的命令：pip install pip -U<br>9.一些库：request:http请求工具<br>      pandas:分析结构化数据的工具<br>      jieba:中文分词工具</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习--考试复习</title>
    <link href="/2022/06/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    <url>/2022/06/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="第三章-重点"><a href="#第三章-重点" class="headerlink" title="第三章(重点)"></a>第三章(重点)</h3><h4 id="不同行业的工龄与薪水的线性回归模型"><a href="#不同行业的工龄与薪水的线性回归模型" class="headerlink" title="不同行业的工龄与薪水的线性回归模型"></a>不同行业的工龄与薪水的线性回归模型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>df = pd.read_excel(<span class="hljs-string">&#x27;IT行业收入表.xlsx&#x27;</span>)<br>df.head()<span class="hljs-comment">#显示前五行</span><br><br>X = df[[<span class="hljs-string">&#x27;工龄&#x27;</span>]]<br>Y = df[<span class="hljs-string">&#x27;薪水&#x27;</span>]<br><br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression<br>regr = LinearRegression()<br>regr.fit(X,Y)<br><br>plt.scatter(X,Y)<br>plt.plot(X,regr.predict(X),color=<span class="hljs-string">&#x27;red&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;工龄&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;薪水&#x27;</span>)<br>plt.show()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;截距：&#x27;</span>+<span class="hljs-built_in">str</span>(regr.intercept_))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;系数：&#x27;</span>+<span class="hljs-built_in">str</span>(regr.coef_))<br></code></pre></td></tr></table></figure><h3 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h3><h4 id="模型搭建"><a href="#模型搭建" class="headerlink" title="模型搭建"></a>模型搭建</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>df = pd.read_excel(<span class="hljs-string">&#x27;员工离职模型.xlsx&#x27;</span>)<br>df = df.replace(&#123;<span class="hljs-string">&#x27;工资&#x27;</span>:&#123;<span class="hljs-string">&#x27;低&#x27;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;中&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;高&#x27;</span>:<span class="hljs-number">2</span>&#125;&#125;)<br>df.head()<span class="hljs-comment">#显示前五行</span><br><br>X = df.drop(columns=<span class="hljs-string">&#x27;离职&#x27;</span>)<br>Y = df[<span class="hljs-string">&#x27;离职&#x27;</span>]<br><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br>X_train,X_test,Y_train,Y_test = train_test_split(X,Y,test_size=<span class="hljs-number">0.2</span>,random_state=<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> DecisionTreeClassifier<br>model = DecisionTreeClassifier()<br>model.fit(X_train,Y_train)<br></code></pre></td></tr></table></figure><h4 id="模型预测"><a href="#模型预测" class="headerlink" title="模型预测"></a>模型预测</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python">y_pred = model.predict(X_test)<br>a = pd.DataFrame()<br>a[<span class="hljs-string">&#x27;预测值&#x27;</span>] = <span class="hljs-built_in">list</span>(y_pred)<br>a[<span class="hljs-string">&#x27;实际值&#x27;</span>] = <span class="hljs-built_in">list</span>(y_test)<br><br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score<br>score = accuracy_score(y_pred,y_test)<br><span class="hljs-comment">#显示所有分数</span><br>model.score(X_test,y_test)<br><br><span class="hljs-comment">#离职和不离职的概率</span><br>y_pred_proba = model.predict_proba(X_test)<br>b = pd.DataFrame(y_pred_proba,columns=[<span class="hljs-string">&#x27;不离职概率&#x27;</span>,<span class="hljs-string">&#x27;离职概率&#x27;</span>])<br>y_pred_proba[:,<span class="hljs-number">1</span>]<br><br><span class="hljs-comment">#用ROC曲线进行预测</span><br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> roc_curve<br>fpr,tpr,thres = roc_curve(y_test,y_pred_proba[:,<span class="hljs-number">1</span>])<br>a = pd.DataFrame()<br>a[<span class="hljs-string">&#x27;阈值&#x27;</span>] = <span class="hljs-built_in">list</span>(fpr)<br>a[<span class="hljs-string">&#x27;假报警率&#x27;</span>] = <span class="hljs-built_in">list</span>(tpr)<br>a[<span class="hljs-string">&#x27;命中率&#x27;</span>] = <span class="hljs-built_in">list</span>(thres)<br><br><span class="hljs-comment">#画出来</span><br><span class="hljs-keyword">import</span> matplotlib <span class="hljs-keyword">as</span> plt<br>plt.plot(fpr,tpr) <br>plt.show()<br></code></pre></td></tr></table></figure><h3 id="第六章-考试的时候可能会把肿瘤改成其他的病"><a href="#第六章-考试的时候可能会把肿瘤改成其他的病" class="headerlink" title="第六章(考试的时候可能会把肿瘤改成其他的病)"></a>第六章(考试的时候可能会把肿瘤改成其他的病)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>df = pd.read_excel(<span class="hljs-string">&#x27;肿瘤数据.xlsx&#x27;</span>)<br>X = df.drop(columns = <span class="hljs-string">&#x27;肿瘤性质&#x27;</span>)<br>Y = df[<span class="hljs-string">&#x27;肿瘤性质&#x27;</span>]<br><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br>X_train,X_test,y_train,y_test = train_test_split(X,Y,test_size=<span class="hljs-number">0.2</span>,random_state=<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">from</span> sklearn.naive_bayes <span class="hljs-keyword">import</span> GaussianNB<br>model = GaussianNB()<br>model.fit(X_train.y_train)<br><br>y_pred = model.predict(X_test)<br>a = pd.DataFrame()<br>a[<span class="hljs-string">&#x27;预测值&#x27;</span>] = <span class="hljs-built_in">list</span>(y_pred)<br>a[<span class="hljs-string">&#x27;实际值&#x27;</span>] = <span class="hljs-built_in">list</span>(y_test)<br><br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score<br>score = accuracy_score(y_pred,y_test)<br></code></pre></td></tr></table></figure><h3 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>df = pd.read_excel(<span class="hljs-string">&#x27;手写数字识别.xlsx&#x27;</span>)<br><br>X = df.drop(columns=<span class="hljs-string">&#x27;对应数字&#x27;</span>)<br>y = df[<span class="hljs-string">&#x27;对应数字&#x27;</span>]<br><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br>X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=<span class="hljs-number">0.2</span>,random_state=<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">from</span> sklearn.neibhors <span class="hljs-keyword">import</span> KNeighborsClassifier<br>model = KNeighborsClassifier(n_neibhors=<span class="hljs-number">5</span>)<span class="hljs-comment">#记得要加n_neighbors参数</span><br>model.fit(X_train,y_train)<span class="hljs-comment">#训练模型</span><br><br><span class="hljs-comment">#开始处理图片</span><br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br>img = Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;图片.jpg&#x27;</span>)<span class="hljs-comment">#打开图片文件</span><br>img = img.resize((<span class="hljs-number">32</span>,<span class="hljs-number">32</span>))<span class="hljs-comment">#重新定义图片大小</span><br>img = img.convert(<span class="hljs-string">&#x27;L&#x27;</span>)<span class="hljs-comment">#灰度处理</span><br><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>img_new = img.point(<span class="hljs-keyword">lambda</span> x:<span class="hljs-number">0</span> <span class="hljs-keyword">if</span> x&gt;<span class="hljs-number">128</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>)<span class="hljs-comment">#这里是如果x的色彩大于128则赋值为0，否则赋值为1</span><br>arr = np.array(img_new)<br>arr_new = arr.reshape(<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">#进行预测</span><br>answer = model.predict(arr_new)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;图片中的数字为:&quot;</span>+<span class="hljs-built_in">str</span>(answer[<span class="hljs-number">0</span>]))<br></code></pre></td></tr></table></figure><h3 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#引入需要用到的库</span><br><span class="hljs-keyword">import</span> tushare <span class="hljs-keyword">as</span> ts<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> talib<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifier<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score<br><br><span class="hljs-comment"># 1.股票基本数据获取</span><br>df = ts.get_k_data(<span class="hljs-string">&#x27;000002&#x27;</span>,start=<span class="hljs-string">&#x27;2015-01-01&#x27;</span>,end=<span class="hljs-string">&#x27;2019-12-31&#x27;</span>)<br>df = df.set_index(<span class="hljs-string">&#x27;date&#x27;</span>)<br><br><span class="hljs-comment">#简单衍生变量构造</span><br>df[<span class="hljs-string">&#x27;close-open&#x27;</span>] = (df[<span class="hljs-string">&#x27;close&#x27;</span>] - df[<span class="hljs-string">&#x27;open&#x27;</span>])/df[<span class="hljs-string">&#x27;open&#x27;</span>]<br>df[<span class="hljs-string">&#x27;high-low&#x27;</span>] = (df[<span class="hljs-string">&#x27;high&#x27;</span>] - df[<span class="hljs-string">&#x27;low&#x27;</span>])/df[<span class="hljs-string">&#x27;low&#x27;</span>]<br>df[<span class="hljs-string">&#x27;pre_close&#x27;</span>] = df[<span class="hljs-string">&#x27;close&#x27;</span>].shift(<span class="hljs-number">1</span>)<br>df[<span class="hljs-string">&#x27;price_change&#x27;</span>] = df[<span class="hljs-string">&#x27;close&#x27;</span>]-df[<span class="hljs-string">&#x27;pre_close&#x27;</span>]<br>df[<span class="hljs-string">&#x27;p_change&#x27;</span>] = (df[<span class="hljs-string">&#x27;close&#x27;</span>]-df[<span class="hljs-string">&#x27;pre_close&#x27;</span>])/df[<span class="hljs-string">&#x27;pre_close&#x27;</span>]*<span class="hljs-number">100</span><br><span class="hljs-comment">#移动平均线相关数据构造</span><br>df[<span class="hljs-string">&#x27;MA5&#x27;</span>] = df[<span class="hljs-string">&#x27;close&#x27;</span>].rolling(<span class="hljs-number">5</span>).mean()<br>df[<span class="hljs-string">&#x27;MA10&#x27;</span>] = df[<span class="hljs-string">&#x27;close&#x27;</span>].rolling(<span class="hljs-number">10</span>).mean()<br>df.dropna(inplace=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 删除空值</span><br><span class="hljs-comment">#通过Ta_lib库构造衍生变量</span><br>df[<span class="hljs-string">&#x27;RSI&#x27;</span>] = talib.RSI(df[<span class="hljs-string">&#x27;close&#x27;</span>], timeperiod=<span class="hljs-number">12</span>)<br>df[<span class="hljs-string">&#x27;MOM&#x27;</span>] = talib.MOM(df[<span class="hljs-string">&#x27;close&#x27;</span>], timeperiod=<span class="hljs-number">5</span>)<br>df[<span class="hljs-string">&#x27;EMA12&#x27;</span>] = talib.EMA(df[<span class="hljs-string">&#x27;close&#x27;</span>], timeperiod=<span class="hljs-number">12</span>)<br>df[<span class="hljs-string">&#x27;EMA26&#x27;</span>] = talib.EMA(df[<span class="hljs-string">&#x27;close&#x27;</span>], timeperiod=<span class="hljs-number">26</span>)<br>df[<span class="hljs-string">&#x27;MACD&#x27;</span>], df[<span class="hljs-string">&#x27;MACDsignal&#x27;</span>], df[<span class="hljs-string">&#x27;MACDhist&#x27;</span>] = talib.MACD(df[<span class="hljs-string">&#x27;close&#x27;</span>], fastperiod=<span class="hljs-number">12</span>, slowperiod=<span class="hljs-number">26</span>, signalperiod=<span class="hljs-number">9</span>)<br>df.dropna(inplace=<span class="hljs-literal">True</span>)<br>df.tail()<br><span class="hljs-comment">#特征变量和目标变量提取</span><br>X = df[[<span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-string">&#x27;volume&#x27;</span>, <span class="hljs-string">&#x27;close-open&#x27;</span>, <span class="hljs-string">&#x27;MA5&#x27;</span>, <span class="hljs-string">&#x27;MA10&#x27;</span>, <span class="hljs-string">&#x27;high-low&#x27;</span>, <span class="hljs-string">&#x27;RSI&#x27;</span>, <span class="hljs-string">&#x27;MOM&#x27;</span>, <span class="hljs-string">&#x27;EMA12&#x27;</span>, <span class="hljs-string">&#x27;MACD&#x27;</span>, <span class="hljs-string">&#x27;MACDsignal&#x27;</span>, <span class="hljs-string">&#x27;MACDhist&#x27;</span>]]<br>y = np.where(df[<span class="hljs-string">&#x27;price_change&#x27;</span>].shift(-<span class="hljs-number">1</span>)&gt; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>)<br><span class="hljs-comment">#训练集和测试集数据划分</span><br>X_length = X.shape[<span class="hljs-number">0</span>]  <span class="hljs-comment"># shape属性获取X的行数和列数，shape[0]即表示行数</span><br>split = <span class="hljs-built_in">int</span>(X_length * <span class="hljs-number">0.9</span>)<br>X_train, X_test = X[:split], X[split:]<br>y_train, y_test = y[:split], y[split:]<br><span class="hljs-comment">#4.模型搭建</span><br>model = RandomForestClassifier(max_depth=<span class="hljs-number">3</span>, n_estimators=<span class="hljs-number">10</span>, min_samples_leaf=<span class="hljs-number">10</span>, random_state=<span class="hljs-number">1</span>)<br>model.fit(X_train, y_train)<br></code></pre></td></tr></table></figure><h3 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h3><h4 id="9-2"><a href="#9-2" class="headerlink" title="9.2"></a>9.2</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>df = pd.read_excle(<span class="hljs-string">&#x27;信用卡精准营销模型.xlsx&#x27;</span>)<br><br>X = df.drop(columns=<span class="hljs-string">&#x27;响应&#x27;</span>)<br>y = df[<span class="hljs-string">&#x27;响应&#x27;</span>]<br><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br>X_train,X_test,y_train,y_test = train_test_split(X,y,train_test_split=<span class="hljs-number">0.2</span>,random_state=<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> AdaBoostClassifier<br>model = AdaBoostClassifier()<br>model.fit(X_train,y_train)<br><br><span class="hljs-comment">#评估模型</span><br>y_pred = model.predict(X_test)<br>a = pd.DataFrame()<span class="hljs-comment">#创建一个空DateFrame</span><br>a[<span class="hljs-string">&#x27;预测值&#x27;</span>] = <span class="hljs-built_in">list</span>(y_pred)<br>a[<span class="hljs-string">&#x27;实际值&#x27;</span>] = <span class="hljs-built_in">list</span>(y_test)<br><span class="hljs-comment">#获得所有值</span><br>score = model.score(X_train,y_train)<br><span class="hljs-comment">#查看概率(不太懂)</span><br>y_pred_proba = model.predict_proba(X_test)<br><span class="hljs-comment">#用ROC曲线绘制图像</span><br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> roc_curve<br>fpr,tpr,thres = roc_curve(y_test.values,y_pred_proba[:,<span class="hljs-number">1</span>])<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>plt.plot(fpr,tpr)<br>plt.show()<br></code></pre></td></tr></table></figure><h4 id="9-4"><a href="#9-4" class="headerlink" title="9.4"></a>9.4</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>df = pd.read_excel(<span class="hljs-string">&#x27;产品定价模型.xlsx&#x27;</span>)<br><span class="hljs-comment">#处理纸张</span><br><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> LabelEncoder<br>le = LabelEncoder()<br>df[<span class="hljs-string">&#x27;类别&#x27;</span>] = le.fit_transform(df[<span class="hljs-string">&#x27;类别&#x27;</span>])<br>df[<span class="hljs-string">&#x27;类别&#x27;</span>].value_counts()<br><span class="hljs-comment">#正常</span><br>X = df.drop(columns = <span class="hljs-string">&#x27;价格&#x27;</span>)<br>Y = df[<span class="hljs-string">&#x27;价格&#x27;</span>]<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br>X_train,X_test,Y_train,Y_test = train_test_split(X,Y,test_size=<span class="hljs-number">0.2</span>,random_state=<span class="hljs-number">1</span>)<br><span class="hljs-comment">#训练模型</span><br><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> GradientBoostingRegressor<br>model = GradientBoostingRegressor()<br>model.fit(X_train,Y_train)<br><span class="hljs-comment">#预测</span><br>Y_pred = model.prodict(X_test)<br>a = pd.DataFrame()<br>a[<span class="hljs-string">&#x27;预测值&#x27;</span>] = <span class="hljs-built_in">list</span>(Y_pred)<br>a[<span class="hljs-string">&#x27;实际值&#x27;</span>] = <span class="hljs-built_in">list</span>(Y_test)<br>score = model.score(X_test,Y_test)<br></code></pre></td></tr></table></figure><h3 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>df = pd.read_excel(<span class="hljs-string">&#x27;信用卡交易模型.xlsx&#x27;</span>)<br>X = df.drop(columns=<span class="hljs-string">&#x27;欺诈标签&#x27;</span>)<br>y = df[<span class="hljs-string">&#x27;欺诈标签&#x27;</span>]<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br>X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=<span class="hljs-number">0.2</span>,random_state=<span class="hljs-number">123</span>)<br><br><span class="hljs-keyword">from</span> xgboost <span class="hljs-keyword">import</span> XGBClassifier<br>model = XGBClassifier(n_estimator=<span class="hljs-number">100</span>,learning_rate=<span class="hljs-number">0.05</span>)<span class="hljs-comment">#重点记住</span><br>model.fit(X_train,y_train)<br><br>y_pred = model.predict(X_test)<br>a = pd.DataFrame()<br>a[<span class="hljs-string">&#x27;预测值&#x27;</span>] = <span class="hljs-built_in">list</span>(y_pred)<br>a[<span class="hljs-string">&#x27;实际值&#x27;</span>] = <span class="hljs-built_in">list</span>(y_test)<br><span class="hljs-comment">#查看所有分数</span><br>score = model.score(X_test,y_test)<br><br>y_pred_proba = model.predict(X_test)<br>y_pred_proba[:,<span class="hljs-number">1</span>]<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> roc_curve<br>fpr,tpr,thres = roc_curve(y_test,y_pred_proba[:,<span class="hljs-number">1</span>])<br><span class="hljs-keyword">import</span> matplotlib <span class="hljs-keyword">as</span> plt<br>plt.plot(fpr,tpr)<br>plt.show()<br></code></pre></td></tr></table></figure><h3 id="12-2-4-数据降维之PCA-其实就是在K近邻的基础上X-train加上pca"><a href="#12-2-4-数据降维之PCA-其实就是在K近邻的基础上X-train加上pca" class="headerlink" title="12.2.4(数据降维之PCA)其实就是在K近邻的基础上X_train加上pca"></a>12.2.4(数据降维之PCA)其实就是在K近邻的基础上X_train加上pca</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier<br>model = KNeighborsClassifier()<br>model.fit(X_train_pca,y_train)<span class="hljs-comment">#加上pca证明数据降维</span><br><br>y_pred = model.predict(X_test_pca)<span class="hljs-comment">#加上pca证明数据降维</span><br><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>a = pd.DataFrame()<br>a[<span class="hljs-string">&#x27;预测值&#x27;</span>] = y_pred<br>a[<span class="hljs-string">&#x27;实际值&#x27;</span>] = y_test<br><span class="hljs-comment">#查看所有数据</span><br>score = model.score(X_test_pca,y_test)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习--深度学习</title>
    <link href="/2022/06/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/06/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#先构造数据并进行拟合</span><br>X = [[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]]<br>y = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]<br><span class="hljs-keyword">from</span> sklearn.neural_network <span class="hljs-keyword">import</span> MLPClassifier<span class="hljs-comment">#Machine Learning Please</span><br>model = MLPClassifier()<br>model.fit(X,y)<br><span class="hljs-comment">#预测</span><br>y_pred = model.predict(X)<br><span class="hljs-comment">#进行预测值和实际值的对比</span><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>a = pd.DataFrame()<br>a[<span class="hljs-string">&#x27;实际值&#x27;</span>] = <span class="hljs-built_in">list</span>[y]<br>a[<span class="hljs-string">&#x27;预测值&#x27;</span>] = <span class="hljs-built_in">list</span>[y_pred]<br></code></pre></td></tr></table></figure><h3 id="案例实战"><a href="#案例实战" class="headerlink" title="案例实战"></a>案例实战</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#导入数据</span><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>df = pd.read_excel(<span class="hljs-string">&#x27;用户情感分析.xlsx&#x27;</span>)<br>df.head()<span class="hljs-comment">#打印前五行数据</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>机器学习--XGBoost与Light-GBM</title>
    <link href="/2022/06/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-XGBoost%E4%B8%8ELight-GBM/"/>
    <url>/2022/06/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-XGBoost%E4%B8%8ELight-GBM/</url>
    
    <content type="html"><![CDATA[<h2 id="XGBoost算法"><a href="#XGBoost算法" class="headerlink" title="XGBoost算法"></a>XGBoost算法</h2><span id="more"></span><h3 id="XGBoost分类算法"><a href="#XGBoost分类算法" class="headerlink" title="XGBoost分类算法"></a>XGBoost分类算法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> xgboost <span class="hljs-keyword">import</span> XGBClassifier<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment">#其实唯一的distinguish就是这里的X数组用numpy数组创建</span><br>X = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]])<br>y = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>model = XGBClassifier()<br>model.fit(X,y)<br><span class="hljs-built_in">print</span>(model.predict(np.array([[<span class="hljs-number">5</span>,<span class="hljs-number">5</span>]])))<br></code></pre></td></tr></table></figure><h3 id="XGBoost回归模型"><a href="#XGBoost回归模型" class="headerlink" title="XGBoost回归模型"></a>XGBoost回归模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> xgboost <span class="hljs-keyword">import</span> XGBRegressor<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>X = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]])<br>y = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>model = XGRegressor()<br>model.fit(X,y)<br><span class="hljs-built_in">print</span>(model.predict(np.array([[<span class="hljs-number">5</span>,<span class="hljs-number">5</span>]])))<br></code></pre></td></tr></table></figure><h3 id="案例实战"><a href="#案例实战" class="headerlink" title="案例实战"></a>案例实战</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>df = pd.read_excel(<span class="hljs-string">&#x27;信用卡评分模型.xlsx&#x27;</span>)<br>df.head()<br><span class="hljs-comment">#提取特征变量</span><br>X = df.drop(<span class="hljs-string">&#x27;信用评分&#x27;</span>)<br>Y = df[<span class="hljs-string">&#x27;信用评分&#x27;</span>]<br><br><span class="hljs-keyword">import</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression<br>model = LinearRegression()<br>model.fit(X,Y)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;各项系数为&#x27;</span>+<span class="hljs-built_in">str</span>(model.coef_))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;截距为&#x27;</span>+<span class="hljs-built_in">str</span>(model.intercept_))<br><br><span class="hljs-comment">#模型评估</span><br><span class="hljs-keyword">import</span> statsmodels.api <span class="hljs-keyword">as</span> sm<br>X2 = sm.add_constant(X)<br>est = sm.OLS(Y,X2).fit()<br><span class="hljs-built_in">print</span>(est.summary())<br></code></pre></td></tr></table></figure><h2 id="Light-GBM"><a href="#Light-GBM" class="headerlink" title="Light-GBM"></a>Light-GBM</h2><h3 id="Light-GBM分类模型"><a href="#Light-GBM分类模型" class="headerlink" title="Light-GBM分类模型"></a>Light-GBM分类模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lightgbm <span class="hljs-keyword">import</span> LGBMClassifier<br>X = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]]<br>y = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>model = LGBMClassifier()<br>model.fit(X,y)<br><span class="hljs-built_in">print</span>(model.predict([[<span class="hljs-number">5</span>,<span class="hljs-number">5</span>]]))<br></code></pre></td></tr></table></figure><h3 id="Light-GBM回归模型"><a href="#Light-GBM回归模型" class="headerlink" title="Light-GBM回归模型"></a>Light-GBM回归模型</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua">from lightgbm import LGBMRegressor<br>X = <span class="hljs-string">[[1,2],[3,4],[5,6],[7,8],[9,10]]</span><br>y = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>model = LGBMRegressor()<br>model.fit(X,y)<br><span class="hljs-built_in">print</span>(model.predict(<span class="hljs-string">[[5,5]]</span>))<br></code></pre></td></tr></table></figure><h3 id="案例实战-1"><a href="#案例实战-1" class="headerlink" title="案例实战"></a>案例实战</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>df = pd.read_excel(<span class="hljs-string">&#x27;广告收入数据.xlsx&#x27;</span>)<br><span class="hljs-comment">#提取特征变量</span><br>X = df.drop(columns=<span class="hljs-string">&#x27;收益&#x27;</span>)<br>y = df[<span class="hljs-string">&#x27;收益&#x27;</span>]<br><span class="hljs-comment">#划分测试集和训练集</span><br><span class="hljs-keyword">import</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br>X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=<span class="hljs-number">0.2</span>,random_state=<span class="hljs-number">1</span>)<br><span class="hljs-comment">#模型回归训练</span><br><span class="hljs-keyword">from</span> lightGBM <span class="hljs-keyword">import</span> LGBMRegressor<br>model = LGBRegressor()<br>model.fit(X_train,y_train)<br><span class="hljs-comment">#预测</span><br>y_pred = model.predict(X_test)<br>a = pd.DataFrame()<br>a[<span class="hljs-string">&#x27;实际值&#x27;</span>] = <span class="hljs-built_in">list</span>(y_test)<br>a[<span class="hljs-string">&#x27;预测值&#x27;</span>] = <span class="hljs-built_in">list</span>(y_pred)<br><span class="hljs-comment">#全部数据</span><br>score = model.score(X_test,y_test)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习--AdaBoost和GBDT</title>
    <link href="/2022/06/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-AdaBoost%E5%92%8CGBDT/"/>
    <url>/2022/06/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-AdaBoost%E5%92%8CGBDT/</url>
    
    <content type="html"><![CDATA[<h2 id="AdaBoost模型"><a href="#AdaBoost模型" class="headerlink" title="AdaBoost模型"></a>AdaBoost模型</h2><span id="more"></span><h3 id="AdaBoost分类模型"><a href="#AdaBoost分类模型" class="headerlink" title="AdaBoost分类模型"></a>AdaBoost分类模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> AdaBoostClassifier<br>X = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]]<br>y = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br><br>model = AdaBoostClassifier(random_state=<span class="hljs-number">1</span>)<br>model.fit(X,y)<br><span class="hljs-built_in">print</span>(model.predict([[<span class="hljs-number">5</span>,<span class="hljs-number">5</span>]]))<br></code></pre></td></tr></table></figure><h3 id="AdaBoost回归模型"><a href="#AdaBoost回归模型" class="headerlink" title="AdaBoost回归模型"></a>AdaBoost回归模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.ensembel <span class="hljs-keyword">import</span> AdaBoostRegressor<br>X = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]]<br>y = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><br>model = AdaBoostRegressor(random_state=<span class="hljs-number">1</span>)<br>model.fit(X,y)<br><span class="hljs-built_in">print</span>(model.predict([[<span class="hljs-number">5</span>,<span class="hljs-number">5</span>]]))<br></code></pre></td></tr></table></figure><h3 id="信用卡案例"><a href="#信用卡案例" class="headerlink" title="信用卡案例"></a>信用卡案例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>df = pd.read_excle(<span class="hljs-string">&#x27;信用卡精准营销模型.xlsx&#x27;</span>)<br><br>X = df.drop(columns=<span class="hljs-string">&#x27;响应&#x27;</span>)<br>y = df[<span class="hljs-string">&#x27;响应&#x27;</span>]<br><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br>X_train,X_test,y_train,y_test = train_test_split(X,y,train_test_split=<span class="hljs-number">0.2</span>,random_state=<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> AdaBoostClassifier<br>model = AdaBoostClassifier()<br>model.fit(X_train,y_train)<br><br><span class="hljs-comment">#评估模型</span><br>y_pred = model.predict(X_test)<br>a = pd.DataFrame()<span class="hljs-comment">#创建一个空DateFrame</span><br>a[<span class="hljs-string">&#x27;预测值&#x27;</span>] = <span class="hljs-built_in">list</span>(y_pred)<br>a[<span class="hljs-string">&#x27;实际值&#x27;</span>] = <span class="hljs-built_in">list</span>(y_test)<br><span class="hljs-comment">#获得所有值</span><br>score = model.score(X_train,y_train)<br><span class="hljs-comment">#查看概率(不太懂)</span><br>y_pred_proba = model.predict_proba(X_test)<br></code></pre></td></tr></table></figure><h2 id="GBDT模型"><a href="#GBDT模型" class="headerlink" title="GBDT模型"></a>GBDT模型</h2><h3 id="GBDT分类模型"><a href="#GBDT分类模型" class="headerlink" title="GBDT分类模型"></a>GBDT分类模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> GradientBoostingClassifier<br>X = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]]<br>y = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br><br>model = GradientBoostingClassifier()<br>model.fit(X,y)<br><span class="hljs-built_in">print</span>(model.predict([[<span class="hljs-number">5</span>,<span class="hljs-number">5</span>]]))<br></code></pre></td></tr></table></figure><h3 id="GBDT回归模型"><a href="#GBDT回归模型" class="headerlink" title="GBDT回归模型"></a>GBDT回归模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> GradientBoostingRegressor<br>X = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]]<br>y = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><br>model = GradientBoostingRegressor(random_state=<span class="hljs-number">1</span>)<br>model.fit(X,y)<br><span class="hljs-built_in">print</span>(model.predict([[<span class="hljs-number">5</span>,<span class="hljs-number">5</span>]]))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习--随机森林模型</title>
    <link href="/2022/06/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/06/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="随机森林的分类模型"><a href="#随机森林的分类模型" class="headerlink" title="随机森林的分类模型"></a>随机森林的分类模型</h3><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifier<br>X = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]]<br>y = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>model = RandomForestClassifier(X,y,test_size=<span class="hljs-number">0.2</span>,random_state=<span class="hljs-number">1</span>)<br>model.fit(X,y)<br>model.predict([[<span class="hljs-number">5</span>,<span class="hljs-number">5</span>]])<br></code></pre></td></tr></table></figure><h3 id="随机森林的回归模型"><a href="#随机森林的回归模型" class="headerlink" title="随机森林的回归模型"></a>随机森林的回归模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestRegressor<br>X = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]]<br>y = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>model = RandomForestRegressor(n_estimators=<span class="hljs-number">10</span>,random_state=<span class="hljs-number">1</span>)<br>model.fit(X,y)<br><span class="hljs-built_in">print</span>(model.predict([[<span class="hljs-number">5</span>,<span class="hljs-number">5</span>]]))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习--K近邻算法</title>
    <link href="/2022/06/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/"/>
    <url>/2022/06/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="K近邻算法"><a href="#K近邻算法" class="headerlink" title="K近邻算法"></a>K近邻算法</h3><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#算法</span><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>df = pd.read_excel(<span class="hljs-string">&#x27;葡萄酒.xlsx&#x27;</span>)<br>X_train = df[[<span class="hljs-string">&#x27;酒精含量(%)&#x27;</span>,<span class="hljs-string">&#x27;酸含量(%)&#x27;</span>]]<br>y_train= df[<span class="hljs-string">&#x27;分类&#x27;</span>]<br><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KN<br><br><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsRegressor<br>X = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]]<br>y = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>model = KNeighborsRegressor(n_neighbors=<span class="hljs-number">2</span>)<br>model.fit(X,y)<br><span class="hljs-built_in">print</span>(model.predict([[<span class="hljs-number">5</span>,<span class="hljs-number">5</span>]]))<br></code></pre></td></tr></table></figure><h3 id="手写数字识别模型"><a href="#手写数字识别模型" class="headerlink" title="手写数字识别模型"></a>手写数字识别模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>df = pd.read_excel(<span class="hljs-string">&#x27;手写数字识别.xlsx&#x27;</span>)<br><br>X = df.drop(columns=<span class="hljs-string">&#x27;对应数字&#x27;</span>)<br>y = df[<span class="hljs-string">&#x27;对应数字&#x27;</span>]<br><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br>X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=<span class="hljs-number">0.2</span>,random_state=<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">from</span> sklearn.neibhors <span class="hljs-keyword">import</span> KNeighborsClassifier<br>model = KNeighborsClassifier(n_neibhors=<span class="hljs-number">5</span>)<span class="hljs-comment">#记得要加n_neighbors参数</span><br>model.fit(X_train,y_train)<span class="hljs-comment">#训练模型</span><br><br><span class="hljs-comment">#开始处理图片</span><br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br>img = Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;图片.jpg&#x27;</span>)<span class="hljs-comment">#打开图片文件</span><br>img = img.resize((<span class="hljs-number">32</span>,<span class="hljs-number">32</span>))<span class="hljs-comment">#重新定义图片大小</span><br>img = img.convert(<span class="hljs-string">&#x27;L&#x27;</span>)<span class="hljs-comment">#灰度处理</span><br><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>img_new = img.point(<span class="hljs-keyword">lambda</span> x:<span class="hljs-number">0</span> <span class="hljs-keyword">if</span> x&gt;<span class="hljs-number">128</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>)<span class="hljs-comment">#这里是如果x的色彩大于128则赋值为0，否则赋值为1</span><br>arr = np.array(img_new)<br>arr_new = arr.reshape(<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">#进行预测</span><br>answer = model.predict(arr_new)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;图片中的数字为:&quot;</span>+<span class="hljs-built_in">str</span>(answer[<span class="hljs-number">0</span>]))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习--朴素贝叶斯</title>
    <link href="/2022/06/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    <url>/2022/06/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h3><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.naive_bayes <span class="hljs-keyword">import</span> GaussianNB<br>X = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]]<span class="hljs-comment">#两个特征</span><br>y = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>model = GaussianNB<br>model.fit(X,y)<br><span class="hljs-built_in">print</span>(model.predict([[<span class="hljs-number">5</span>,<span class="hljs-number">5</span>]]))<br></code></pre></td></tr></table></figure><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#1.读取excel表</span><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>df = pd.read_excel(<span class="hljs-string">&#x27;肿瘤数据.xlsx&#x27;</span>)<br><br><span class="hljs-comment">#2.划分特征变量和目标变量</span><br>X = df.drop(columns=<span class="hljs-string">&#x27;肿瘤性质&#x27;</span>)<br>y = df[<span class="hljs-string">&#x27;肿瘤性质&#x27;</span>]<br><br><span class="hljs-comment">#3.区分训练集和测试集</span><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br>X_train,y_train,X_test,y_test = train_test_split(X,y,test_size=<span class="hljs-number">0.2</span>,random_state=<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">#4.模型搭建</span><br><span class="hljs-keyword">from</span> sklearn.navie_bayes <span class="hljs-keyword">import</span> GaussianNB<br>model = GaussianNB()<br>model.fit(X_train,y_train)<br><br><span class="hljs-comment">#5.模型评估</span><br>y_pred = model.predict(X_test)<br>a = pd.DataFrame()<br>a[<span class="hljs-string">&#x27;预测值&#x27;</span>] = <span class="hljs-built_in">list</span>(y_pred)<br>a[<span class="hljs-string">&#x27;实际值&#x27;</span>] = <span class="hljs-built_in">list</span>(y_test)<br><br><span class="hljs-comment">#获得所有数据</span><br>score = model.score(X_test,y_test)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习--决策树</title>
    <link href="/2022/06/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <url>/2022/06/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>父节点和子节点是相对的，子节点的上边是父节点，父节点的下面是子节点</p><p>根节点：没有父节点的节点叫做根节点，即初始节点</p><p>叶子节点：没有子节点的节点叫做叶子节点，即最终节点</p><span id="more"></span><h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><p>可以做<strong>分类分析（分类决策树模型）</strong>，也可以做<strong>回归分析（回归决策树模型）</strong></p><h4 id="分类决策树模型"><a href="#分类决策树模型" class="headerlink" title="分类决策树模型"></a>分类决策树模型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> DecisionTreeClassifier<br>X = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]]<span class="hljs-comment">#共有5个训练集，每个训练集有2个特征</span><br>y = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<span class="hljs-comment">#这是因变量，分类为1和0</span><br>model = DecisionTreeClassifier(random_state=<span class="hljs-number">0</span>)<span class="hljs-comment">#引入模型并设置随即状态为0，0只是保证运行结果一致</span><br>model.fit(X,y)<span class="hljs-comment">#使用fit训练</span><br><span class="hljs-built_in">print</span>(model.predict([[<span class="hljs-number">5</span>,<span class="hljs-number">5</span>]]))<span class="hljs-comment">#使用predict预测</span><br></code></pre></td></tr></table></figure><h4 id="回归决策树模型"><a href="#回归决策树模型" class="headerlink" title="回归决策树模型"></a>回归决策树模型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> DecisionTreeRegressor<br>X = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]]<br>y = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>model = DecisionTreeRegressor(max_depth=<span class="hljs-number">2</span>,random_state=<span class="hljs-number">0</span>)<br>model.fit(X,y)<br><span class="hljs-built_in">print</span>(model.predict([[<span class="hljs-number">9</span>,<span class="hljs-number">9</span>]]))<br></code></pre></td></tr></table></figure><h3 id="总体决策树模型搭建"><a href="#总体决策树模型搭建" class="headerlink" title="总体决策树模型搭建"></a>总体决策树模型搭建</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#1.数据读取与预处理</span><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>df = pd.read_excel(<span class="hljs-string">&#x27;XX.xlsx&#x27;</span>)<br>df = df.replace(&#123;<span class="hljs-string">&#x27;工资&#x27;</span>:&#123;<span class="hljs-string">&#x27;低&#x27;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;中&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;高&#x27;</span>:<span class="hljs-number">2</span>&#125;&#125;)<br><br><span class="hljs-comment">#2.提取特征变量和目标变量</span><br>X = df.drop(columns=<span class="hljs-string">&#x27;离职&#x27;</span>)<br>y = df[<span class="hljs-string">&#x27;离职&#x27;</span>]<br><br><span class="hljs-comment">#3.划分训练集和测试集</span><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br>X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=<span class="hljs-number">0.2</span>,random_state=<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">#4.训练模型及搭建</span><br><span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> DecisionTreeClassifier<br>model = DecisionTreeClassifier(max_depth=<span class="hljs-number">3</span>,random_state=<span class="hljs-number">1</span>)<br>model.fit(X_train,y_train)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习--逻辑回归</title>
    <link href="/2022/06/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    <url>/2022/06/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<h3 id="Logistic回归"><a href="#Logistic回归" class="headerlink" title="Logistic回归"></a>Logistic回归</h3><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#1.读取数据</span><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>df = pd.read_excel(<span class="hljs-string">&#x27;股票客户流失.xlsx&#x27;</span>)<br><br><span class="hljs-comment">#2.划分特征变量和目标变量</span><br>X = df.drop(columns=<span class="hljs-string">&#x27;是否流失&#x27;</span>)<span class="hljs-comment">#删除是否流失行</span><br>y = df[<span class="hljs-string">&#x27;是否流失&#x27;</span>]<br><br><span class="hljs-comment">#3.划分训练集和测试集</span><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br>X-train,X_test,y_train,y_test = train_test_split(X,y,test_size=<span class="hljs-number">0.2</span>,random_state=<span class="hljs-number">1</span>)<br><span class="hljs-comment">#用train_test_split函数来区分测试集和训练集，test_size是测试集所占的比重，random_state是将其分类，记住就行了。</span><br><br><span class="hljs-comment">#4.模型搭建</span><br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression<br>model = LogisticRegression()<br>model.fit(X_train,y_train)<br><br><span class="hljs-comment">#5.模型使用1：预测数据结果</span><br>y_pred = model.predict(X_test)<br><span class="hljs-built_in">print</span>(y_pred[<span class="hljs-number">0</span>:<span class="hljs-number">100</span>])<span class="hljs-comment">#显示y的预测值中的前一百个数据</span><br><br><span class="hljs-comment">#全部的数据预测</span><br>score = model.score(X_test,y_test)<br><br><span class="hljs-comment">#6.模型使用2：预测概率</span><br>y_pred_proba = model.predict_preba(X_test)<br><span class="hljs-built_in">print</span>(y_pred_proba[<span class="hljs-number">0</span>:<span class="hljs-number">5</span>])<span class="hljs-comment">#打印前五个客户的分类概率</span><br></code></pre></td></tr></table></figure><h3 id="ROC，KS曲线"><a href="#ROC，KS曲线" class="headerlink" title="ROC，KS曲线"></a>ROC，KS曲线</h3><h4 id="ROC"><a href="#ROC" class="headerlink" title="ROC"></a>ROC</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> roc_curve<br>fpr,tpr,thres = roc_curve(y_test,y_pred_proba[:,<span class="hljs-number">1</span>]) <span class="hljs-comment">#fpr:假警报率,tpr:命中率,thres:阈值</span><br><br>a = pd.DataFrame() <span class="hljs-comment">#创建一个空DataFrame</span><br>a[<span class="hljs-string">&#x27;假警报率&#x27;</span>] = <span class="hljs-built_in">list</span>(fpr) <span class="hljs-comment">#用列表的形式将他们表示出来</span><br>a[<span class="hljs-string">&#x27;命中率&#x27;</span>] = <span class="hljs-built_in">list</span>(tpr)<br>a[<span class="hljs-string">&#x27;阈值&#x27;</span>] = <span class="hljs-built_in">list</span>(thres)<br><br><span class="hljs-comment">#开始绘制ROC曲线</span><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>plt.plot(fpr,tpr)<span class="hljs-comment">#折线图</span><br>plt.title(<span class="hljs-string">&#x27;ROC&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;FPR&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;TPR&#x27;</span>)<br>plt.show()<br><br><span class="hljs-comment">#求模型的AUC值</span><br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> roc_auc_score<br>score = roc_auc_score(y_test,y_pred_proba[:,<span class="hljs-number">1</span>])<span class="hljs-comment">#y_pred_proba[:,1]是流失概率</span><br></code></pre></td></tr></table></figure><h4 id="KS"><a href="#KS" class="headerlink" title="KS"></a>KS</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> roc_curve<br>fpr,tpr,thres = roc_curve(y_test,y_pred_proba[:,<span class="hljs-number">1</span>]) <span class="hljs-comment">#fpr:假警报率,tpr:命中率,thres:阈值</span><br><br>a = pd.DataFrame() <span class="hljs-comment">#创建一个空DataFrame</span><br>a[<span class="hljs-string">&#x27;假警报率&#x27;</span>] = <span class="hljs-built_in">list</span>(fpr) <span class="hljs-comment">#用列表的形式将他们表示出来</span><br>a[<span class="hljs-string">&#x27;命中率&#x27;</span>] = <span class="hljs-built_in">list</span>(tpr)<br>a[<span class="hljs-string">&#x27;阈值&#x27;</span>] = <span class="hljs-built_in">list</span>(thres)<br><br><span class="hljs-comment">#绘图</span><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>plt.plot(thres[<span class="hljs-number">1</span>:],tpr[<span class="hljs-number">1</span>:])<br>plt.plot(thres[<span class="hljs-number">1</span>:],fpr[<span class="hljs-number">1</span>:])<br>plt.plot(thres[<span class="hljs-number">1</span>:],tpr[<span class="hljs-number">1</span>:]-fpr[<span class="hljs-number">1</span>:])<br>plt.xlabel(<span class="hljs-string">&#x27;threshold&#x27;</span>)<br>plt.legend([<span class="hljs-string">&#x27;tpr&#x27;</span>,<span class="hljs-string">&#x27;fpr&#x27;</span>,<span class="hljs-string">&#x27;tpr-fpr&#x27;</span>])<span class="hljs-comment">#说明对应的线有什么用</span><br>plt.gca().invert_xaxis()<span class="hljs-comment">#先用gca函数获取坐标轴信息，再使用invert_xaxis函数将x轴反转</span><br>plt.show()<br><span class="hljs-comment">#快速求KS值</span><br><span class="hljs-built_in">max</span>(tpr-fpr)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习--线性回归（重点）</title>
    <link href="/2022/06/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89/"/>
    <url>/2022/06/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#1.读取数据</span><br><span class="hljs-keyword">import</span> pandas<span class="hljs-comment">#导入pandas库</span><br>df = pandas.read_excel(<span class="hljs-string">&#x27;IT行业收入表.xlsx&#x27;</span>) <span class="hljs-comment">#读取excel表，excel表中是有数据的哦</span><br><span class="hljs-built_in">print</span>(df.head())<span class="hljs-comment">#显示df的前五行</span><br>X = df[[<span class="hljs-string">&#x27;工龄&#x27;</span>]]<br><span class="hljs-comment">#如果是多元线性回归则是如下</span><br>X = df[[<span class="hljs-string">&#x27;工龄&#x27;</span>],[<span class="hljs-string">&#x27;姓名&#x27;</span>],[<span class="hljs-string">&#x27;性别&#x27;</span>]]<br>Y = df[<span class="hljs-string">&#x27;薪水&#x27;</span>]<br><br><span class="hljs-comment">#2.模型搭建</span><br><span class="hljs-keyword">from</span> sklean.linear_model <span class="hljs-keyword">import</span> LinearRegression<br>regr = LinearRegression()<span class="hljs-comment">#成为线性回归模型，赋值给regr</span><br>regr.fit(X,Y)<span class="hljs-comment">#训练模型</span><br><br><span class="hljs-comment">#3.模型可视化</span><br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br>plt.scatter(X,Y)<br>plt.plot(X,regr.predict(X))<span class="hljs-comment">#X和X预测值进行线性回归分析</span><br>plt.xlabel(<span class="hljs-string">&#x27;工龄&#x27;</span>)<span class="hljs-comment">#表示x坐标显示工龄</span><br>plt.ylabel(<span class="hljs-string">&#x27;薪水&#x27;</span>)<span class="hljs-comment">#表示y坐标显示薪水</span><br>plt.show()<br><br><span class="hljs-comment">#4.线性回归方程构造</span><br>a = regr.coef_[<span class="hljs-number">0</span>]<span class="hljs-comment">#斜率</span><br>b = regr.intercept_<span class="hljs-comment">#截距</span><br><br><span class="hljs-comment">#结果就是y = ax+b</span><br><br><br><span class="hljs-comment">#线性回归的模型评估</span><br><span class="hljs-keyword">import</span> statsmodels.api <span class="hljs-keyword">as</span> sm<br>X2 = sm.add_constant(X)<span class="hljs-comment">#为特征变量X添加常数项即截距b</span><br>est = sm.OLS(Y,X2).fit()<span class="hljs-comment">#使用OLS和fit函数进行回归方程模型搭建</span><br><span class="hljs-built_in">print</span>(est.summary())<span class="hljs-comment">#将模型打印出来</span><br></code></pre></td></tr></table></figure><h3 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#读取数据</span><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>df = pd.read_excel(<span class="hljs-string">&#x27;XX.xlsx&#x27;</span>)<br><span class="hljs-built_in">print</span>(df.head())<br>X = df[[<span class="hljs-string">&#x27;历史&#x27;</span>],[<span class="hljs-string">&#x27;贷款次数&#x27;</span>],[<span class="hljs-string">&#x27;学历&#x27;</span>],[<span class="hljs-string">&#x27;月收入&#x27;</span>]]<span class="hljs-comment">#这里用了两个方括号</span><br>Y = df[<span class="hljs-string">&#x27;客户价值&#x27;</span>]<span class="hljs-comment">#注意这里只用了一个方括号</span><br><span class="hljs-comment">#模型搭建</span><br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression<br>regr = LinearRegression<br>regr.fit(X,y)<br><span class="hljs-comment">#方程构造</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;各系数:&#x27;</span>+<span class="hljs-built_in">str</span>(regr.coef_)) <span class="hljs-comment">#就是截距的位置</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;常数项:&#x27;</span>+<span class="hljs-built_in">str</span>(regr.intercept_))<span class="hljs-comment">#X前面的系数</span><br><span class="hljs-comment">#模型评估</span><br><span class="hljs-keyword">import</span> statsmodels.api <span class="hljs-keyword">as</span> sm <span class="hljs-comment">#引入相关库</span><br>X2 = sm.add_constant(X)<span class="hljs-comment">#添加常数项X,即截距b</span><br>est = sm.OLS(Y,X2).fit()<br><span class="hljs-built_in">print</span>(est.summary())<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习--列表切片</title>
    <link href="/2022/06/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%88%97%E8%A1%A8%E5%88%87%E7%89%87/"/>
    <url>/2022/06/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%88%97%E8%A1%A8%E5%88%87%E7%89%87/</url>
    
    <content type="html"><![CDATA[<p>只需要列表切片的时候是左闭右开的！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br><span class="hljs-built_in">print</span>(a[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>])<br><span class="hljs-comment">#因为左闭右开，所以打印出来的结果是[1,2]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NFT--MetaMask的创建</title>
    <link href="/2022/06/05/NFT-MetaMask%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
    <url>/2022/06/05/NFT-MetaMask%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="Chrome中的MetaMask钱包的创建"><a href="#Chrome中的MetaMask钱包的创建" class="headerlink" title="Chrome中的MetaMask钱包的创建"></a>Chrome中的MetaMask钱包的创建</h3><span id="more"></span><p>1.先把MetaMask添加到Chrome插件</p><p>2.按照提示设置密码</p><p><img src="/2022/06/05/NFT-MetaMask%E7%9A%84%E5%88%9B%E5%BB%BA/image-20220605164451817.png" alt="image-20220605164451817"></p><p>3.每个账户都会有一个专属的助记词，<strong>请记住你的助记词，很重要</strong></p><p><img src="/2022/06/05/NFT-MetaMask%E7%9A%84%E5%88%9B%E5%BB%BA/image-20220605164617756.png" alt="image-20220605164617756"></p><p>4.为了确保你记住会让你确认一遍</p><p><img src="/2022/06/05/NFT-MetaMask%E7%9A%84%E5%88%9B%E5%BB%BA/image-20220605165616940.png" alt="image-20220605165616940"></p><p>5.完成之后就创建好你的MetaMask账户了！</p><p>6.再登陆Mintable.app网站（用于NFT的购买和售卖）创建账户，和你的Meta Mask账户连接即可进行NFT的购买和售卖。</p>]]></content>
    
    
    <categories>
      
      <category>NFT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NFT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web--将web内容上传服务器</title>
    <link href="/2022/06/03/web--%E5%B0%86web%E5%86%85%E5%AE%B9%E4%B8%8A%E4%BC%A0%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2022/06/03/web--%E5%B0%86web%E5%86%85%E5%AE%B9%E4%B8%8A%E4%BC%A0%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="先上总结"><a href="#先上总结" class="headerlink" title="先上总结"></a>先上总结</h4><p>1.先用原始服务器的实例创建一个ubuntu镜像，记住镜像的账号（root）和密码。<br>2.先使用cmd进行root连接：（ssh <a href="mailto:&#x72;&#x6f;&#x6f;&#x74;&#64;&#49;&#50;&#48;&#46;&#x37;&#55;&#x2e;&#49;&#55;&#46;&#50;&#x31;&#54;">&#x72;&#x6f;&#x6f;&#x74;&#64;&#49;&#50;&#48;&#46;&#x37;&#55;&#x2e;&#49;&#55;&#46;&#50;&#x31;&#54;</a>）当然使用putty或者Xshell同样可以<br>3.使用Xftp7上传对应的web网页到服务器对应的目录中，目录为var\www\html（其中的var目录是和root同级目录）<br>4.上传之后，在浏览器中使用公网的ip即可看到网页。<br>试了一天TT</p><span id="more"></span><h4 id="参考视频，资料"><a href="#参考视频，资料" class="headerlink" title="参考视频，资料"></a>参考视频，资料</h4><p>b站视频：<a href="https://www.bilibili.com/video/BV19g4y1b7F5?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV19g4y1b7F5?spm_id_from=333.337.search-card.all.click</a></p><p>博客园日志：<a href="http://t.zoukankan.com/chrischen98-p-10874821.html%EF%BC%88%E4%B8%8A%E5%8D%88%E4%B8%80%E7%9B%B4%E7%9C%8B%E8%BF%99%E4%B8%AA%EF%BC%8C%E4%BD%86%E6%98%AF%E7%94%A8%E4%BA%86iis%E4%B9%8B%E5%90%8E%E7%BD%91%E9%A1%B5%E4%B8%80%E7%9B%B4%E4%B8%8D%E6%98%BE%E7%A4%BA,%E8%AE%BE%E7%BD%AE%E5%95%A5%E7%AB%AF%E5%8F%A3%E9%83%BD%E6%B2%A1%E7%94%A8%EF%BC%89">http://t.zoukankan.com/chrischen98-p-10874821.html（上午一直看这个，但是用了iis之后网页一直不显示,设置啥端口都没用）</a></p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>html -- 基础</title>
    <link href="/2022/04/14/html-%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/04/14/html-%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--标准格式--&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mate</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><br>    标题 <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>标题1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>标题2<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>        段落1<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>html</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理--存储器</title>
    <link href="/2022/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <url>/2022/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="主存简单模型和寻址概念"><a href="#主存简单模型和寻址概念" class="headerlink" title="主存简单模型和寻址概念"></a>主存简单模型和寻址概念</h2><span id="more"></span><h3 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h3><p>包括<strong>存储体</strong>和<strong>MAR</strong>（Address地址存储器），<strong>MDR</strong>（Data数据存储器）-&gt;地址存储器（存储<strong>传入的</strong>地址）-&gt;存储体（寄存二进制位）&lt;-&gt;数据存储器&lt;-&gt;</p><p><strong>存储元</strong>：是存储器中最小的单位，一个存储元包含着一个二进制位（0/1）</p><h4 id="”读“操作"><a href="#”读“操作" class="headerlink" title="”读“操作"></a>”读“操作</h4><p>从地址存储器出发经过开关元件到数据寄存器</p><p>图中的一行就是一个<strong>存储单元</strong>，一个存储单元中有若干个存储元。而一个存储体是由若干个存储单元构成的。</p><p>就像上面的图片一样，读数据是一个bit一个bit的读的，从左边的第一个1开始，经过开关元件到达上面绿色的线，再由绿色的线传到数据寄存器当中，就完成了一次<strong>读</strong>操作。</p><p><strong>图中绿色的数字称为存储字</strong></p><h4 id="”写“操作"><a href="#”写“操作" class="headerlink" title="”写“操作"></a>”写“操作</h4><p>把数据先存在数据寄存器中，经过开关元件到达地址寄存器</p><h4 id="通过地址确定容量"><a href="#通过地址确定容量" class="headerlink" title="通过地址确定容量"></a>通过地址确定容量</h4><p>n条地址线对应着n位地址代表有2^n个存储单元（也是MAR的表达）。*<em>存储单元个数</em>存储字长=**列数 * 行数</p><h4 id="存储器的结构"><a href="#存储器的结构" class="headerlink" title="存储器的结构"></a>存储器的结构</h4><p><strong>片选线</strong>：整个电路的开关，片选线发出1（高电平）时，电路开，发出0（低电平）时，电路关。<strong>可用CS高电平有效控制线</strong></p><p><strong>读写控制线</strong>：说明本次操作是读还是写，以及什么时候读什么时候写！</p><h4 id="8-8位的存储芯片"><a href="#8-8位的存储芯片" class="headerlink" title="8*8位的存储芯片"></a>8*8位的存储芯片</h4><p><strong>K:2^10    M:2^20    G:2^30    T:2^40</strong></p><p>8K * 8位 = 2^13 * 8bit</p><p>64K * 16位 = 2^16 * 16bit</p><h5 id="1KB-2-10-2-3-2-13-bit"><a href="#1KB-2-10-2-3-2-13-bit" class="headerlink" title="1KB = 2^10 * 2^3 = 2^13 bit"></a>1KB = 2^10 * 2^3 = 2^13 bit</h5><h3 id="拓展：位，字节，字"><a href="#拓展：位，字节，字" class="headerlink" title="拓展：位，字节，字"></a>拓展：位，字节，字</h3><p>位、字节、字是计算机数据存储的单位。位是最小的存储单位，每一个位存储一个1位的二进制码，一个字节由8位组成。而字通常为16、32或64个位组成。</p><h3 id="按字节寻址和按字寻址"><a href="#按字节寻址和按字寻址" class="headerlink" title="按字节寻址和按字寻址"></a>按字节寻址和按字寻址</h3><p>总容量为1KB，32位的处理器。</p><p><strong>按字节（Byte）寻址：</strong>1K个单元，每个单元1B</p><p><strong>按字寻址：</strong>把一个存储单元看成一个整体，而一个存储单元是4B，所以有256个单元，每个单元4B。</p><p><strong>按半字寻址：</strong>有512个单元，每个单元2B。</p><p><strong>按双字寻址：</strong>有128个单元，每个单元8B。</p><p><strong>字地址：</strong>每个存储单元开头的数据的地址。</p><h3 id="多字节存放：大小端方式"><a href="#多字节存放：大小端方式" class="headerlink" title="多字节存放：大小端方式"></a>多字节存放：大小端方式</h3><p><strong>来自百度：采用大小模式对数据进行存放的主要区别在于在存放的字节顺序，大端方式将高位存放在低地址，小端方式将高位存放在高地址。采用大端方式进行数据存放符合人类的正常思维，而采用小端方式进行数据存放利于计算机处理。</strong></p><p>大端方式：12 34 56 78 <strong>从高位到低位</strong></p><p>小端方式：78 56 34 12 <strong>从低位到高位</strong></p><h2 id="半导体存储器RAM–易失性"><a href="#半导体存储器RAM–易失性" class="headerlink" title="半导体存储器RAM–易失性"></a>半导体存储器RAM–易失性</h2><h3 id="半导体存储芯片的基本结构"><a href="#半导体存储芯片的基本结构" class="headerlink" title="半导体存储芯片的基本结构"></a>半导体存储芯片的基本结构</h3><p>1.存储矩阵：由大量相同的位存储单元列阵构成</p><p>2.译码驱动：将来自地址总线的<strong>地址信号</strong>翻译成对应存储单元的选通信号，该信号在读写电路的配合下完成对被选中电路的读写操作。</p><p>3.读写电路：包括读出放大器和写入电路，用来完成读写操作</p><p>4.读写控制线：决定芯片进行读写操作。</p><p>5.片选线：<strong>相当于芯片的开关，</strong>确定哪个存储芯片被选中，可以用于容量扩充。</p><p>6.地址线：单向输入，其位数与存储字的个数有关。<strong>一个地址线代表一个二进制位，有n条地址线就有n个存储单元</strong></p><p>7.数据线：是双向的，位数与读出或写入的数据位数有关。<strong>有n条数据线就有n个数据位。</strong> </p><p>8.数据线和地址线数共同反映存储芯片容量的大小。</p><p>​    如地址线10跟，数据线8根，芯片容量=2^10 * 8 = 8K位 </p><h3 id="半导体随机存取存储器"><a href="#半导体随机存取存储器" class="headerlink" title="半导体随机存取存储器"></a>半导体随机存取存储器</h3><h4 id="随机存取存储器"><a href="#随机存取存储器" class="headerlink" title="随机存取存储器"></a>随机存取存储器</h4><p>存取数据的速度之取决于电流流动的速度，与物理元件所在的位置没有关系。</p><h3 id="两种随机存储器"><a href="#两种随机存储器" class="headerlink" title="两种随机存储器"></a>两种随机存储器</h3><p><strong>SRAM（Static Random Access Memory）静态随机存储器</strong></p><p>存储信息使用触发器（能保持两种稳定的状态）</p><p>读：查看触发器状态；写：改变触发器状态</p><p><strong>DRAM（Dynamic Random Access Memory）动态随机存储器</strong></p><p>存储信息使用电容（需要充放电）</p><p>读：连接电容，检测电流变化</p><p>写：给电容充放电。</p><p>电容上的电荷只能维持2ms</p><p>这两个存储器都需要有电，如果断电了就会丢失信息，因此也称其为易失性存储器。</p><h3 id="DRAM的刷新"><a href="#DRAM的刷新" class="headerlink" title="DRAM的刷新"></a>DRAM的刷新</h3><p>2ms刷新一次</p><p>每次刷新一行存储单元</p><p>如何刷新？    有硬件支持，读出一行的信息后重新输入，占用1个读写周期</p><p>在什么时刻进行刷新？    </p><h3 id="DRAM中的行列地址复用"><a href="#DRAM中的行列地址复用" class="headerlink" title="DRAM中的行列地址复用"></a>DRAM中的行列地址复用</h3><p><strong>假设你的存储器容量是16bit，那么可以将这16个比特组织成一个4*4的矩阵，为了找到某个你想要找的bit，比如第1行第2列的那个bit。你先发送二进制的01，表示要找的数据在第1行；接着发送二进制的10，表示要找的数据在第2列。这样一来你就找到了第1行第2列的那个bit。可以发现只要两根地址线就能寻找16个bit了，但是要发送两次地址（一次行地址，一次列地址）‍</strong></p><p>DRAM 普遍采用的是行与列地址分时复用技术进行寻址。在 DRAM 的矩阵存储单元中，地址可以分成行地址和列地址。在寻址时，必须先进行行寻址然后在进行列寻址，这是由 DRAM 的硬件电路所决定的。所以，对行地址线和列地址线进行共用，传送时只需要一半地址，先传送至缓冲区，再传送给译码器即可。既节省了地址线，也不会降低 DRAM 原有的工作速率（因为 DRAM 的行地址和列地址就是要分时传送的）。</p><p>如果是 SRAM 采用这种寻址方式的话，则会大大降低其工作速度。Cache多为SRAM，存储单元是线性排列，不像DRAM那样分行列，所以不适用行列地址线复用方式。不过说到底是因为Cache就是为了快才存在的，容量又小，所以SRAM也用得起。</p><h3 id="SRAM时序"><a href="#SRAM时序" class="headerlink" title="SRAM时序"></a>SRAM时序</h3><p>百度</p><h2 id="半导体存储器ROM（Read-Only-Memory）–非易失性"><a href="#半导体存储器ROM（Read-Only-Memory）–非易失性" class="headerlink" title="半导体存储器ROM（Read-Only Memory）–非易失性"></a>半导体存储器ROM（Read-Only Memory）–非易失性</h2><p>指令和数据会存储在主存储器中，CPU中的运算器和控制器会对指令的指示进行下一步的操作。</p><h3 id="CPU的任务"><a href="#CPU的任务" class="headerlink" title="CPU的任务"></a>CPU的任务</h3><p>到主存中取指令；</p><p>按指令的指示进行下一步操作</p><h3 id="ROM的优势"><a href="#ROM的优势" class="headerlink" title="ROM的优势"></a>ROM的优势</h3><p>断电后不丢失数据。</p><p>因此ROM负责存放一些开机之后的必要信息，不至于丢失；而程序中的信息比较详细的就放在RAM中</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><strong>掩膜式只读存储器（MROM）</strong>：存储内容由半导体制造厂按用户提出的要求在芯片的生产过程中直接写入，无法修改。</p><p><strong>一次可编程只读存储器（PROM）</strong>：内容由用户通过专门的设备一次性写入，写入后无法修改！</p><p><strong>可擦除可编程只读存储器（EPROM）</strong>：紫外线擦除，电擦除</p><p><strong>闪速存储器（Flash Memory）：</strong>如U盘，写入速度较快</p><p><strong>固态硬盘（Solid State Drives）</strong></p><h2 id="存储器的基本概念"><a href="#存储器的基本概念" class="headerlink" title="存储器的基本概念"></a>存储器的基本概念</h2><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><p><img src="/2022/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AD%98%E5%82%A8%E5%99%A8/image-20220407203824780.png" alt="image-20220407203824780"></p><p>存储器的功能：存放二进制信息。</p><p><strong>不同的材料：</strong></p><p><strong>1.磁表面存储器：磁盘，磁带</strong></p><p><strong>2.磁芯存储器</strong></p><p><strong>3.半导体存储器（体积小）</strong></p><p><strong>4.光存储器</strong></p><p><img src="/2022/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AD%98%E5%82%A8%E5%99%A8/image-20220407205005959.png" alt="image-20220407205005959"></p><h3 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h3><p><strong>容量和速度重要，需要掌握计算方法</strong></p><p><img src="/2022/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AD%98%E5%82%A8%E5%99%A8/image-20220407205342224.png" alt="image-20220407205342224"></p><h3 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h3><p><img src="/2022/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AD%98%E5%82%A8%E5%99%A8/image-20220407205558685.png" alt="image-20220407205558685"></p><h2 id="CPU和存储之间的传递"><a href="#CPU和存储之间的传递" class="headerlink" title="CPU和存储之间的传递"></a>CPU和存储之间的传递</h2><p><img src="/2022/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AD%98%E5%82%A8%E5%99%A8/image-20220407210942248.png" alt="image-20220407210942248"></p><p>A：地址线</p><p>D：数据线</p><p>通过A0到A15传递地址，通过WE传递</p><p><strong>因为一个芯片只有一个数据端口，要把CPU上的8条数据线全部传到芯片中，则需要同时连接8个芯片！</strong></p><p><img src="/2022/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AD%98%E5%82%A8%E5%99%A8/image-20220407211604968.png" alt="image-20220407211604968"></p><p>当一个CPU同时连接多个芯片的时候，<strong>不能让他们同时工作</strong>，同时工作的话，输出的数据信息使得CPU无法区分。解决方法就是：<strong>让CPU中多出来的地址线控制芯片中的片选线，如A13控制CS1，A14控制CS2等等！</strong></p><p><strong>那么此时在第一个芯片的地址中A14，A13分别是01；第二个芯片中A14，A13分别是10.</strong></p><h2 id="主存和CPU之间"><a href="#主存和CPU之间" class="headerlink" title="主存和CPU之间"></a>主存和CPU之间</h2><h3 id="存储器芯片的结构"><a href="#存储器芯片的结构" class="headerlink" title="存储器芯片的结构"></a>存储器芯片的结构</h3><p><img src="/2022/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%AD%98%E5%82%A8%E5%99%A8/Users/me/AppData/Roaming/Typora/typora-user-images/image-20220629200220305.png" alt="image-20220629200220305"></p><p>1.片选线的作用：当接收到<strong>高电平（1信号）</strong>的时候，整个芯片处于<strong>工作</strong>的状态，同理当接收到<strong>低电平（0）</strong>时候处于<strong>不工作</strong>的状态</p><p>2.读写控制线的作用：来控制整个芯片是读还是写。</p><p>3.数据线：将芯片内的数据和外部的数据进行交流</p><p>4.地址线：外部传输到存储器的地址信号 </p><h3 id="王道书总结"><a href="#王道书总结" class="headerlink" title="王道书总结"></a>王道书总结</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>1.随机存储方式：RAM，ROM；顺序存储方式：磁带；直接存储方式：磁盘，光盘。</p><p>2.存储器的存储周期是：存储器连续进行读或写操作是所允许的最短时间间隔。</p><p>3.半字查找，如字长为32bit即4B，那么半字就是4/2=2B</p><p>4.存储容量 = 字长*存储字数</p><p>5.1s = 10^9 ns = 10^6 微秒 = 10^3 ms</p><p>6.相联存储器：选取存储器中符合条件进行检索，并将其读出或者写入</p><p>7.CPU不能直接读取硬盘中的内容，要把内容写入主存中才可以读取</p><p>8.存储器中读取速度有快到慢为：寄存器，Cache，主存，辅存。</p><p>9.CD-ROM是光盘，属于直接存储器，不属于顺序存储器。</p><hr><p>1.某存储器容量为1024<em>8bit 那么地址线10根，数据线8根，*<em>如果采用地址复用技术，那么地址线的根数减少一半！！！</em></em></p><p>2.RAM中不存在死时间的刷新技术是分散刷新（分两部分，一部分读写一部分刷新），而异步刷新只是缩短了死时间而不是没有死时间。</p><p>3.Cache是SRAM构成的。</p><p>4.U盘属于高速缓存的存储器。</p><p>5.访存冲突的条件是相邻并且地址相同。</p><p>6.EPROM可以多次改写，但是改写的过程繁琐，所以不能作为随机存储器</p>]]></content>
    
    
    <categories>
      
      <category>计组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理--算数逻辑单元ALU</title>
    <link href="/2022/04/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AE%97%E6%95%B0%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83ALU/"/>
    <url>/2022/04/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AE%97%E6%95%B0%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83ALU/</url>
    
    <content type="html"><![CDATA[<h2 id="ALU实现"><a href="#ALU实现" class="headerlink" title="ALU实现"></a>ALU实现</h2><span id="more"></span><p>1.算数运算：加减乘除</p><p>2.逻辑运算：与或非，异或等</p><p>3.辅助功能：移位，求补等</p><p><img src="/2022/04/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AE%97%E6%95%B0%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83ALU/01.png" alt="01"></p><p>右边的S和M是来自控制单元（CU）的，当M=1时逻辑运算，M=0时算数运算 . </p><h2 id="基本的逻辑运算"><a href="#基本的逻辑运算" class="headerlink" title="基本的逻辑运算"></a>基本的逻辑运算</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>1.与 = &amp;&amp; ：Y = A*B</p><p>2.或 = || ：Y = A+B</p><p>3.非=! ：Y = A(ba)</p><p><img src="/2022/04/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AE%97%E6%95%B0%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83ALU/02.png" alt="02"></p><p>注意图中的尖角的是或门，圆角的是与门，后面加上个小圆点的就是非门！</p><p><strong>高电位代表二进制的1，低电位代表二进制的0</strong></p><p><strong>1.与门：当两个输入都为高电位（1）时，输出才会是高电位。</strong></p><p><strong>2.或门：当两个输入都为低电位（0）时，输出才会是低电位。</strong></p><p><strong>3.非门：输入是0输出1，输入是1输出0.</strong></p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>与&gt;或</p><p>例：AB+CD是先将AB进行<strong>与</strong>运算，再将CD进行<strong>与</strong>运算，最后将两者的结果进行或运算。 </p><h3 id="复合逻辑"><a href="#复合逻辑" class="headerlink" title="复合逻辑"></a>复合逻辑</h3><p>1.与非：先与再非。电路表示是在圆角后面加个小圆点。</p><p>2.或非：先或再非。电路表示是在尖角后面加个小圆点。</p><p>3.异或：不同取1，同取0，异或的电路表达如下图所示 。</p><p><img src="/2022/04/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AE%97%E6%95%B0%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83ALU/03.png" alt="03"></p><p>4.同或：是异或的取反，相同取1，不同取1</p><h3 id="用门电路求偶校验位"><a href="#用门电路求偶校验位" class="headerlink" title="用门电路求偶校验位"></a>用门电路求偶校验位</h3><p>1001101 = 0</p><p>（（1异或0）异或（0异或1）异或（1异或0）异或1） = 0 </p><p>如果输入的有偶数个1，那么结果是0；如果输入的有奇数个1，那么结果就是1</p><p><img src="/2022/04/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AE%97%E6%95%B0%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83ALU/04.png" alt="04"></p><h3 id="一位全加器-（FA：Full-Add）"><a href="#一位全加器-（FA：Full-Add）" class="headerlink" title="一位全加器 （FA：Full Add）"></a>一位全加器 （FA：Full Add）</h3><h4 id="符号表示"><a href="#符号表示" class="headerlink" title="符号表示"></a>符号表示</h4><p>Ai表示被加数，i表示被加数的第i位</p><p>Bi表示加数，i表示加数的第i位</p><p>Ci-1表示进位数，i-1表示第i-1为进位数</p><p>Si表示本位的和。</p><p><strong>综上就是：Ai+Bi=Si，而Ci-1是进位！</strong></p><p>Si：输入中有奇数个1时为1（异或）</p><p>Si = Ai异或Bi异或Ci-1</p><p><strong>Ci是否等于1：Ci = AiBi + (Ai异或Bi)Ci-1</strong></p><p><strong>解释上面：AiBi是两个输入都为1，(Ai异或Bi)Ci-1是输入中有一个为1，进位为1</strong></p><p><img src="/2022/04/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AE%97%E6%95%B0%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83ALU/05.png" alt="05"></p><h3 id="串行加法器"><a href="#串行加法器" class="headerlink" title="串行加法器"></a>串行加法器</h3><p>只有一个加法器，数据逐位送入加法器中运算，进位触发器用来寄存进位信号，以便下一次的运算</p><p>如果操作数长度为n，那么就要分n次进行，每次产生一位和，并且串行逐位的送回寄存器 </p><h3 id="串位进行的并行加法器"><a href="#串位进行的并行加法器" class="headerlink" title="串位进行的并行加法器"></a>串位进行的并行加法器</h3><p>把n个全加器串接起来，可进行两个n位数的相加。</p><p>就是A1和B1进行相加产生了C1这个进位，那么A2和B2的相加又要依靠C1.即每一级进位直接依赖于前一级的进位，即进位信号是逐级形成的。</p><p><strong>效率很低T T</strong></p><p><img src="/2022/04/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AE%97%E6%95%B0%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83ALU/06.png" alt="06"></p><h3 id="并行进位的并行加法器（串行进位的优化版本）"><a href="#并行进位的并行加法器（串行进位的优化版本）" class="headerlink" title="并行进位的并行加法器（串行进位的优化版本）"></a>并行进位的并行加法器（串行进位的优化版本）</h3><p>各级信号同时形成，又称为先行进位，同时进位。</p><p><strong>最多支持4个FA</strong> </p>]]></content>
    
    
    <categories>
      
      <category>计组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理--数、码</title>
    <link href="/2022/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%95%B0%E3%80%81%E7%A0%81/"/>
    <url>/2022/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%95%B0%E3%80%81%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="定点数（考试重点）"><a href="#定点数（考试重点）" class="headerlink" title="定点数（考试重点）"></a>定点数（考试重点）</h2><p>定点数：小数点的位置不变</p><p>浮点数：小数点的位置会改变</p><span id="more"></span><h3 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h3><p>定义：整个机器的全部二进制位全部是数值位，没有符号位。相当于数的绝对值。</p><h3 id="有符号数"><a href="#有符号数" class="headerlink" title="有符号数"></a>有符号数</h3><h4 id="定点整数"><a href="#定点整数" class="headerlink" title="定点整数"></a>定点整数</h4><p>小数点在最后</p><h4 id="定点小数"><a href="#定点小数" class="headerlink" title="定点小数"></a>定点小数</h4><p>小数点紧跟在符号位的后面。</p><p><strong>由此我们可以知道，如果要保存一个定点数，需要定点整数和定点小数分开保存</strong></p><p>可以用<strong>原码，反码，补码来表示</strong>定点正数和定点小数，可以用移码表示定点整数</p><p><strong>尾数：用来表示整数或者小数的数值部分的二进制位称为尾数。若机器的字长为n+1,那么尾数占n位</strong></p><h4 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h4><p>用尾数表示真值的绝对值，0表示+，1表示-</p><h5 id="表示定点整数-使用逗号"><a href="#表示定点整数-使用逗号" class="headerlink" title="表示定点整数(使用逗号)"></a>表示定点整数(使用逗号)</h5><p>[x]原：1,10111100</p><p><strong>重点：若机器字长为n+1位，原码整数的表示范围是-(2^n -1)~(2^n - 1)，因为真值0分为+0和-0两种，所以两个不同的二进制位表示一种状态，因此要减一</strong></p><h5 id="表示定点小数（使用小数点）"><a href="#表示定点小数（使用小数点）" class="headerlink" title="表示定点小数（使用小数点）"></a>表示定点小数（使用小数点）</h5><p>容易混淆的定点小数的表示方法：[x]原：1.1100000    实际上这个表示的是 - 0.11，前面的1代表的是负号。</p><p>若计算机字长为n+1位，原码小数的表示范围是-（1-2^-n）~ (1-2^-n)</p><h4 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h4><p>若为正数，则反码与原码相同；</p><p>若为负数，则数值位全部取反。</p><p>例子：<br>[x]原：1,0111000</p><p>[x]反：1,1000111</p><p>反码中小数的取值范围和原码是相同的</p><p>整数范围是-2^n ~ 2^n - 1</p><h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><p>正数的补码 = 原码</p><p>负数的补码 = 反码末位+1（要考虑到进位问题）</p><p>注意：补码的真值0只有一种表示形式</p><p>定点整数补码，[x]补 = 1，0000000，表示-2^7</p><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p>通过x的补码求-x的补码：符号位全部取反，再在末位加一</p><h4 id="补码转原码"><a href="#补码转原码" class="headerlink" title="补码转原码"></a>补码转原码</h4><p>方法和原码转补码的方法一样，都是<strong>取反之后加一（不是加一后取反）</strong></p><p><strong>即：补码的补码是原码</strong></p><h4 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h4><p>在补码的基础上将符号位取反</p><p><strong>移码只能用于表示整数</strong></p><p>移码可以方便计算机判断哪个值更大</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>综上，我们只有在看到符号位是1的才需要进行反码原码的操作，0的反码和补码都是它本身</p><h2 id="原码补码移码的作用"><a href="#原码补码移码的作用" class="headerlink" title="原码补码移码的作用"></a>原码补码移码的作用</h2><h3 id="补码的作用"><a href="#补码的作用" class="headerlink" title="补码的作用"></a>补码的作用</h3><h4 id="带余除法"><a href="#带余除法" class="headerlink" title="带余除法"></a>带余除法</h4><p>如 x mod m = r .</p><p>实际是x = qm + r（其中q是整数，r是余数）</p><p>mod 12 把所有数分成了12类（余数相同的是一类）同一类数都是等价的，即1+0和1+12和1+24都是等效的！！</p><p>同一类数<strong>（如1和13和25）</strong>之间互为补数，两者的绝对值之和为模数<strong>（12）</strong></p><p><strong>重点公式：模-a的绝对值=a的补数</strong>（如12-|-3| = 9）</p><h5 id="计算机中的应用"><a href="#计算机中的应用" class="headerlink" title="计算机中的应用"></a>计算机中的应用</h5><p>计算机中的模是2的八次方，任何一个数想要求补码就拿2的八次方减去该数绝对值即可，但是有了补码就可以用上面的重点公式来算了，十分方便，因此可以总结出：<br><strong>补码的作用是：让减法操作转变为加法操作，节省计算机硬件的成本！</strong></p><p>使得ALU算术逻辑单元中只需要设计加法相关的电路而不需要设计减法电路，非常的银杏化！</p><p>执行加法操作的时候，符号位会一起参与运算！</p><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="移位运算（-）"><a href="#移位运算（-）" class="headerlink" title="移位运算（*）"></a>移位运算（*）</h3><p>移位：通过改变各个数码位和小数点的相对位置，从而改变各个数码位的位权，可以用移位运算实现乘法，除法。</p><h4 id="算术移位（符号位保持不变，数值位移动）"><a href="#算术移位（符号位保持不变，数值位移动）" class="headerlink" title="算术移位（符号位保持不变，数值位移动）"></a>算术移位（符号位保持不变，数值位移动）</h4><p>因为定点数的小数点位置是不变的，那我们可以改变数的位置，各个数的位权发生改变。</p><p>如110011.000向右移一位变成：11001.100。这时，前数除2的一次方即可得到后数。</p><p>110011.000向左移一位变成：1100110.000，这时前数乘以2的一次方即可得到后数。</p><p>110011.000向左移两位变成：11001100.000，这时前数乘以2的二次方即可得到后数。</p><p><strong>右移：高位补零，低位（小数点后的位数）舍弃，如果舍弃的位数等于0，那么除2，如果舍弃的位数不等于0，那么会丢失精度。</strong></p><p><strong>左移：低位补零，高位舍弃，若舍弃位=0，相当于*2，若舍弃位！=0，会出现严重误差（因为最高位只能表示到(2^8)-1）</strong></p><h5 id="反码的算术移位"><a href="#反码的算术移位" class="headerlink" title="反码的算术移位"></a>反码的算术移位</h5><p><strong>正数：</strong>因为正数的反码与原码相同，因此正数反码的算术移位也和原码相同！</p><p><strong>负数：</strong>负数的算术移位与原码相反，左移在低位补1，右移在高位补1.</p><h5 id="补码的算术移位"><a href="#补码的算术移位" class="headerlink" title="补码的算术移位"></a>补码的算术移位</h5><p><strong>正数：算术移位与原码相同</strong></p><p><strong>负数移位的前提：在负数的补码中，补码最右边的1（包括自己）的右边与原码一致，最右边的1的左边与反码一致·</strong></p><p><strong>负数：右移，高位补1，左移，低位补0.</strong></p><h5 id="计算机中的表达"><a href="#计算机中的表达" class="headerlink" title="计算机中的表达"></a>计算机中的表达</h5><p>例如-20*7，我们可以把7看成（2^0 + 2^1 + 2^2）,所以就是-20 * （2^0 + 2^1 + 2^2），计算机就判断把-20的二进制形式左移或者右移几位就行了！</p><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><h5 id="正数：全补0；"><a href="#正数：全补0；" class="headerlink" title="正数：全补0；"></a>正数：全补0；</h5><p><strong>负数：原码补0，反码补1，补码左0右1</strong></p><h4 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h4><p>不需要考虑别的，<strong>相当于对无符号数的算数移位</strong></p><p>逻辑左移：高位补0，低位舍弃</p><p>逻辑右移：低位补0，高位舍弃</p><h4 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h4><p>左移时移出来的数放在最后！</p><p>右移时移出来的数放在最前！</p><h4 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h4><p><strong>进位位</strong>：如果我们把两个二进制数相加了结果大于8bit，那么多出来的那一位数就称为<strong>进位位</strong></p><p>进位位的循环移位：左移时会把进位位的数放在原数的最后，把原数最前面的数放在进位位里面！</p><h3 id="加减运算"><a href="#加减运算" class="headerlink" title="加减运算"></a>加减运算</h3><h4 id="原码的加减法"><a href="#原码的加减法" class="headerlink" title="原码的加减法"></a>原码的加减法</h4><h5 id="原码的加法运算"><a href="#原码的加法运算" class="headerlink" title="原码的加法运算"></a>原码的加法运算</h5><p>正+正=绝对值做加法，结果为正！</p><p>负+负=绝对值做减法，结果为负！</p><p>正+负=绝对值大的减绝对值小的，符号同绝对值大的数</p><h5 id="原码的减法运算（减数符号取反变成加法）"><a href="#原码的减法运算（减数符号取反变成加法）" class="headerlink" title="原码的减法运算（减数符号取反变成加法）"></a>原码的减法运算（减数符号取反变成加法）</h5><p>正-负 = 正+正</p><p>正-正 = 正+负</p><p>负-正 = 负+负</p><p>负-负 = 负+正</p><h4 id="补码的加减法（常用）"><a href="#补码的加减法（常用）" class="headerlink" title="补码的加减法（常用）"></a>补码的加减法（常用）</h4><p>[A+B]补 = [A]补+[B]补</p><p>[A-B]补 = [A]补 + [-B]补（其中用B补求-B补是符号位数值位全部取反，然后加一）</p><h4 id="溢出计算"><a href="#溢出计算" class="headerlink" title="溢出计算"></a>溢出计算</h4><h5 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h5><p><strong>只有正数+正数才会上溢</strong></p><p><strong>只有负数+负数才会下溢</strong></p><p>V = ABS(ba) + A(ba)B(ba)S        其中A是第一个数的符号，B是第二个数的符号，S是结果的符号，（ba）是一霸，取反的意思，他们之间用与（&amp;&amp;）连接，加号表示或！</p><p><strong>若V = 0,无溢出</strong></p><p><strong>若V = 1，有溢出</strong> </p><h5 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h5><p><strong>上溢：符号位的进位为0（进位到进位位），最高数值位进位为1（进位到符号位）</strong></p><p><strong>下溢：符号位的进位为1（进位到进位位），最高数值位进位为0（进位到符号位）</strong></p><p>将符号位进位和数值位进位进行异或运算，结果是1说明有溢出，结果是0说明无溢出</p><h5 id="方法3（考点）"><a href="#方法3（考点）" class="headerlink" title="方法3（考点）"></a>方法3（考点）</h5><p>采用双符号位</p><p>正数的符号为00，负数的符号位为11.</p><p>记两个符号位分别为S1，S2，V = S1 异或 S2</p><p>若V=0，则无溢出；若V=1，则有溢出</p><p><strong>双符号位补码称为模4补码</strong></p><p><strong>单符号位补码称为模2补码</strong></p><h4 id="符号拓展"><a href="#符号拓展" class="headerlink" title="符号拓展"></a>符号拓展</h4><h5 id="整数拓展"><a href="#整数拓展" class="headerlink" title="整数拓展"></a>整数拓展</h5><h6 id="正整数"><a href="#正整数" class="headerlink" title="正整数"></a>正整数</h6><p>8bit -&gt; 16bit</p><p>0,1011010 -&gt; 0,000000001011010    即在符号位和数值位之间加上若干个0</p><h6 id="负整数"><a href="#负整数" class="headerlink" title="负整数"></a>负整数</h6><p>原码：0,1011010 -&gt; 0,000000001011010</p><p>反码：0,1011010 -&gt; 0,111111111011010    添1</p><p>补码：0,1011010 -&gt; 0,111111111011011     添1后+1    </p><h5 id="小数拓展"><a href="#小数拓展" class="headerlink" title="小数拓展"></a>小数拓展</h5><h6 id="正小数"><a href="#正小数" class="headerlink" title="正小数"></a>正小数</h6><p>原码反码补码都一样</p><p>0.10010001 -&gt; 0.10010001 00000000    在后面添加0才能保证各个数的位权不变。</p><h6 id="负小数"><a href="#负小数" class="headerlink" title="负小数"></a>负小数</h6><p>原码：0.10010001 -&gt; 0.10010001 00000000    同样在后面添加0</p><p>反码：0.10010001 -&gt; 0.01101110 11111111    把0变成1</p><p>补码：0.10010001 -&gt; 0.01101111 00000000     在反码的基础上+1</p><h3 id="乘法运算"><a href="#乘法运算" class="headerlink" title="乘法运算"></a>乘法运算</h3><p><a href="https://www.bilibili.com/video/BV1BE411D7ii?p=18&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1BE411D7ii?p=18&amp;spm_id_from=pageDriver</a></p><h4 id="原码乘法（逻辑右移）"><a href="#原码乘法（逻辑右移）" class="headerlink" title="原码乘法（逻辑右移）"></a>原码乘法（逻辑右移）</h4><h5 id="符号位"><a href="#符号位" class="headerlink" title="符号位"></a>符号位</h5><p>符号位单独处理，两个符号位进行异或操作，符号相同返回0，不同返回1</p><h5 id="数值位"><a href="#数值位" class="headerlink" title="数值位"></a>数值位</h5><h6 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h6><p>ACC存放乘积高位，MQ存放乘积低位和乘数，X存放被乘数</p><h6 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h6><p>先加法再移位，重复n次。</p><p>第一步：</p><p>从MQ中的最低位（最右边）开始：<strong>如果当前位为1，则ACC加上被乘数（通过ALU进行），如果当前位为0，则ACC加上0</strong></p><p>第二步：<br>ACC和MQ看成一条线，将ACC进行逻辑右移（高位补0），则ACC的第一位就移到了MQ的最后一位，那么MQ的第一位就丢掉了。</p><p>第三步：</p><p>算到乘数的符号位（即MQ中的最后一位）是不参与运算的！！</p><p>第四步：</p><p>使用异或处理符号位</p><p>第五步：<br>小数点隐藏在符号位的后面，ACC和MQ中的值放在一起就是最后的结果了</p><h6 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h6><p><img src="/2022/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%95%B0%E3%80%81%E7%A0%81/image-20220330115915831.png" alt="image-20220330115915831"></p><h4 id="补码乘法（算术右移）"><a href="#补码乘法（算术右移）" class="headerlink" title="补码乘法（算术右移）"></a>补码乘法（算术右移）</h4><p>同样进行n轮加法，每次加法内容可能加0，可能加x的补码，也可能加-x的补码</p><p><strong>辅助位-MQ中最低位=1时，（ACC）+[x]补</strong></p><p><strong>辅助位-MQ中最低位=0时，（ACC）+0</strong></p><p><strong>辅助位-MQ中最低位=-1时，（ACC）+[-x]补</strong></p><p><strong>每次位移都是“补码的算数右移”</strong></p><h5 id="辅助位"><a href="#辅助位" class="headerlink" title="辅助位"></a>辅助位</h5><p>所谓辅助位就是在MQ最低位的后面加一位称为辅助位，辅助位初始为0，进行一次乘法操作后MQ最低位的值会移至辅助位。</p><p>最后当MQ的最低位是乘数的符号位时，ACC还要再加一次补码，结果和上一个式子的后半部分（低位）拼接起来即可。 </p><h3 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h3><h4 id="原码除法：恢复余数法"><a href="#原码除法：恢复余数法" class="headerlink" title="原码除法：恢复余数法"></a>原码除法：恢复余数法</h4><p><a href="https://www.bilibili.com/video/BV1BE411D7ii?p=20">https://www.bilibili.com/video/BV1BE411D7ii?p=20</a></p><p>先明白一个原理：任何<strong>一位</strong>余数乘除数都等于对应的乘积</p><p>符号位单独处理：x和y进行异或</p><p><strong>被除数 / |除数|=新余数</strong></p><p>例题：求x/y</p><p><strong>第一步：</strong><br>将商放在MQ中（默认第一位是1），将被除数和余数放在ACC中，将除数放在X中</p><p><strong>第二步：</strong></p><p>写出x和y的绝对值，y绝对值的补码，y绝对值取负数的补码。</p><p><strong>x中存放的除数是y的绝对值，进行减法操作时加上-y的绝对值，进行加法操作时加上y的绝对值</strong></p><p><strong>第三 步：</strong></p><p><strong>计算机默认商1，商1的结果放在MQ的第一位，执行ACC（被除数）-x（除数）的操作。 但是这时候如果ACC-x的结果的符号位为1，说明MQ商1是错的，会变成商0，并且把ACC中的值恢复原样ACC（被除数）+x（除数）-&gt; ACC！！</strong></p><p><strong>第四步：</strong></p><p>将余数结果和MQ（商）看成一个整体进行逻辑左移（低位补0）</p><p>小数点放在ACC的倒数第一位和第二位之间</p><p><strong>总结：</strong></p><p>直接加（-y的绝对值）看结果是正数还是负数（0还是1），负数商0，然后恢复余数，正数商1，然后逻辑左移一位。</p><p>若余数为负，可以直接商0，并让余数左移一位再<strong>加上除数</strong>（其实加上除数这一步就已经是下一步默认商1之后的加-y的绝对值了）</p><p>最后一次上商逻辑不左移。</p><p>如果最后一次的余数为负，那么还是需要恢复余数的。</p><h4 id="补码除法"><a href="#补码除法" class="headerlink" title="补码除法"></a>补码除法</h4><p><strong>要点：</strong></p><p>符号位参与运算</p><p>被除数，余数，除数采用双符号位（00表示正，11表示负，01 10 表示溢出）</p><p><strong>第一步：</strong></p><p>判断余数是否与除数同号？</p><p>被除数和除数同号：</p><p>商1，左移一位，<strong>被除数 - 除数 = 新余数</strong></p><p>被除数和除数异号：</p><p>商0，先左移一位，<strong>被除数+除数 = 新余数</strong></p><p><strong>第二步：</strong></p><p>末位商恒置为1</p><p><strong>总结：</strong></p><p><strong>加减n+1次，每次加减确定一位商，左移n次（最后一次减完不移位 ）</strong></p><p><img src="/2022/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%95%B0%E3%80%81%E7%A0%81/image-20220331201635487.png" alt="image-20220331201635487"></p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>C语言中定点整数是用补码存储的</p><p>short ;</p><p>unsigned short y = (unsigned short)x;</p><p><strong>这时y是无符号short，x是有符号short</strong></p><p>假设x的二进制形式为x = 1,110110     其中最后一个1是符号位。</p><p>转化为y后y = 1110110    这时x的符号位变成了y的数值位！</p><h4 id="高转低"><a href="#高转低" class="headerlink" title="高转低"></a>高转低</h4><p>int a = 12345,b = 54321;</p><p>short c = (short)a,d = (short)b</p><p><strong>高转低非常的暴力,直接截断,只保留低位的字节</strong></p><p>这时a = 0x000286a1</p><p>那么c = 0x286a1</p><p>这时b = 0xffff7751</p><p>那么d = 0x7751</p><h4 id="低转高"><a href="#低转高" class="headerlink" title="低转高"></a>低转高</h4><p>因为是补码，所以在符号位和数值位之间补相应的1即可</p><p>无符号数用原码转（添0）</p><h3 id="数据的存储和排列"><a href="#数据的存储和排列" class="headerlink" title="数据的存储和排列"></a>数据的存储和排列</h3><h4 id="大小端模式"><a href="#大小端模式" class="headerlink" title="大小端模式"></a>大小端模式</h4><p>4个字节的int：01 23 45 67    <strong>其中01是最低有效字节MSB，67是最高有效字节（LSB）</strong>这个多字节数据在内存里一定是占连续的几个字节的</p><h5 id="大端模式"><a href="#大端模式" class="headerlink" title="大端模式"></a>大端模式</h5><p>把数据中的各个数据项从小到大排列：01 23 45 67    这样排列，方便人类阅读</p><h5 id="小端模式"><a href="#小端模式" class="headerlink" title="小端模式"></a>小端模式</h5><p>把数据中的各个数据项从大到小排列：67 45 23 01    这样排列，方便机器处理 </p><h4 id="边界对齐"><a href="#边界对齐" class="headerlink" title="边界对齐"></a>边界对齐</h4><p><img src="/2022/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%95%B0%E3%80%81%E7%A0%81/image-20220331203710586.png" alt="image-20220331203710586"></p><p><strong>边界不对齐方式</strong>需要在必要情况下需要读取两次去找一个数据，如short分成了半字1-1和半字1-2两部分，那么就需要读取这两个地址才能找到一个完整的short。</p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p><a href="https://www.bilibili.com/video/BV1BE411D7ii?p=24&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1BE411D7ii?p=24&amp;spm_id_from=pageDriver</a></p><h4 id="用科学计数法理解"><a href="#用科学计数法理解" class="headerlink" title="用科学计数法理解"></a>用科学计数法理解</h4><p>科学计数法：3.01*10^11    </p><h5 id="阶码"><a href="#阶码" class="headerlink" title="阶码"></a>阶码</h5><p>其中的11是幂，在浮点数里面我们叫阶码，其中+11的“+”是阶符，11是阶码的数值部分。</p><h5 id="尾数"><a href="#尾数" class="headerlink" title="尾数"></a>尾数</h5><p>3.01是尾数部分，其中+是数符，3.01是尾数的数值部分。</p><h4 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h4><p>阶码用<strong>补码或者移码</strong>表示</p><p>尾数用<strong>原码或者补码</strong>表示</p><p>我们令阶码为E，尾数为M，r是底数在二进制中取2。浮点数就可以表示为r^E * M</p><p>在做题中，阶码和尾数都是使用二进制来表示的 </p><p><strong>真值的结果是：2的阶码（十进制）次方 乘 尾数（二进制）</strong></p><h4 id="浮点数的规格化（考点）"><a href="#浮点数的规格化（考点）" class="headerlink" title="浮点数的规格化（考点）"></a>浮点数的规格化（考点）</h4><h5 id="左规"><a href="#左规" class="headerlink" title="左规"></a>左规</h5><p>在有限的内存中尽量减少精度的丢失，方法是把尾数中小数点后面的零尽可能的除去。</p><p><img src="/2022/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%95%B0%E3%80%81%E7%A0%81/image-20220331211346107.png" alt="image-20220331211346107"></p><h5 id="右规"><a href="#右规" class="headerlink" title="右规"></a>右规</h5><p>通常发生在双符号数当中，当进位之后符号位变成了01表示溢出了，那么需要算数右移，使得符号位变为00（负数）。<strong>尾数右移，增大阶码。</strong></p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p><img src="/2022/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%95%B0%E3%80%81%E7%A0%81/image-20220331212243385.png" alt="image-20220331212243385"></p><p><strong>规格化的原码尾数，最高数值位一定是1</strong></p><p><strong>规格化的补码尾数，符号位与最高数值位一定相反！！</strong></p><h5 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h5><p>1.采用规格化的浮点数是为了：增加数据的表示精度。</p><p>2.两个浮点数相加减时，阶码小的向阶码大的看齐。</p><p>3.在浮点数编码表示中，<strong>基数</strong>在机器数中不出现！</p><h3 id="浮点数标准-IEEE745"><a href="#浮点数标准-IEEE745" class="headerlink" title="浮点数标准 IEEE745"></a>浮点数标准 IEEE745</h3><h4 id="移码-要把移码看成无符号数！"><a href="#移码-要把移码看成无符号数！" class="headerlink" title="移码(要把移码看成无符号数！)"></a>移码(要把移码看成无符号数！)</h4><p>移码的定义：移码=真值+偏置值</p><p><strong>所以真值=移码-偏置值</strong></p><p>8位移码的的偏置值是128D = 10000000B（即2^(n-1)）</p><p><strong>在IEEE754中阶码使用移码来表示的，规定偏置值为127D = 0,1111111(即2^(n-1)-1)</strong></p><p><strong>因为是无符号数，所以在这里直接用减法，不要用加法！！！不够位就升位</strong></p><p>例如：真值是-127D = - 0，1111111</p><p>​            偏置值是127D = 0，1111111</p><p>​            移码=真值+偏置值 = 11，1111111</p><h4 id="IEEE754的规定"><a href="#IEEE754的规定" class="headerlink" title="IEEE754的规定"></a>IEEE754的规定</h4><p>在浮点数表示中，分为数符，阶码和尾数三个部分</p><p>阶码E用移码表示，尾数M用原码表示。</p><p>原码中隐藏了最高位1，表示尾数应该是1.M</p><p>当偏置值为127时，-128的移码表示是全0，-127的移码表示是全1.</p><p>所以真值的取值范围是-126-127. </p><h4 id="不同类型的浮点数表示"><a href="#不同类型的浮点数表示" class="headerlink" title="不同类型的浮点数表示"></a>不同类型的浮点数表示</h4><p><strong>短浮点数：数符1，阶码8，尾数数值23</strong></p><p>长浮点数：数符1，阶码11，尾数数值52</p><p>临时浮点数：数符1，阶码15，尾数数值64 </p><h4 id="特殊情况-1"><a href="#特殊情况-1" class="headerlink" title="特殊情况"></a>特殊情况</h4><p>只有当阶码E在1&lt;=E&lt;=254的条件下，真值 = (-1)^S * 1.M * 2^(E-127)</p><p>当阶码E全为0时，尾数不全为0时，表示非规格化小数：+-（0.xxx）*2^-126</p><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>1.将十进制数-0.75转换为IEEE754的单精度浮点数格式表示。</p><p><strong>解：</strong></p><p><strong>先将-0.75转换成为二进制形式-0.75D = -0.1100000B</strong></p><p>那么尾数部分就是 - 1.1B</p><p>阶码部分是-1，<strong>这里的-1是真值，要转换成为移码，需要加上偏置值127D（0111,1111）结果是0111,1110</strong></p><hr><p><strong>王道书笔记：</strong></p><p>1.补码和移码的0的表示形式相同；原码和反码的0的表示形式不同，分为-0和+0两种形式。</p><p>2.补码转原码的方式：<strong>先取反后加1</strong></p><p>3.移码就是补码的符号位取反！</p><p>4.移位：算术移位符号位不变，逻辑移位符号位和数值位一起改变</p><p>​               正数移位：全补0；负数移位：原码补0，反码补1，补码左边补0，右边补1</p><p>5.溢出：需要最高算数位和符号位的进位异或结果为1（即一个0一个1）才算溢出，01表示正溢出，10表示负溢出。</p><p>6.原码一位乘法：乘数与被乘数的数值相乘，符号异或处理，不参与运算。相当于符号位和数值位分开计算的！</p><p><strong>题目：</strong></p><p>1.ALU属于：<strong>组合逻辑电路</strong></p><p>2.在串行进位的并行加法器中，影响加法器速度的关键因素是：进位传递延迟。</p><p>3.不属于运算器的是<strong>地址寄存器</strong>。</p><p>4.模4补码：每个模4补码存储时只需要一个符号位。</p><p>5.原码乘法是：先取操作数绝对值相乘，<strong>符号位单独处理，不参与运算。</strong>。</p><p>6.实现N位补码乘法时，乘积为N+1位</p><p>7.在原码不恢复余数法时，只有当最后一步不够减时候，才要恢复一次余数。</p>]]></content>
    
    
    <categories>
      
      <category>计组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理--数据的表示和运算</title>
    <link href="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/"/>
    <url>/2022/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="进位计数制"><a href="#进位计数制" class="headerlink" title="进位计数制"></a>进位计数制</h2><span id="more"></span><h3 id="不同的进制"><a href="#不同的进制" class="headerlink" title="不同的进制"></a>不同的进制</h3><p>其实进制的实质就是<strong>逢X进一</strong>，如十进制就是逢十进一，八进制逢八进一。</p><p>二进制：0，1</p><p>八进制：0，1，2，3，4，5，6，7</p><p>十进制：0，1，2，3，4，5，6，7，8，9</p><p>十六进制：0，1，2，3，4，5，6，7，8，9，A，B，C，D，E，F</p><h4 id="基数"><a href="#基数" class="headerlink" title="基数"></a>基数</h4><p>不同进制的基数不同，如<strong>r进制的基数就是r</strong>，十进制的基数就是十</p><h4 id="不同进制的加法"><a href="#不同进制的加法" class="headerlink" title="不同进制的加法"></a>不同进制的加法</h4><h5 id="八进制加法"><a href="#八进制加法" class="headerlink" title="八进制加法"></a>八进制加法</h5><p>逢八进一，那么5.4+0.4 = 6.0</p><h5 id="十六进制加法"><a href="#十六进制加法" class="headerlink" title="十六进制加法"></a>十六进制加法</h5><p>逢十六进一，那么5.8+1.8 = 7.0</p><h3 id="十进制计数法"><a href="#十进制计数法" class="headerlink" title="十进制计数法"></a>十进制计数法</h3><p>古印度人发明了阿拉伯数字：1，2，3，4.……</p><h4 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h4><p>例如在十进制数<strong>987</strong>中，9是百位，8是十位，7是个位。也即9*10^2 + 8 * 10^1 + 7 * 10^0这三个分别代表了不同的权重。</p><h4 id="从其他进制转换到十进制"><a href="#从其他进制转换到十进制" class="headerlink" title="从其他进制转换到十进制"></a>从其他进制转换到十进制</h4><p><strong>如二进制数11011要转化成十进制的方式就是从第一位到最后一位分别成对应进制基数的0，1，2，3，4次方。</strong></p><p>在这个例子里面就是 1乘二的0次方 + 1乘二的1次方 + 0乘二的2次方 + 1乘二的3次方 + 1乘二的4次方 = 27</p><h4 id="从十进制转化成其他进制"><a href="#从十进制转化成其他进制" class="headerlink" title="从十进制转化成其他进制"></a>从十进制转化成其他进制</h4><h5 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h5><h6 id="整数位置"><a href="#整数位置" class="headerlink" title="整数位置"></a>整数位置</h6><p><strong>除基取余法</strong></p><p>拿十进制的数除2，得到的余数就是二进制的数，直到除到商为0为止，先得到的余数是低位的，后得到的余数是高位的。</p><h6 id="小数位置"><a href="#小数位置" class="headerlink" title="小数位置"></a>小数位置</h6><p><strong>乘基取整法</strong></p><p>拿十进制的小数部分乘2，看乘二之后的整数部分是不是1，是1的话该位的二进制就是1，否则是0。有一些十进制的小数位取不完（如0.3），遇到这种情况就取小数点的后五位</p><h5 id="十进制转八进制和十六进制"><a href="#十进制转八进制和十六进制" class="headerlink" title="十进制转八进制和十六进制"></a>十进制转八进制和十六进制</h5><p>先把十进制转化成为二进制，再把二进制转化成为八进制和十六进制</p><h3 id="二进制转八进制和十六进制"><a href="#二进制转八进制和十六进制" class="headerlink" title="二进制转八进制和十六进制"></a>二进制转八进制和十六进制</h3><h4 id="二进制转八进制"><a href="#二进制转八进制" class="headerlink" title="二进制转八进制"></a>二进制转八进制</h4><p>二进制中的数每三个分成一组，每组对应转换成八进制的数字（0~7）即可，如二进制数100111011001可以分成这样：100<strong>111</strong>011<strong>001</strong>,然后分别看，001转化成八进制是1，011转化成八进制是3，111转化成八进制是7，100转化成八进制是4，所以这个二进制数转化成八进制实际上是4731.</p><p><strong>注意：位数不够的在前面或者后面补0</strong></p><h4 id="二进制转十六进制"><a href="#二进制转十六进制" class="headerlink" title="二进制转十六进制"></a>二进制转十六进制</h4><p>把二进制数看成四个一组即可，要注意的是十六进制中，ABCDEF分别表示10，11，12，13，14，15</p><h4 id="八进制转二进制"><a href="#八进制转二进制" class="headerlink" title="八进制转二进制"></a>八进制转二进制</h4><p>把八进制中<strong>每一个</strong>数都转化成为<strong>三个</strong>二进制数即可</p><h3 id="如何区别不同进制"><a href="#如何区别不同进制" class="headerlink" title="如何区别不同进制"></a>如何区别不同进制</h3><p>一般会在右下角有角标，如八进制会在右下角有八的角标</p><p>如果没有角标的情况下，会在数字的后面加上对应的字母以便区分，二进制的字母是B，十进制的字母是D，十六进制的字母是H。</p><h3 id="真值和机器数"><a href="#真值和机器数" class="headerlink" title="真值和机器数"></a>真值和机器数</h3><p>在计算机中如何表示正负号，通常用0代表负号，用1代表正号。如5436这是个真值，为了表示他是正数，用<strong>1</strong>5436表示他是个正数，15436就是个机器数。在后面的原码，反码，补码，移码中会具体说明。</p><h2 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>使用二进制来编码的十进制数</p><p>每<strong>四个二进制码（4bit）（一共对应了2^4=16种状态）对应这十进制中的0~9</strong>，那么明显有六种是冗余的</p><h3 id="8421码"><a href="#8421码" class="headerlink" title="8421码"></a>8421码</h3><p>8421码种规定了0~9的二进制状态</p><p><strong>9：1001</strong></p><p><strong>8：1000</strong></p><p><strong>7：0111</strong></p><p><strong>6：0110</strong></p><p><strong>5：0101</strong></p><p><strong>4：0100</strong></p><p><strong>3：0011</strong></p><p><strong>2：0010</strong></p><p><strong>1：0001</strong></p><p><strong>0：0000</strong></p><p>要记熟8421码，考试容易碰到</p><h4 id="8421码中数之间的相加"><a href="#8421码中数之间的相加" class="headerlink" title="8421码中数之间的相加"></a>8421码中数之间的相加</h4><p>可以用二进制直接加（记住逢二进一就可以了），也可以用十进制加好之后再转化成二进制数。</p><p><strong>Q：那么这里有个问题是相加得到的数大于9，不在8421码当中怎么办？</strong></p><p><strong>A：通常把这个大于9的数再加上6即可得到两位数的表示方法</strong></p><h3 id="余3码"><a href="#余3码" class="headerlink" title="余3码"></a>余3码</h3><p>在8421码表示的数值中每一个都加上一个二进制的0011，得到的就是余3码。</p><h3 id="2421码"><a href="#2421码" class="headerlink" title="2421码"></a>2421码</h3><p>与8421码很类似，只是2421码对应的权值分别是2421.</p><p>2421码在0~4的时候前两位的值是0</p><h2 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h2><h3 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h3><p>在ASCII码中一共有128个字符，而2的7次方正好等于128，所以我们只需要7位二进制的编码就可以表示ASCII码中的数字符号字母，但是计算机为了凑够一个字节，通常使用8个bit来表示，这样正好凑够了一个字节（Byte）</p><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>已知<strong>A</strong>的ASCII码值是65，<strong>H</strong>存放在M单元中，求M单元中的二进制数</p><p>H在26个字母的第八位，所以计算得M中存放的二进制值是<strong>0</strong>1001000（注意：一定要补一个0凑够八位）</p><p><strong>按字节编址</strong>的意思是每一个地址对应着1B</p><p>一个汉字占两个字节（2B）的大小</p><h2 id="奇偶效验码"><a href="#奇偶效验码" class="headerlink" title="奇偶效验码"></a>奇偶效验码</h2><p>A的编码是00</p><p>B的编码是01</p><p>C的编码是10</p><p>D的编码是11</p><p>当然ABCD都是两个bit的。</p><p><strong>位错误</strong>：0变1，1变0</p><p>由若干位代码组成的一个字叫做<strong>码字</strong></p><h3 id="码距"><a href="#码距" class="headerlink" title="码距"></a>码距</h3><p>将两个码字放在一起一个个字符的逐一进行对比，具有不同位的个数称为两个码字之间的距离，一种编码方案可能有若干个合法码字，各码字之间的<strong>最小距离</strong>称为<strong>码距</strong>。</p><p>当码距=1时，无检错能力</p><p>当码距=2时，具有检错能力</p><p>当码距&gt;=3时，具有检错甚至纠错能力</p><h3 id="奇效验码"><a href="#奇效验码" class="headerlink" title="奇效验码"></a>奇效验码</h3><p><strong>能发现奇数位错误</strong></p><p>保证码中的“1”的个数是<strong>奇数</strong>个，如果是<strong>偶数</strong>，在前面添1；如果是<strong>奇数</strong>，在前面添0</p><h3 id="偶效验码"><a href="#偶效验码" class="headerlink" title="偶效验码"></a>偶效验码</h3><p><strong>能发现偶数位错误</strong></p><p>保证码中的“1”的个数是<strong>偶数</strong>个，如果是<strong>偶数</strong>，在前面添0；如果是<strong>奇数</strong>，在前面添1</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>在<strong>奇校验</strong>中有<strong>奇数个bit</strong>发生了错误是无法发现的</p><p>在<strong>偶校验</strong>中有<strong>偶数个bit</strong>发生了错误是无法发现的</p><h3 id="如何实现奇偶校验"><a href="#如何实现奇偶校验" class="headerlink" title="如何实现奇偶校验"></a>如何实现奇偶校验</h3><h4 id="先求校验码"><a href="#先求校验码" class="headerlink" title="先求校验码"></a>先求校验码</h4><p>将码中的每一bit都进行<strong>异或运算</strong>，返回值作为校验位</p><p><strong>异或运算（模二加）：</strong>当两个值相同的时候返回0，当两个值不同的时候返回1</p><h4 id="进行校验"><a href="#进行校验" class="headerlink" title="进行校验"></a>进行校验</h4><p>和求校验码很类似，对每个值都进行<strong>异或处理</strong>。如果结果为1说明出错了！</p><h3 id="海明校验码"><a href="#海明校验码" class="headerlink" title="海明校验码"></a>海明校验码</h3><h4 id="海明码的设计思路"><a href="#海明码的设计思路" class="headerlink" title="海明码的设计思路"></a>海明码的设计思路</h4><p>将信息分组，对各组分别进行偶校验</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>设信息位有n位，校验位有k位，那么信息位+校验位一共有n+k位，校验位一共有2^k种状态。</p><p>推出不等式：<strong>2^k&gt;=n+k+1</strong>（n是信息位是给出的，要求的只是k）</p><h4 id="信息位"><a href="#信息位" class="headerlink" title="信息位"></a>信息位</h4><p>使用D加下标来表示，校验位用P加下标来表示。</p><h4 id="校验位放什么位置"><a href="#校验位放什么位置" class="headerlink" title="校验位放什么位置"></a>校验位放什么位置</h4><p>校验位Pi应该放在2^(i-1)的位置上</p><h4 id="求校验位的值"><a href="#求校验位的值" class="headerlink" title="求校验位的值"></a>求校验位的值</h4><p>(用D表示信息位，用P表示效验码位，用H表示所有位置，@代表异或，其实是圈里加号)</p><p>先把信息位所处的位置用二进制方式表示出来，假设有三位，把第三位是1的数提出来进行异或运算（用来异或的值是信息位里面的值）</p><p>P1 = D1 @ D2 @ D4</p><p>P2 = D1 @ D3 @ D4</p><p>P3 = D2 @ D3 @ D4</p><h4 id="纠错"><a href="#纠错" class="headerlink" title="纠错"></a>纠错</h4><p>S1 = P1 @ D1 @ D2 @ D4</p><p>S2 = P2 @ D1 @ D3 @ D4</p><p>S3 = P3 @ D2 @ D3 @ D4</p><p><strong>如果：S1，S2，S3中出现了1（假设在S2出现），那么就是010位置出现了错误</strong></p><h4 id="海明码的能力"><a href="#海明码的能力" class="headerlink" title="海明码的能力"></a>海明码的能力</h4><p>海明码具有一个bit位的纠错能力和两个bit位的检错能力</p><h4 id="全校验"><a href="#全校验" class="headerlink" title="全校验"></a>全校验</h4><p>S1S2S3=0 且全体偶校验成功，说明无错误！</p><p>S1S2S3！=0且全体偶校验失败，说明有1处错误，纠正即可，纠正方法是上面的<strong>纠错</strong>部分</p><p>S1S2S3！=0且全体偶校验成功，说明有两处错误，需要重新上传。</p><h3 id="循环冗余校验码"><a href="#循环冗余校验码" class="headerlink" title="循环冗余校验码"></a>循环冗余校验码</h3><p><strong>循环冗余非常难，多看几次视频：</strong></p><p><strong><a href="https://www.bilibili.com/video/BV1BE411D7ii?p=13&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1BE411D7ii?p=13&amp;spm_id_from=pageDriver</a></strong></p><p>定义：数据的发送方和接收方会先约定一个<strong>除数</strong>，当接收到数据后将要验证的数据除以除数，如果得到的数是0，那么这个数据是正确的，如果得到的数据不是0，那么这个数据是错误的。</p><p>​            若是错误的，使用K个信息位加上R个校验位（R是生成多项式中的最高次幂），再进行除法，如果除数为0，说明OK；如果除数非0，说明有错误需要重新上传。</p><h4 id="怎么求"><a href="#怎么求" class="headerlink" title="怎么求"></a>怎么求</h4><p>题目一般会给生成多项式G（G求出来的就是除数）出来，，例如G(x)=x^3 + x^2 +1，那么可以看成G(x)=1*x^3 + 1 *x^2 +0 * x^1 +1 *x^0,那么除数就是1101.（除数是早已经规定好的）</p><p>在信息位后面补上r个0，，然后再与除数进行余二除。</p><p><strong>余二除：从第一位开始看被除数的第一位如果是1那么商1，结果放原数，对后面的三位进行异或运算。。。得到的余数就是校验位，如果余数为000就是没错</strong></p><h4 id="冗余校验码的检错能力的特点"><a href="#冗余校验码的检错能力的特点" class="headerlink" title="冗余校验码的检错能力的特点"></a>冗余校验码的检错能力的特点</h4><p>（1）可检测出所有奇数个错误</p><p>（2）可检测出所有双bit的错误</p><p>（3）可检测出所有小于等于校验位长度的连续错误</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>K位信息码，R位效验码，若生成多项式选择得当，2^R&gt;=K+R+1,则CRC码可纠一处错，因为(2^R)-1和K+R的所有位置元素是一一对应的！</p>]]></content>
    
    
    <categories>
      
      <category>计组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>matlab--程序设计</title>
    <link href="/2022/03/21/matlab-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/03/21/matlab-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>matlab中的程序设计知识</p><span id="more"></span><p>使用input函数可以让用户输入想输入的值，可以是任何形式的。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">#可以在input函数的括号内加入想说的话，如<br>a = input(<span class="hljs-string">&quot;请输入a的值：&quot;</span>)#然后这个a的值会赋值给变量a，在后面可以对a进行相应的运算<br>b = a * <span class="hljs-number">2</span> #b = <span class="hljs-number">2</span>a<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>matlab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>matlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理--硬件</title>
    <link href="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%A1%AC%E4%BB%B6/"/>
    <url>/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%A1%AC%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>计算机硬件如何区分二进制中的0和1？</p><p><strong>由低电平和高电平来区分0和1，低电平（电力较低）表示0，高电平（电力较高）表示1.</strong></p><span id="more"></span><h3 id="金属针脚的作用"><a href="#金属针脚的作用" class="headerlink" title="金属针脚的作用"></a>金属针脚的作用</h3><p>硬件上的金属针脚是用来接收或者发送电信号的。</p><h3 id="主板上的烙印的作用"><a href="#主板上的烙印的作用" class="headerlink" title="主板上的烙印的作用"></a>主板上的烙印的作用</h3><p>是用来导电用的，可以同时传递多个二进制数位（0或者1），每个二进制数位称为1bit。</p><h3 id="硬件的发展"><a href="#硬件的发展" class="headerlink" title="硬件的发展"></a>硬件的发展</h3><p>第一台<strong>电子数字</strong>计算机：1946年的ENIAC</p><p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%A1%AC%E4%BB%B6/image-20220316211930988.png" alt="image-20220316211930988"></p><p><strong>考点是每个阶段的逻辑元件</strong></p><h3 id="冯诺依曼机"><a href="#冯诺依曼机" class="headerlink" title="冯诺依曼机"></a>冯诺依曼机</h3><p>现代的计算机由冯诺依曼机发展而成。</p><p>冯诺依曼提出了<strong>存储程序</strong>的概念：指先将所有指令以二进制代码的形式事先输入计算机的主存储器中，计算机就一一读取这些指令，这样程序员就不用一条一条指令的输入了</p><p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%A1%AC%E4%BB%B6/image-20220317101430363.png" alt="image-20220317101430363"></p><p>在计算机系统中，<strong>软件和硬件在逻辑上是等效的</strong>，对于乘法运算，可以设计一个专门的硬件电路进行乘法运算。</p><p><strong>在处理同一个问题的情况下，硬件的效率大于软件，所以请在条件允许的情况下使用硬件提升效率</strong></p><p>冯诺依曼计算机的五个特征：<br>1.计算机由五大部件组成：存储器，输入设备，运算器，输出设备，控制器</p><p>2.指令和数据以同等地位存储在存储器中，形式上没有区别，可以通过地址来访问</p><p>3.指令和数据用二进制表示</p><p>4.指令由操作码和地址码组成</p><p>5.存储程序（上面讲过了）</p><p><strong>6.以运算器为中心</strong></p><h3 id="现代计算机"><a href="#现代计算机" class="headerlink" title="现代计算机"></a>现代计算机</h3><p>现代计算机和冯诺依曼机最大的不同就在于冯诺依曼机是以运算器为中心的，而现代计算器是以存储器为中心的！</p><p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%A1%AC%E4%BB%B6/image-20220318195318977.png" alt="image-20220318195318977"></p><p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%A1%AC%E4%BB%B6/image-20220318195614419.png" alt="image-20220318195614419"></p><p>存储器又分为主存和辅存，其中主存是主存储器，是属于主机的一部分，辅存是固态硬盘机械硬盘等等辅助存储的设备，辅存属于外设的分类。</p><p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%A1%AC%E4%BB%B6/image-20220318195906524.png" alt="image-20220318195906524"></p><h3 id="主机中的基本组成"><a href="#主机中的基本组成" class="headerlink" title="主机中的基本组成"></a>主机中的基本组成</h3><h4 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h4><p>分为存储体和MAR，MDR</p><p>MAR：Memory Address Register    存储地址寄存器</p><p>MDR：Memory Data Register          存储数据寄存器</p><p>CPU将地址指令发给MAR，MAR将指令发给存储体，存储体经过处理后将读出的数据发给MDR，MDR在还给CPU即可得到我们的元素了</p><p><strong>CPU能够直接访问的存储器是主存储器，辅助存储器中的信息要调入主存储器中才能够被CPU所读取</strong></p><p><strong>数据是存放在存储体当中的</strong></p><p><strong>在现代计算机中，MAR和MDR是存在CPU中的，包括Cache也是存在CPU中。</strong></p><h3 id="主存储器中的组成部分：（选择题的高频考点）"><a href="#主存储器中的组成部分：（选择题的高频考点）" class="headerlink" title="主存储器中的组成部分：（选择题的高频考点）"></a>主存储器中的组成部分：（选择题的高频考点）</h3><p><strong>存储单元：</strong>每个存储单元存放一串二进制代码</p><p><strong>存储字（word）</strong>：存储单元中二进制代码的组合</p><p><strong>存储字长</strong>：存储单元中二进制代码的位数</p><p><strong>储存元</strong>：即存储二进制的电子元件，每个存储元可以存1bit（使用电容存储）</p><p><strong>存储体=若干个存储单元，存储单元=若干个存储元件，一个存储元件存储着一位二进制代码（0/1），构成存储单元中的一串代码称为存储字，位数称为存储字长</strong></p><h3 id="运算器，存储器，控制器的构成"><a href="#运算器，存储器，控制器的构成" class="headerlink" title="运算器，存储器，控制器的构成"></a>运算器，存储器，控制器的构成</h3><p>MAR位数反映存储单元的位数</p><p>MDR位数=存储字长</p><p>例：MAR=4位 即一共有2^4个<strong>存储单元</strong> </p><p>​        MDR=16位 每个<strong>存储单元</strong>可以存放16bit，一个字 = 16bit</p><p>​        1个字节 = 8bit 1B = 1个字节 1B=8bit 1b=1个bit</p><h4 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h4><p>ACC：累加器，用于存放操作数，或者运算结果</p><p>MQ：乘商寄存器，在乘除运算时，用于存放操作数或者运算结果的。</p><p>X：通用的操作数寄存器，用于存放操作数</p><p><strong>ALU</strong>：算数逻辑单元，通过内部复杂的电路实现算术运算、逻辑运算</p><h4 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h4><p><strong>CU</strong>：控制单元，<strong>分析指令</strong>，给出控制信号</p><p>IR：指令寄存器，存放当前执行的指令</p><p>PC：程序计数器，存放下一条指令的地址，有自动加1的功能</p><p>完成一条指令需要的步骤：取指令（PC）-&gt;分析指令IR-&gt;执行指令（CU） </p><h3 id="一个完整的计算机计算乘法的例子"><a href="#一个完整的计算机计算乘法的例子" class="headerlink" title="一个完整的计算机计算乘法的例子"></a>一个完整的计算机计算乘法的例子</h3><p><strong>重要！！！</strong></p><p><strong>一串代码运行的各个步骤：</strong>我们要计算的是a * b的结果</p><h4 id="第一步：把a存进ACC中"><a href="#第一步：把a存进ACC中" class="headerlink" title="第一步：把a存进ACC中"></a>第一步：把a存进ACC中</h4><p><strong>1.（PC）= 0，指向第一条指令的存储地址</strong></p><p>2.（PC）-&gt;MAR 导致MAR=0</p><p>3.（MAR）-&gt;MDR，导致MDR = （操作码）（地址码）</p><p>4.（MDR）-&gt;IR，导致IR = （操作码）（地址码）</p><p>5.<strong>IR（操作码）</strong> -&gt; CU     将指令的<strong>操作码（注意只是操作码，不包括地址码）</strong>送至CU，CU分析后得知要执行的是什么操作，在这里是<strong>取指</strong>操作。</p><p>6.<strong>IR（地址码）</strong>-&gt; MAR    指令的地址码送到MAR。</p><p>7.MAR将地址信息传给主存储器，主存储器再传给MDR，MDR中的就是要读取的数据</p><p>8.MDR中的数据再传给ACC，给ACC进行运算！</p><p><strong>1~4    是取指令的操作</strong>，需要注意的是，PC有自动+1的过程，在取指令操作完成之后，PC就会自动+1</p><p><strong>5        是分析指令的操作</strong></p><p><strong>6~8    执行取数指令</strong></p><h4 id="第二步：乘法操作，存b，然后实现a-b"><a href="#第二步：乘法操作，存b，然后实现a-b" class="headerlink" title="第二步：乘法操作，存b，然后实现a * b"></a>第二步：乘法操作，存b，然后实现a * b</h4><p><strong>其中Ad表示地址，OP表示操作</strong></p><p>1.PC -&gt; MAR</p><p>2.MAR - &gt;主存储器 -&gt; MDR</p><p>3.MDR -&gt; IR</p><p>4.OP(IR) -&gt; CU，CU分析指令之后得知这是<strong>乘法</strong>操作</p><p>5.Ad(IR) -&gt; MAR ，MAR此时的值是b</p><p>6.MAR -&gt;主存储器-&gt;MDR </p><p>7.MDR - &gt;MQ,此时MQ中的值是b的值</p><p>8.ACC -&gt; X，<strong>注意，这一步非常重要，在运算器当中，永远会把被乘数（ab中的a）转移到X中，乘数（ab中的b）转移到MQ中</strong>，此时X中的值是a的值。</p><p>9.<strong>此时ALU会把X中的值和MQ中的值都提取出来进行相乘的操作，然后！把结果存放在ACC当中，如果乘积太大需要MQ来进行辅助存储</strong></p><h4 id="第三步：加法操作，存c，然后实现a-b-c"><a href="#第三步：加法操作，存c，然后实现a-b-c" class="headerlink" title="第三步：加法操作，存c，然后实现a *b + c"></a>第三步：加法操作，存c，然后实现a *b + c</h4><p>1.PC -&gt; MAR</p><p>2.MAR - &gt;主存储器 -&gt; MDR</p><p>3.MDR -&gt; IR</p><p>4.OP(IR) -&gt; CU，CU分析指令之后得知这是<strong>加法</strong>操作</p><p>其他差不多都一样，需要注意的就是在进行加法操作的时候，ACC当中存放的是被加数（a<em>b+c中的a * b），x中存放的是加数(a</em>b+c当中的c)</p><p>然后用ALU来进行加法的操作，结果同样赋值给ACC</p><h4 id="第四步：存数操作，把a-b-c的结果存放在对应的存储单元（这里是8）"><a href="#第四步：存数操作，把a-b-c的结果存放在对应的存储单元（这里是8）" class="headerlink" title="第四步：存数操作，把a * b + c的结果存放在对应的存储单元（这里是8）"></a>第四步：存数操作，把a * b + c的结果存放在对应的存储单元（这里是8）</h4><p>前面的一系列操作直到CU分析完要运行的操作是<strong>存数</strong>操作。</p><p>1.IR将地址赋给MAR，此时MAR即地址存储器存放的就是结果要存放的存储单元（8）</p><p>2.ACC中有结果的值，ACC -&gt; MDR    ,此时MDR中的值就是abc的运算结果</p><p>3.MDR -&gt; 存储单元为8的位置</p><h4 id="第五步：停机操作"><a href="#第五步：停机操作" class="headerlink" title="第五步：停机操作"></a>第五步：停机操作</h4><p>这个属于操作系统的范畴了</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在计算机执行指令的时候，前面的**取指令（PC-&gt;MAR-&gt;MDR-&gt;IR）(注意这里取指令结束PC加一)<strong>，</strong>分析指令(IR-&gt;CU)**的操作都是一模一样的</p><p><strong>记住有个“被”字的都是在ACC中，被乘数在ACC中，乘数在乘法寄存器MQ中，结果赋值给ACC；被加数在ACC，加数在X，结果赋值给ACC；最后ACC-&gt;MDR，那么MDR中就是结果，以二进制的形式表示。</strong></p><h2 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h2><p>计算机层次一共分成五层结构，由上至下分别是：高级语言机器，汇编语言机器，操作系统语言机器，传统机器（识别机器语言的），微程序机器（执行微指令的）</p><p>汇编语言和高级语言所存在的机器都是<strong>虚拟机器</strong>，因为机器并不能直接识别汇编语言和高级语言，而是要把他们两个翻译成机器语言才能使计算机识别。</p><p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%A1%AC%E4%BB%B6/image-20220321203540393.png" alt="image-20220321203540393"></p><h3 id="语言之间的传递关系"><a href="#语言之间的传递关系" class="headerlink" title="语言之间的传递关系"></a>语言之间的传递关系</h3><p>1.我们平时写的高级语言需要通过<strong>编译程序</strong>来把它翻译成为与之等价的汇编语言（实际上汇编语言就是一些助记符）。</p><p>2.汇编语言则需要通过<strong>汇编程序</strong>的翻译来得到计算机真正能够识别的机器语言。</p><p><strong>另一种方法</strong></p><p>有一种<strong>解释程序</strong>能将高级语言直接通过解释程序来转化成为机器语言，一步到位</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>1.编译程序：是将高级语言一次全部翻译成机器语言然后一次执行完，<strong>每次执行都需要翻译</strong>，熟悉的exe文件就是这样的效果</p><p>2.解释程序：是将高级语言一句一句的翻译成机器语言，每翻译一句就会执行一次，<strong>每次执行都需要翻译</strong></p><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><h3 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h3><p>MAR为32位，MDR为8位，总容量是2^32 / 8 bit = 4GB</p><p><strong>如果有n个二进制位，那么就有2的n次方种状态，因为一个二进制位就有0和1两种可能结果</strong></p><p>1kB是1024个Byte，也就是2^10个Byte</p><p>2^10 = K     ,    2^20 = M    ,     2^30 = G    ,    2^40 = T.</p><h3 id="CPU的性能指标"><a href="#CPU的性能指标" class="headerlink" title="CPU的性能指标"></a>CPU的性能指标</h3><p>比如英特尔i9-9900KF CPU，标有的3.6GHZ代表着<strong>CPU的主频</strong>是3.6GHZ</p><p>CPU的时钟周期：每个脉冲信号的时间周期称为CPU的时钟周期（单位一般是微秒，纳秒）</p><p><strong>CPU的主频：CPU内数字脉冲震荡的频率，如CPU的主频是10，那么代表着每秒钟有10个脉冲信号,主频=CPU时钟周期分之一</strong></p><p>CPI也对CPU的主频有影响，CPI：执行一条指令所需要的时钟周期数</p><p>执行一条指令的耗时是CPI * CPU的时钟周期</p><p>公式总结：CPU执行时间= （指令条数*CPI）/主频。或CPU时钟周期数/主频 = 1/主频^2</p><p>​                    IPS：每秒执行了多少条指令，IPS = 主频/平均CPI</p><p>​                    FLOPS：每秒执行了多少次浮点运算</p><p>KIPS:千，10^3</p><p>MIPS：百万10^6</p><p>GIPS: 十亿，10^9</p><p>TIPS: 万亿，10^12</p><h3 id="系统总体性能指标"><a href="#系统总体性能指标" class="headerlink" title="系统总体性能指标"></a>系统总体性能指标</h3><p><strong>数据通路带宽</strong>：数据总线一次能传输多少bit位的数据，CPU和主存储器和IO设备之间都是通过数据通路带宽来传输数据的。</p><p>​    假设数据通路带宽为8bit，而主存储器向CPU传输的数据大小为16bit，那么就需要传输两次才能够实现</p><p><strong>吞吐量</strong>：指系统在单位时间内能处理多少个请求</p><p><strong>响应时间：</strong>指用户向计算机发送一个请求，直到接收到回复为止的总时间</p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><p><strong>主频高的CPU一定比主频低的CPU快吗？</strong></p><p>答：不一定，具体还要看CPI（处理一条指令需要的用时）。就算CPI相等，也是不一定的，因为有一些CPU无法执行如乘法操作等复杂操作，那么只能用加法累加，那就复杂得多了</p><hr><p><strong>王道书总结：</strong></p><p>1.主频 = 时钟频率 = 1/时钟周期</p><p>2.时钟周期 = 1/主频    （他俩是倒数关系）</p><p>3.CPI（执行一条指令所需要的时钟周期） = 时钟周期/指令条数n = 1/主频*指令条数</p><p>4.（常考，非常重要）<strong>CPU执行时间 = 时钟周期/主频 = 指令条数n*CPI/主频</strong></p><p>5.两个概念：MFLOPS：一秒一百万次的浮点运算</p><p>​                       PFLOPS：一秒一千万亿次运算</p><p>6.机器字长：CPU一次能处理的二进制数据的最大位数</p><p>7.存储字长：存储单元中存储的二进制数据和二进制指令</p><p>8.字长：地址字长是2^n中的n，MAR = PC = 地址字长</p><p>9.主频（GHZ和MHZ，GHZ要求MIPS时要除以10^6进行转换，MHZ则不用）对应着时钟周期（μs）</p><p>10.MIPS：主频（GHZ）/CPI* 10^6 = 主频（MHZ）/ CPI</p><p>11.CPI = 平均指令周期</p><hr><p><strong>题目：</strong></p><p>1.在CPU寄存器中<strong>指令寄存器</strong>对用户是完全透明的（透明指看不见）</p><p>2.计算机操作的最小单位时间：<strong>时钟周期</strong>（因为他是主频的倒数是最小的！）</p><p>3.从用户观点看关系计算机速度最重要的指标是<strong>吞吐量</strong></p><p>4.设计高性能计算机的关键途径是采用<strong>并行技术</strong></p><p>5.计算机能够直接执行的语言只有<strong>机器语言</strong></p><p>6.机器字长=CPU内部用于整数运算的运算器位数和通用寄存器X位数。</p>]]></content>
    
    
    <categories>
      
      <category>计组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数值分析--Newton插值</title>
    <link href="/2022/03/16/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-Newton%E6%8F%92%E5%80%BC/"/>
    <url>/2022/03/16/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-Newton%E6%8F%92%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在拉格朗日插值中解决了Ln(x)的问题，那么要解决L2(x)=L1(x)+？中的？是什么，我们需要引入牛顿插值来解决</p><span id="more"></span><h3 id="差商"><a href="#差商" class="headerlink" title="差商"></a>差商</h3><p>要想解决牛顿插值问题先要知道差商的概念。</p><p>C0 = f(x0) = f(x0)</p><p>C1 = f[x0,x1] = [f(x1)-f(x0)]/x1-x0</p><p>C2 = f[x0,x1,x2] = f(x1)-f(x0)/x1-x0 ……</p><h3 id="牛顿插值"><a href="#牛顿插值" class="headerlink" title="牛顿插值"></a>牛顿插值</h3><p>Nn(x) = C0 + C1(x-x0) + C2 (x-x0)(x-x1) + … + Cn(x-x0)(x-x1)..(x-xn)</p>]]></content>
    
    
    <categories>
      
      <category>数值分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数值分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数值分析--Lagrange插值</title>
    <link href="/2022/03/16/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-Lagrange%E6%8F%92%E5%80%BC/"/>
    <url>/2022/03/16/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-Lagrange%E6%8F%92%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>拉格朗日插值法分为一次插值，两次插值直到n次插值，划分的方法是有两个点就有一次插值，有三个点就有两次插值，同理可以推出有n个点就有n-1次插值。</p><span id="more"></span><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>假设图中有n个点，我们先找一个穿过第一个点的函数，再找穿过第二个点的函数，把这两个函数相加，得到的结果就是同时穿过这两个点的函数。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>当我们知道图中有n个点的时候，要找到同时穿过这n个点的函数，即把分别穿过n个点的函数相加，得到的就是拉格朗日插值。</p><h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><p>当图中有三个点的时候，L2(x) = [(x-x1)(x-x2)/(x0-x1)(x0-x2)]y0 + [(x-x0)(x-x2)/(x1-x0)(x1-x2)]y1 + [(x-x0)(x-x1)/(x2-x0)(x2-x1)]y2</p><p>当图中有n个点的时候，Ln(x) = n(大派键)i=0且i不等于j (x-xj)/(xi-xj)</p>]]></content>
    
    
    <categories>
      
      <category>数值分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数值分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python--name属性</title>
    <link href="/2022/03/10/python-name%E5%B1%9E%E6%80%A7/"/>
    <url>/2022/03/10/python-name%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>python中的 __  <em>name</em> _ _属性</p><span id="more"></span><p>除了直接运行，python文件还可以直接作为模块导入。通过Python中的__name__属性来判断，分两种情况：<br>1.如果文件作为模块被导入，那么他的__name__值被自动设置为模块名</p><p>2.如果文件直接运行，那么__name__的属性值自动设置为字符串’<strong>main</strong>‘</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>()<br><span class="hljs-keyword">if</span> __name__ = <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;directly run&quot;</span>)<br><span class="hljs-keyword">elif</span> __name__ = <span class="hljs-string">&#x27;hello&#x27;</span>:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;import way&quot;</span>)<br>    <br>main()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习-- Matplotlib库</title>
    <link href="/2022/03/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-Matplotlib%E5%BA%93/"/>
    <url>/2022/03/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-Matplotlib%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>Matplotlib库用来创建图表</p><span id="more"></span><p>在使用Matplotlib库的时候要导入matpltlib库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure><p>常用的图形函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#绘制折线图</span><br>plt.plot()<br><span class="hljs-comment">#绘制柱形图</span><br>plt.bar()<br><span class="hljs-comment">#绘制饼图</span><br>plt.pie()<br></code></pre></td></tr></table></figure><h3 id="绘制基本的图表"><a href="#绘制基本的图表" class="headerlink" title="绘制基本的图表"></a>绘制基本的图表</h3><h4 id="绘制折线图"><a href="#绘制折线图" class="headerlink" title="绘制折线图"></a>绘制折线图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>x = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>y = [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>]<br>plt.plot(x,y)<br>plt.show()<br></code></pre></td></tr></table></figure><h4 id="绘制柱形图"><a href="#绘制柱形图" class="headerlink" title="绘制柱形图"></a>绘制柱形图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>x = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>y = [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>plt.bar(x,y)<br>plt.show()<br></code></pre></td></tr></table></figure><h4 id="绘制散点图"><a href="#绘制散点图" class="headerlink" title="绘制散点图"></a>绘制散点图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>x = np.random.rand(<span class="hljs-number">10</span>)<span class="hljs-comment">#生成10个位于0~1之间的数</span><br>y = np.random.rand(<span class="hljs-number">10</span>)<br>plt.scatter(x,y)<br>plt.show()<br></code></pre></td></tr></table></figure><h4 id="绘制直方图"><a href="#绘制直方图" class="headerlink" title="绘制直方图"></a>绘制直方图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>data = np.random.randn(<span class="hljs-number">10000</span>)<span class="hljs-comment">#生成10000个服从标准正态分布的随机数</span><br>plt.hist(data,bins=<span class="hljs-number">40</span>,edgecolor=<span class="hljs-string">&#x27;black&#x27;</span>)   <span class="hljs-comment">#绘制直方图的函数,bins为直方图的数量（颗粒度），edgecolor为柱形图的边框颜色</span><br>plt.show()<br></code></pre></td></tr></table></figure><h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><h4 id="添加文字"><a href="#添加文字" class="headerlink" title="添加文字"></a>添加文字</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>x = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>y = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>plt.plot(x,y)<br>plt.title(<span class="hljs-string">&#x27;TITLE&#x27;</span>)<span class="hljs-comment">#设置图标上面的标题</span><br>plt.xlabel(<span class="hljs-string">&#x27;X&#x27;</span>)<span class="hljs-comment">#设置横坐标的值</span><br>plt.ylabel(<span class="hljs-string">&#x27;Y&#x27;</span>)<span class="hljs-comment">#设置纵坐标的值</span><br>plt.show()<br></code></pre></td></tr></table></figure><h4 id="添加图例"><a href="#添加图例" class="headerlink" title="添加图例"></a>添加图例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>plt(x,y,lable=<span class="hljs-string">&#x27;x+y&#x27;</span>)<span class="hljs-comment">#只是在之前的条件后面添加一个label参数</span><br>plt.legend(loc=<span class="hljs-string">&#x27;upper left&#x27;</span>)<span class="hljs-comment">#这是用来把图例设置在图表的左上方</span><br></code></pre></td></tr></table></figure><h4 id="设置图表大小"><a href="#设置图表大小" class="headerlink" title="设置图表大小"></a>设置图表大小</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.rcParams[<span class="hljs-string">&#x27;figure.figsize&#x27;</span>] = (<span class="hljs-number">8</span>,<span class="hljs-number">6</span>)<span class="hljs-comment">#其中8是长度，6是宽度</span><br></code></pre></td></tr></table></figure><h4 id="设置x轴刻度的问题"><a href="#设置x轴刻度的问题" class="headerlink" title="设置x轴刻度的问题"></a>设置x轴刻度的问题</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.xticks(rotation=<span class="hljs-number">45</span>)<br></code></pre></td></tr></table></figure><h4 id="解决中文显示问题ax"><a href="#解决中文显示问题ax" class="headerlink" title="解决中文显示问题ax"></a>解决中文显示问题ax</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pylot <span class="hljs-keyword">as</span> plt<br>plt.rcParams[fort.sans-serif] = [<span class="hljs-string">&#x27;SimHei&#x27;</span>]<span class="hljs-comment">#用来正常显示中文标签</span><br>plt.rcParams[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="hljs-literal">False</span><span class="hljs-comment">#解决符号显示为方块的问题</span><br></code></pre></td></tr></table></figure><h4 id="绘制多图"><a href="#绘制多图" class="headerlink" title="绘制多图"></a>绘制多图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#Matplotlib库中的figure作为画布，axes作为子图，一个画布中可以有多张子图，绘制多图常用subplot()函数和subplots()函数.</span><br><br><span class="hljs-comment">#subplot函数，他的参数为三位整数，分别表示子图的行数列数和当前子图的序号。</span><br>ax = plot.subplot(<span class="hljs-number">221</span>)<br>plt.plot([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>])<span class="hljs-comment">#表示这个两行两列的子图绘制折线图。</span><br><br><span class="hljs-comment">#subplots函数，表示生成几行几列的子图</span><br>fig,axes = plt.subplots(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<span class="hljs-comment">#表示生成两行两列的一共四个的子图,fig是画布参数，axes是子图参数</span><br>ax1,ax2,ax3,ax4 = axes.flatten()<span class="hljs-comment">#这个语句将子图变量赋值给ax1,ax2,ax3,ax4</span><br><span class="hljs-comment">#之后就可以使用subplot在子图中画图</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习--pandas库</title>
    <link href="/2022/03/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-pandas%E5%BA%93/"/>
    <url>/2022/03/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-pandas%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>pandas库基础</p><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#numpy库用random等函数创建数组，而pandas用Series创建数组</span><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>s = pd.Series([<span class="hljs-string">&#x27;邓&#x27;</span>,<span class="hljs-string">&#x27;高&#x27;</span>,<span class="hljs-string">&#x27;正&#x27;</span>])<span class="hljs-comment">#Series不单止创建了一维数组，还创建了索引，使用s[i]即可找到对应元素的位置</span><br><span class="hljs-built_in">print</span>(s[<span class="hljs-number">1</span>])<span class="hljs-comment">#高</span><br></code></pre></td></tr></table></figure><h3 id="二维数据表格DataFrame的创建"><a href="#二维数据表格DataFrame的创建" class="headerlink" title="二维数据表格DataFrame的创建"></a>二维数据表格DataFrame的创建</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#使用DataFrame创建二维数组</span><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>a = pd.DataFrame([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>])<span class="hljs-comment">#生成的结果会有行索引和列索引，当然我们也可以自定义行列索引，如下</span><br>a = pd.DataFrame([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],columns=[<span class="hljs-string">&#x27;data&#x27;</span>,<span class="hljs-string">&#x27;score&#x27;</span>],index=[<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>])<span class="hljs-comment">#这样就自定义了行列是什么</span><br><br><span class="hljs-comment">#DataFrame同样可以创建字典，字典值默认为列索引</span><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>b = pd.DataFrame(&#123;<span class="hljs-string">&#x27;a&#x27;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>],<span class="hljs-string">&#x27;b&#x27;</span>:[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>]&#125;,index=[<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span>,<span class="hljs-string">&#x27;z&#x27;</span>])<br><span class="hljs-comment">#若想让字典为行索引</span><br>c = pd.DataFrame.from_dict(&#123;<span class="hljs-string">&#x27;a&#x27;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-string">&#x27;b&#x27;</span>:[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]&#125;,orient=<span class="hljs-string">&quot;index&quot;</span>)<br><span class="hljs-comment">#DataFrame支持将二维表格转置</span><br>b = pd.DataFrame(&#123;<span class="hljs-string">&#x27;a&#x27;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>],<span class="hljs-string">&#x27;b&#x27;</span>:[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>]&#125;,index=[<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span>,<span class="hljs-string">&#x27;z&#x27;</span>])<br><span class="hljs-built_in">print</span>(b.T)<span class="hljs-comment">#打印转置后的表格</span><br><br><span class="hljs-comment">#若要修改行索引和列索引的名字，使用rename函数</span><br>a = a.rename(columns = [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>],index = [<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>])<br><span class="hljs-comment">#其实上面那个只是创建了一个新的索引并未改变a的内容，需要使用inplace=True才能改变a的内容</span><br>a = a.rename(columns = [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>],index = [<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>]，inplace=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment">#查看index索引的值</span><br>a.index.values()<br></code></pre></td></tr></table></figure><h3 id="Excel表格的读取和写入"><a href="#Excel表格的读取和写入" class="headerlink" title="Excel表格的读取和写入"></a>Excel表格的读取和写入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#使用pandas函数</span><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>data = pd.read_excel(<span class="hljs-string">&#x27;data.xlsx&#x27;</span>)<br><span class="hljs-comment">#通过打印data可以看到读取表格中的内容</span><br>data.head(n)<span class="hljs-comment">#其中的n是查看多少行</span><br><br><span class="hljs-comment">#read_excel函数还可以设置更多的参数</span><br>pd.read_excel(<span class="hljs-string">&#x27;data.xlsx&#x27;</span>,sheet_name=<span class="hljs-number">0</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<span class="hljs-comment">#其中sheet_name是工作表的位置，可以是工作表的名称，也可以是数字，默认是0，即第1个工作表，encoding自然是编码形式不必多说。</span><br><br><span class="hljs-comment">#pd还可以读取csv文件，使用read_csv</span><br>pd.read_csv(<span class="hljs-string">&#x27;data.csv&#x27;</span>,delimiter=<span class="hljs-string">&#x27;,&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<span class="hljs-comment">#delimiter指的是指定csv文件中的分隔符。</span><br><br><br><span class="hljs-comment">#Excel的写入</span><br><span class="hljs-comment">#先创建DataFrame</span><br>data = pd.DataFrame([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]],columns=[<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>])<br><span class="hljs-comment">#将data写入excel中</span><br>data.to_excel(<span class="hljs-string">&#x27;data.xlsx&#x27;</span>)<br><br><span class="hljs-comment">#在字符串之前加入r可以取消字符串中反斜杠的意义。</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">r&quot;D:\\niu\\bi&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="数据的选取与处理"><a href="#数据的选取与处理" class="headerlink" title="数据的选取与处理"></a>数据的选取与处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#先创建一个二维数组</span><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>data = pd.DataFrame(np.arange(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">1</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>),index=(<span class="hljs-string">&#x27;r1&#x27;</span>,<span class="hljs-string">&#x27;r2&#x27;</span>,<span class="hljs-string">&#x27;r3&#x27;</span>),columns=(<span class="hljs-string">&#x27;c1&#x27;</span>,<span class="hljs-string">&#x27;c2&#x27;</span>,<span class="hljs-string">&#x27;c3&#x27;</span>))<br><br><span class="hljs-comment">#选择打印一行</span><br><span class="hljs-built_in">print</span>(data[<span class="hljs-string">&#x27;c1&#x27;</span>])<br><span class="hljs-comment">#选择打印多行</span><br><span class="hljs-comment">#print([&#x27;c1&#x27;,&#x27;c2&#x27;]),这样的做法是错误的</span><br><span class="hljs-built_in">print</span>([[<span class="hljs-string">&#x27;c1&#x27;</span>,<span class="hljs-string">&#x27;c2&#x27;</span>]])<span class="hljs-comment">#这样的做法才是正确的！</span><br><span class="hljs-comment">#要选取第2~3行的数据</span><br>data[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<span class="hljs-comment">#注意序号从0开始，并且是左闭右开</span><br><span class="hljs-comment">#python中的pandas库推荐使用iloc函数来选取数组中的行列</span><br>d = data.iloc[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<span class="hljs-comment">#选取第2~3行</span><br>e = data.iloc[-<span class="hljs-number">1</span>]<span class="hljs-comment">#选取倒数第一行</span><br><span class="hljs-comment">#还可以使用loc来选取行的名称来实现输出</span><br>f = data.loc[[<span class="hljs-string">&#x27;c1&#x27;</span>,<span class="hljs-string">&#x27;c2&#x27;</span>]]<br><span class="hljs-comment">#可以用head函数选取前n行</span><br>data.head(<span class="hljs-number">5</span>)<br><span class="hljs-comment">#如果只想选取某几行的前几个元素，可以在后面加上[]</span><br>data.iloc[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>][<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]<br><br><span class="hljs-comment">#数据筛选</span><br>a = data[data[<span class="hljs-string">&#x27;c1&#x27;</span>]&gt;<span class="hljs-number">1</span>]<span class="hljs-comment">#选取data中c1列中大于1的数</span><br><br><span class="hljs-comment">#查看数据情况</span><br><span class="hljs-comment">#可以通过DataFrame中的shape属性来查看二维数组的行列</span><br>data.shape()<span class="hljs-comment">#(3,3)其中，前一个参数是行，后一个参数是列</span><br><span class="hljs-comment">#使用describe()可以查看每一列的数据个数，平均值，标准差，最小值，最大值等信息</span><br>data.describe()<br><br><span class="hljs-comment">#通过运算创建新的列或者行</span><br>data[<span class="hljs-string">&#x27;c4&#x27;</span>] = data[<span class="hljs-string">&#x27;c3&#x27;</span>] - data[<span class="hljs-string">&#x27;c1&#x27;</span>]<br><br><span class="hljs-comment">#可以使用sort_values函数来对表格进行排列，其中ascending参数确定是升序还是降序</span><br>a = data.sort_values(by=<span class="hljs-string">&#x27;c2&#x27;</span>,ascending=<span class="hljs-literal">False</span>)<span class="hljs-comment">#其中False表示降序排序，True表示升序排序</span><br><span class="hljs-comment">#通过sort_index函数进行行排序</span><br>a = a.sort_index(<span class="hljs-string">&#x27;r2&#x27;</span>,ascending=<span class="hljs-literal">True</span>)<span class="hljs-comment">#同样True表示升序，False表示降序</span><br><br><span class="hljs-comment">#使用drop()函数删除数组中的列或者行</span><br>a = data.drop(columns=[<span class="hljs-string">&#x27;c1&#x27;</span>,<span class="hljs-string">&#x27;c3&#x27;</span>],index=[<span class="hljs-string">&#x27;r2&#x27;</span>],inplace=<span class="hljs-literal">True</span>)<span class="hljs-comment">#这里删除了c1和c3两列，和r2这一行，inplace参数表示是否选择改变原表格，默认值为False。</span><br></code></pre></td></tr></table></figure><h3 id="数据表的拼接"><a href="#数据表的拼接" class="headerlink" title="数据表的拼接"></a>数据表的拼接</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#merge()函数将多个数据表进行合并，merge会自己判断相同的项的位置并进行合并，也可以自己设置on参数来选择按照哪一列来合并</span><br>df1 = ..... <span class="hljs-comment">#是一个数据表</span><br>df2 = .....<span class="hljs-comment">#也是一个数据表</span><br>df3 = merge(df1,df2,on=<span class="hljs-string">&#x27;公司&#x27;</span>)<br><span class="hljs-comment">#如果想取并值,可以设置how函数。</span><br>df3 = pd.merge(df1,df2,how=<span class="hljs-string">&#x27;outer&#x27;</span>)<span class="hljs-comment">#改成outer即可取并值连接</span><br><span class="hljs-comment">#如果想保留左表的内容</span><br>df3 = pd.merge(df1,df2,how=<span class="hljs-string">&#x27;left&#x27;</span>)<br><span class="hljs-comment">#如果想保留右表的内容</span><br>df3 = pd.merge(df1,df2,how=<span class="hljs-string">&#x27;right&#x27;</span>)<br><br><span class="hljs-comment">#concat()函数</span><br><span class="hljs-comment">#concat函数是全连接，不去管是否有相同的值能进行合并，而是直接合并，只有一个可设置参数axis</span><br>df3 = pd.concat([df1,df2],axis=<span class="hljs-number">0</span>)<span class="hljs-comment">#这个表示纵向连接</span><br>df3 = pd.concat([df1,df2],axis=<span class="hljs-number">1</span>)<span class="hljs-comment">#这个表示横向连接</span><br><br><span class="hljs-comment">#append()函数</span><br><span class="hljs-comment">#append函数可以看成concat函数的简化版</span><br>df3 = df1.append(df2)<br><span class="hljs-comment">#append函数还有一个常用功能是在列表里面添加元素</span><br>df3 = df1.append(&#123;<span class="hljs-string">&#x27;公司&#x27;</span>:<span class="hljs-string">&#x27;腾讯&#x27;</span>,<span class="hljs-string">&#x27;分数&#x27;</span>:<span class="hljs-string">&#x27;90.0&#x27;</span>&#125;,ignore_index=<span class="hljs-literal">True</span>)<span class="hljs-comment">#这个ignore_index参数是设置忽略原列表中的数值的</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>统计学-- 数据的搜集</title>
    <link href="/2022/03/08/%E7%BB%9F%E8%AE%A1%E5%AD%A6-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%90%9C%E9%9B%86/"/>
    <url>/2022/03/08/%E7%BB%9F%E8%AE%A1%E5%AD%A6-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%90%9C%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h3 id="数据的分类"><a href="#数据的分类" class="headerlink" title="数据的分类"></a>数据的分类</h3><span id="more"></span><p>1.原始数据：调查，观察实验。</p><p>2.次级数据：已被做好的，统计年鉴，期刊等等。</p><h3 id="概率抽样和非概率抽样"><a href="#概率抽样和非概率抽样" class="headerlink" title="概率抽样和非概率抽样"></a>概率抽样和非概率抽样</h3><p>1.概率抽样（随机抽样）：</p><p>​    （1）简单随机抽样：（需要<strong>抽样框</strong>，<strong>抽样框</strong>通常包括所有总体单位的信息，如小区用户信息，住户门牌号等）从包括总体N个单位的抽样框中一个个的抽取n个单位作为样本，抽中每个样本的概率是相等的。</p><p>​    （2）分层抽样：把总体按照某种特征或某种规则划分成多层，然后从不同的层中抽取样本，然后将这些样本结合起来。</p><p>​    （3）整群抽样：总体中若干个单位合并为<strong>群</strong>，抽样的时候直接抽取群，然后对选中的群全部进行调查，称为<strong>整群抽样</strong>。</p><p>​    （4）系统抽样：将所有单位按一定的顺序排好，在规定的范围内随机抽取一个单位作为初始单位。然后按照一定的规则确定其他的样本单位。</p><p>​    （5）多阶段抽样：先进行整群抽样，然后再从群里面抽取若干个单位进行调查。</p><p>2.非概率抽样：</p><p>​    （1）方便抽样：调查过程中调查员依据方便的原则</p><p>​    （2）判断抽样：研究人员根据经验，判断等，有目标的选择对象进行研究</p><p>​    （3）自愿抽样：自愿者自愿参与</p><p>​    （4）滚雪球抽样：先选择一组样本，然后由这个样本提供其他的样本，故称为滚雪球</p><p>​    （5）配额抽样：类似于概率抽样中的分层抽样</p><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>统计学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>统计学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>matlab -- 向量与矩阵</title>
    <link href="/2022/03/07/matlab-%E5%90%91%E9%87%8F%E4%B8%8E%E7%9F%A9%E9%98%B5/"/>
    <url>/2022/03/07/matlab-%E5%90%91%E9%87%8F%E4%B8%8E%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="向量的基本命令"><a href="#向量的基本命令" class="headerlink" title="向量的基本命令"></a>向量的基本命令</h3><span id="more"></span><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs matlab">#创建一个四维向量（<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>，<span class="hljs-number">4</span>）<br>x = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>#注意：在matlab中下标是从<span class="hljs-number">1</span>开始计算的，而不是从<span class="hljs-number">0</span>开始计算的<br>#使用y = x(<span class="hljs-built_in">i</span>)可以提取x中的第<span class="hljs-built_in">i</span>个元素！！<br>y  = x(<span class="hljs-number">2</span>) #这里我们提取了x中的第二个元素是<span class="hljs-number">2</span>，不是<span class="hljs-number">3</span>！！！<br>#使用分号；来分行，用逗号来分列！<br>x = [<span class="hljs-number">1</span>;<span class="hljs-number">2</span>;<span class="hljs-number">3</span>;<span class="hljs-number">4</span>] #这时x就是四行了<br><br>#创建等差数列来遍历向量<br><br>#第一种等差数列的方式： x = a:d:b 表示遍历从a到b，其中公差是d（包括开头的数，当然也包括结尾的数，如果能取到的话）<br>x = <span class="hljs-number">1</span>:<span class="hljs-number">2</span>:<span class="hljs-number">10</span>  #结果就是<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span><br>#第二种等差数列的方式：x = <span class="hljs-built_in">linspace</span>(a,b,n),简单来说就是在a和b之间平均分成n分呈现出来。当a=b时会产生n个a。<br>x = <span class="hljs-built_in">linspace</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>) #<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span><br><br>#求向量的维数（长度）<br>n = <span class="hljs-built_in">length</span>(x)<br>#求向量的转置<br>xt = transpose(x)#也可以表示为xt=x&#x27;<br>#求最大值及对应位置的元素<br>[m1,p1] = <span class="hljs-built_in">max</span>(x)#m1表示最大值，p1表示对应的位置的元素<br>#求最大值及对应位置的元素<br>[m2,p2] = <span class="hljs-built_in">min</span>(x)#m2表示最小值，p2表示对应位置的元素<br>#求向量x中所有元素的和<br>y = sum(x)<br>#求x中所有元素的平均值<br>y = <span class="hljs-built_in">mean</span>(x)<br>#求向量x的lp范数<br>y = norm(x,p)<br>#求向量的标准差<br>y = std(x)<br>#求向量中每个元素的绝对值<br>y = <span class="hljs-built_in">abs</span>(x)<br>#对向量中的每个元素进行从小到大的排序，p表示位置组成的变量<br>[y,p] = <span class="hljs-built_in">sort</span>(x)#正序排序<br>[y,p] = <span class="hljs-built_in">sort</span>(x,<span class="hljs-string">&#x27;descend&#x27;</span>)#倒序排序<br></code></pre></td></tr></table></figure><h3 id="矩阵的基本命令"><a href="#矩阵的基本命令" class="headerlink" title="矩阵的基本命令"></a>矩阵的基本命令</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs matlab">#求矩阵X的大小，m是行数，n是列数<br>[m,n] = <span class="hljs-built_in">size</span>(X)<br>#求方阵X的行列式<br>d = det(X)<br>#求矩阵X的秩<br>r = rank(X)<br>#求矩阵X的迹，即矩阵的主对角线元素之和<br>T = trace(X)<br>#求主对角线元素组成的列向量<br>d = <span class="hljs-built_in">diag</span>(X)<br>#将矩阵X按列排成m X n维矩阵Y，要求X的元素个数为m X n<br>Y = <span class="hljs-built_in">reshape</span>(X,m,n)<br>#求可逆方阵X的逆矩阵<br>XT = inv(X)<br>#求m*n维矩阵X的伪逆矩阵Y，Y是n*m维的<br>Y = pinv(X)<br>#求矩阵X的lp范数，默认p=<span class="hljs-number">2</span><br>n = norm(X,p)<br>#求矩阵X的Frobenius范数，即将所有X的元素平方和开根号<br>n = norm(X,<span class="hljs-string">&#x27;fro&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs matlab">#m*n维<span class="hljs-number">0</span>矩阵<br>A = <span class="hljs-built_in">zeros</span>(m,n)<br>#m*n维全<span class="hljs-number">1</span>矩阵<br>A = <span class="hljs-built_in">ones</span>(m,n)<br>#m*n维全无穷大矩阵<br>A = <span class="hljs-built_in">inf</span>(m,n)<br>#m*n维不定值矩阵<br>A = <span class="hljs-built_in">nan</span>(m,n)<br>#m*n维随机矩阵，元素服从（<span class="hljs-number">0</span>，<span class="hljs-number">1</span>）区间上的均匀分布<br>A = <span class="hljs-built_in">rand</span>(m,n)<br>#m*n维随机矩阵，元素服从均值为<span class="hljs-number">0</span>，标准差为<span class="hljs-number">1</span>的正态分布<br>A = <span class="hljs-built_in">randn</span>(m,n)<br>#生成m*n维单位矩阵<br>A = <span class="hljs-built_in">eye</span>(m,n)<br>#m阶杨辉三角矩阵<br>A = <span class="hljs-built_in">pascal</span>(x)<br>#向量x组成的范德蒙德矩阵<br>A = <span class="hljs-built_in">vander</span>(x)<br>#m阶魔术矩阵，即各行各列，对角线元素之和相等<br>A = <span class="hljs-built_in">magic</span>(m)<br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">#求转置矩阵，在矩阵后面加上.<span class="hljs-string">&#x27;</span><br><span class="hljs-string">A = [1,2,3;4,5,6]</span><br><span class="hljs-string">B = A.&#x27;</span><br>#求共轭转置矩阵，在矩阵后面加上<span class="hljs-string">&#x27;</span><br><span class="hljs-string">C = A&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">#提取第i行第j列的元素<br><span class="hljs-function"><span class="hljs-title">A</span><span class="hljs-params">(i,j)</span></span><br>#提取第i行的元素<br><span class="hljs-function"><span class="hljs-title">A</span><span class="hljs-params">(i,:)</span></span><br>#提取第j列的元素<br><span class="hljs-function"><span class="hljs-title">A</span><span class="hljs-params">(:,j)</span></span><br>#删除第j列的元素<br><span class="hljs-function"><span class="hljs-title">A</span><span class="hljs-params">(:,j)</span></span> = <span class="hljs-selector-attr">[]</span><br>#删除第<span class="hljs-number">1</span>和<span class="hljs-number">3</span>行的元素<br><span class="hljs-function"><span class="hljs-title">A</span><span class="hljs-params">([<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],:)</span></span> = <span class="hljs-selector-attr">[]</span><br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs matlab">#查找函数<span class="hljs-built_in">find</span>()<br>[I,J,K] = <span class="hljs-built_in">find</span>(A==<span class="hljs-number">10</span>) #其中A是一个矩阵<br>#查找出来的I是所在位置的行坐标，J是所在位置的列坐标，K是查找到的值<br><br>#子矩阵的表达形式，在表达式后面加上,:<br>B = A(A==<span class="hljs-number">10</span>,:) #这样B就是A中等于<span class="hljs-number">10</span>的表达式生成的子矩阵<br><br>#判断是否为素数：<span class="hljs-built_in">isprime</span>()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>matlab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>matlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数值分析-- 误差</title>
    <link href="/2022/03/07/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-%E8%AF%AF%E5%B7%AE/"/>
    <url>/2022/03/07/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-%E8%AF%AF%E5%B7%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="误差和误差限"><a href="#误差和误差限" class="headerlink" title="误差和误差限"></a>误差和误差限</h3><span id="more"></span><p>设X* 为X的一个近似值（可大于X也可小于X），有e* =  X-X* ,称e* 为<strong>绝对误差</strong>，简称<strong>误差</strong>。</p><p>易得出结论：当绝对误差大于0时，近似值大于真实值，称为<strong>强近似值</strong>；当绝对误差小于0时，近似值小于真实值，称为<strong>弱近似值</strong>。</p><p>误差的绝对值不超过某个正数E* ，称这个正数E<em>为近似值的*<em>误差限</em></em> </p><h3 id="相对误差和相对误差限"><a href="#相对误差和相对误差限" class="headerlink" title="相对误差和相对误差限"></a>相对误差和相对误差限</h3><p>**相对误差:*<em>指的是近似值e</em> 与真实值X的比值，称为e(r)*（右下角有个小r）</p><p><strong>相对误差限：</strong>相对误差不能超过相对误差限E(r)* ，E(r)* =E* / |x*|</p><h3 id="绝对误差的计算方法"><a href="#绝对误差的计算方法" class="headerlink" title="绝对误差的计算方法"></a>绝对误差的计算方法</h3><p><strong>注意：绝对误差限一定是一个单位的半个单位，如0.5，0.05，0.005，0.0005等等，那么换成科学计数法的形式就可以变成1/2 * 10^-p</strong></p><p><strong>（其中p取正整数！）这时，-p就可以换成另一种表示方法，-p = m-n+1  （其中m是小数点离第一个非0数字的后一位有多远，如123.45的m就是2，而0.00123的m就是-3）（其中n是有几位有效数字如123.45就有5为有效数字，那么n就是5.）通常情况下都是知道了m和n要去求p的！！</strong></p><p>例如“派”取近似值3.14，那么|3.14-“派”| = 0.0015926&lt;=0.005=1/2 * 10^-2，则绝对误差限就是1/2 * 10^-2</p><h3 id="相对误差的计算方法"><a href="#相对误差的计算方法" class="headerlink" title="相对误差的计算方法"></a>相对误差的计算方法</h3><p>若近似值有n为有效数字，其中a是近似值的个位数。</p><p>E(r)*&lt;=1/2a * 10^-(n-1)</p><h3 id="误差估计中的重要公式"><a href="#误差估计中的重要公式" class="headerlink" title="误差估计中的重要公式"></a>误差估计中的重要公式</h3><p>E(x1* +- x2* ) = E(x1* ) +- E(x2*)</p><p><em><em>E(x1</em> * x2</em> ) = |x1*| * E(x2*) + |x2 *| * E(x1 *)**这个公式在平常的运算中常常能用得上。</p><p>E(x1* / x2* ) = |x1*| * E(x2*) + |x2 *| * E(x1 *) / |x2 *|^2    这是上面那一条的除法运算</p><h3 id="误差中的规则"><a href="#误差中的规则" class="headerlink" title="误差中的规则"></a>误差中的规则</h3><p>1.要避免除数的绝对值远远小于被除数绝对值的除法</p><p>2.避免出现有效数字少的相减如x=123.401,  y = 123.412  ，那么y-x =0.011只有两位有效数字。</p><p>3.防止大数吃掉小数</p><p>4.注意简化运算流程，简化运算步骤</p>]]></content>
    
    
    <categories>
      
      <category>数值分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数值分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习-- numpy库</title>
    <link href="/2022/03/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-numpy%E5%BA%93/"/>
    <url>/2022/03/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-numpy%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>学习numpy库的主要目的是为了后面学习pandas库打下基础</p><span id="more"></span><h3 id="python中数组、元组、列表的区别"><a href="#python中数组、元组、列表的区别" class="headerlink" title="python中数组、元组、列表的区别"></a>python中数组、元组、列表的区别</h3><p><strong>首先要知道python中是没有数组的</strong></p><p>列表和元组的区别：列表中可以append元素，可以pop元素，而元组做不到，只能对元组元素进行索引而不能对它赋值！</p><p><strong>创建数组的第一种方式</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]  <span class="hljs-comment">#创建一个列表a</span><br>b = np.array([<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>])   <span class="hljs-comment">#通过array创建数组</span><br><span class="hljs-built_in">print</span>(a)<span class="hljs-comment">#[1,2,3]-&gt;这是列表的表现形式</span><br><span class="hljs-built_in">print</span>(b)<span class="hljs-comment">#[4 5 6]-&gt;这是数组的表现形式</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(a))<span class="hljs-comment">#class = list</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(b))<span class="hljs-comment">#class = numpy.ndarray</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#数组和列表的切片都遵循左闭右开的元组</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>b = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br><span class="hljs-built_in">print</span>(a[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]) <span class="hljs-comment">#因为左闭右开所以是[1,2]</span><br><span class="hljs-built_in">print</span>(b[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>])<span class="hljs-comment">#因为左闭右开所以是[1 2],注意和列表的表达形式不一样</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#数组*2</span><br>a = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])*<span class="hljs-number">2</span><span class="hljs-comment">#[2,4,6]</span><br>b = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<span class="hljs-comment">#[1,2,3,1,2,3]</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#二维数组</span><br>x = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]]) <span class="hljs-comment">#生成的结构是二维的，即不止一行</span><br><span class="hljs-comment">#对应的列表中的就是小列表了</span><br>y = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]]  <span class="hljs-comment">#就产生一行而已</span><br></code></pre></td></tr></table></figure><p><strong>创建数组的第二种方式</strong>（arange通过步长来创建）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#使用np.arange可以传递1~3个参数</span><br><span class="hljs-comment">#1个参数,那么这个参数就是终止值，起始值默认是0，步长默认是1</span><br>x = np.arange(<span class="hljs-number">5</span>)<span class="hljs-comment">#相当于np.arange(0,5,1)</span><br><span class="hljs-comment">#2个参数，第一个参数是初始值，第二个参数是终止值，步长默认为1</span><br>x = np.arange(<span class="hljs-number">5</span>,<span class="hljs-number">10</span>)<span class="hljs-comment">#相当于np.arange(5,10,1)</span><br><span class="hljs-comment">#3个参数，第一个参数是初始值，第二个参数是终止值，第三个参数是步长</span><br>x = np.arange(<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0.5</span>)<br></code></pre></td></tr></table></figure><p><strong>创建数组的第三种方式</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#使用np.random可以创建随机一维数组</span><br><span class="hljs-comment">#例如使用np.random.randn(n)可以创建n个服从标准正态分布(均值为0，标准差为1)的随机数</span><br>np.random.randn(<span class="hljs-number">3</span>)<span class="hljs-comment">#创建服从标准正态分布的3个随机数</span><br><span class="hljs-comment">#如果把randn改成rand（n），即为创建n个处于0~1的随机数</span><br><br><span class="hljs-comment">#想要转换成二维随机数，可以用创建一维数组的arange和转变成二维数组的reshape来实现。</span><br>a = np.arange(<span class="hljs-number">20</span>).reshape(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)<span class="hljs-comment">#reshape的第一个参数是行数，第二个参数是列数，如这个例子就是创建3行4列的二维数组</span><br><span class="hljs-comment">#np.random.randint用于创建随机整数（注意是随机）</span><br>np.random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>,(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>))<span class="hljs-comment">#第一个参数是初始值，第二个参数是终止值，（4，4）则是创建为4X4的二维向量</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>machine leaning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>machine leaning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>统计学 -- 导论</title>
    <link href="/2022/03/04/%E7%BB%9F%E8%AE%A1%E5%AD%A6-%E5%AF%BC%E8%AE%BA/"/>
    <url>/2022/03/04/%E7%BB%9F%E8%AE%A1%E5%AD%A6-%E5%AF%BC%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="统计数据的类型"><a href="#统计数据的类型" class="headerlink" title="统计数据的类型"></a>统计数据的类型</h3><span id="more"></span><h4 id="计量尺度分类"><a href="#计量尺度分类" class="headerlink" title="计量尺度分类"></a>计量尺度分类</h4><p><strong>1.分类数据：</strong></p><p>​    分类数据是只能归于某一类别的数据，通常把数据划分为不同的数据类型，如：金融业，制造业，计算机业等等。</p><p><strong>2.数值数据：</strong><br>    结果表现为具体的数值。数值数据又分为离散数值和连续数值，离散数值是一个个单独的数据不连贯的，连续数值是连起来的，通常不能一一列举！</p><h4 id="收集方法分类"><a href="#收集方法分类" class="headerlink" title="收集方法分类"></a>收集方法分类</h4><p><strong>1.观测数据：</strong></p><p>​    是通过调查或者观察从而得到的数据，这类数据通常没有人为参与和控制。</p><p><strong>2.实验数据：</strong></p><p>​    在实验中控制实验对象从而得到的实验数据，自然科学领域大多数都是实验数据。</p><h4 id="现象与时间关系分类"><a href="#现象与时间关系分类" class="headerlink" title="现象与时间关系分类"></a>现象与时间关系分类</h4><p><strong>1.截面数据：</strong></p><p>指在同一时间或者是相隔很近的时间点上收集的数据。这类数据通常是在不同的时空上收集的，描述某一时刻的某事务的变化情况。</p><p><strong>2.时间序列数据：</strong></p><p>是在不同时间收集的数据，表现事务随着时间的变化情况。如2012-2022年我国的人均GDP情况就是时间序列数据。</p><h3 id="总体和样本"><a href="#总体和样本" class="headerlink" title="总体和样本"></a>总体和样本</h3><p><strong>1.总体：</strong></p><p>​    是包含所研究的全部个体（数据）的集合，通常由多个个体组成。</p><p><strong>2.样本：</strong><br>    样本是从总体中抽取的一部分元素的集合，构成样本的元素的数目称为<strong>样本量</strong>。</p><h3 id="参数和统计量"><a href="#参数和统计量" class="headerlink" title="参数和统计量"></a>参数和统计量</h3><p><strong>1.参数：</strong><br>    用来描述总体特征的数字度量。是观察者想要了解的某种特征值。</p><p><strong>2.统计量：</strong></p><p>​    用来描述样本特征的数字度量。表示样本的特征值。</p><h3 id="变量和其分类"><a href="#变量和其分类" class="headerlink" title="变量和其分类"></a>变量和其分类</h3><p><strong>1.变量：</strong>指某种<strong>特征</strong>的概念，如商品的销售额可以是五十万或者六十万。</p><p>2.变量的分类：</p><p>​    （1）分类变量：如客户的满意程度可以分类成：“很好”，“还行”，“一般”，“较差”，“很差”。</p><p>​    （2）数值变量：可以用数值表示的变量：生活费支出，骰子的点数。</p><h3 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h3><p>1.任何一个总体中都包含一个非随机变量，例如调查广西大学的学生，那么其中都是广西大学的学生，这个变量（来自广西大学）就是一个非随机变量。</p><p>2.<strong>总体单位=个体！！</strong></p><p>3.<strong>统计指标反映总体数量特征概念</strong>，分为两类：</p><p>​    （1）数量指标-&gt;总体GDP</p><p>​    （2）质量指标-&gt;人均GDP</p><p>4.统计指标的构成如下：时间限制，空间限制，计算方法，指标名称，数值，计量单位</p>]]></content>
    
    
    <categories>
      
      <category>统计学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>统计学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构--线性表</title>
    <link href="/2022/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2022/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="线性表的基础内容及应用"><a href="#线性表的基础内容及应用" class="headerlink" title="线性表的基础内容及应用"></a>线性表的基础内容及应用</h1><span id="more"></span><h2 id="基础知识（重点！！）"><a href="#基础知识（重点！！）" class="headerlink" title="基础知识（重点！！）"></a>基础知识（重点！！）</h2><p>1.ElemType是你<strong>自己定义</strong>的数据类型，想用什么用什么，使用typedef定义，如<strong>typedef int ElemType</strong></p><p>2.数组的静态分配和动态分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//静态分配,很好理解</span><br>ElemType data[MAXSIZE];<br><br><span class="hljs-comment">//静态分配，难理解！</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>ElemType *data;<br><span class="hljs-type">int</span> length;<br>&#125;sqList;<br><span class="hljs-comment">//接着上面的，在动态分配的固定的函数给他分配内存！</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 100</span><br>sqList L;<br>L.data = (ElemType*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(ElemType)*MaxSize);<span class="hljs-comment">//其中ElemType*表示强制类型转换，因为在定义的时候是指针类型的！</span><br></code></pre></td></tr></table></figure><p>3.接上！内存分配函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//下列三个函数都是要在加载头文件&lt;stdlib.h&gt;的前提下</span><br><span class="hljs-comment">//malloc(m)函数:开辟m字节长度的地址空间，并返回这段空间的首地址！</span><br><span class="hljs-comment">//sizeof(x)函数:计算变量x的长度</span><br><span class="hljs-comment">//free(p)函数:释放指针p所指变量的存储空间，即删除一个变量</span><br></code></pre></td></tr></table></figure><p>4.C++的动态存储分配：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//创建空间--new</span><br><span class="hljs-keyword">new</span> 类型名（初值列表）<br>    功能：<br>    申请用于存放T类型对象的内存空间，并赋予初值<br>    结果值：<br>    成功：T类型的指针，指向新分配的内存<br>    失败：<span class="hljs-number">0</span> <br><span class="hljs-comment">//如int *p1 = new int;</span><br>    <br><span class="hljs-comment">//删除空间--delete</span><br>    <span class="hljs-keyword">delete</span> 指针P<br>    功能：<br>    释放指针P所指向的内存，P必须是<span class="hljs-keyword">new</span>操作的返回值<br></code></pre></td></tr></table></figure><h3 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h3><p>线性表：<strong>零个或多个</strong>数据元素的<strong>有限序列</strong></p><p>线性表中的元素有且只有一个直接前驱和直接后继（除了线性表中的第一个和最后一个元素）</p><p><strong>线性表元素的个数n定义为线性表的长度为n。当n=0时，线性表为空表！</strong></p><p>在比较复杂的线性表当中，一个数据元素可以由若干个数据项组成！</p><h3 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的抽象数据类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">ADT 线性表(List)<br>Data<br>线性表的数据对象的集合为&#123;a1,a2,..,an&#125;,每个元素的类型均为DataType，其中，除了第一个元素a1外，每个元素有且只有一个直接前驱元素，除了最后一个元素an外，每个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。<br>Operation<br>    <span class="hljs-title function_">InitList</span><span class="hljs-params">(*L)</span>:初始化操作，建立一个空的线性表L。<br>    <span class="hljs-title function_">DestroyList</span><span class="hljs-params">(*L)</span>:销毁一个线性表。<br>    <span class="hljs-title function_">ListEmpty</span><span class="hljs-params">(L)</span>:判断线性表是否为空表，若线性表为空，返回<span class="hljs-literal">true</span>，否则返回<span class="hljs-literal">false</span>。<br>    <span class="hljs-title function_">CleanList</span><span class="hljs-params">(*L)</span>:将线性表清空。<br>    <span class="hljs-title function_">GetElem</span><span class="hljs-params">(L,i,*e)</span>:将线性表L中的第i个元素值返回给e。<br>    <span class="hljs-title function_">LocateElem</span><span class="hljs-params">(L,e)</span>:在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则返回0表示失败！<br>    <span class="hljs-title function_">priorElem</span><span class="hljs-params">(L,cur_e,*pre_e)</span>:如果cur_e不是线性表中的第一个元素，那么返回它的直接前驱，否则操作失败！<br>    <span class="hljs-title function_">NextElem</span><span class="hljs-params">(L,cur_e,*next_e)</span>:如果cur_e不是线性表中的最后一个元素，那么返回它的直接后继，否则操作失败！<br>    <span class="hljs-title function_">ListInsert</span><span class="hljs-params">(*L,i,e)</span>:在线性表L中的第i个位置插入新元素e。<br>    <span class="hljs-title function_">ListDelete</span><span class="hljs-params">(*L,i,*e)</span>:删除在线性表L中第i个位置元素，并用e返回其值。<br>    <span class="hljs-title function_">ListLength</span><span class="hljs-params">(L)</span>:返回线性表L的元素个数。<br>endADT<br></code></pre></td></tr></table></figure><h3 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h3><p>顺序存储的定义：在逻辑结构上相邻的数据储存在物理位置也相邻的地方</p><h4 id="顺序表中存储位置的计算（重点！）"><a href="#顺序表中存储位置的计算（重点！）" class="headerlink" title="顺序表中存储位置的计算（重点！）"></a>顺序表中存储位置的计算（重点！）</h4><p>如果每个元素占用8个存储单元，已知ai的存储位置是2000，问a（i+1）的存储位置</p><p>答：a(i+1) = ai + 8  = 2008</p><p>假设每个元素占用L个存储单元，已知第一个元素的位置，求第i个元素的位置：</p><p>*<em>LOC(ai) = LOC(a1) + (i-1)<em>L</em></em></p><h4 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">long</span> num;<br><span class="hljs-type">char</span> name[<span class="hljs-number">10</span>];<br><span class="hljs-type">char</span> gender;<br><span class="hljs-type">float</span> score;<br>&#125;stu=&#123;<span class="hljs-number">01</span>;<span class="hljs-string">&quot;dgz&quot;</span>;<span class="hljs-string">&#x27;男&#x27;</span>;<span class="hljs-number">90</span>&#125;   <span class="hljs-comment">//这里使用了尾随法来给结构体类型赋值</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> *<span class="hljs-title">p</span>;</span>    <span class="hljs-comment">//创建一个结构体指针</span><br>p = &amp;stu;<span class="hljs-comment">//这个结构体指针指向的是结构体变量stu</span><br><span class="hljs-comment">//现在我们想使用指针调用结构体变量stu中的num变量，有三种方法</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld\n&quot;</span>,stu.num);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld\n&quot;</span>,*p.num);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld\n&quot;</span>,p -&gt; num);<br></code></pre></td></tr></table></figure><h4 id="顺序结构的代码-very-very-important"><a href="#顺序结构的代码-very-very-important" class="headerlink" title="顺序结构的代码(very very important!!!)"></a>顺序结构的代码(very very important!!!)</h4><p><strong>标准格式(下面所有的代码全部以他为依据！)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    ElemType data[MAXSIZE];<br>    <span class="hljs-type">int</span> length;<br>&#125;sqList;<br></code></pre></td></tr></table></figure><p><strong>用e返回线性表L中的第i个元素</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;<br>Status <span class="hljs-title function_">GetElem</span><span class="hljs-params">(sqList L,<span class="hljs-type">int</span> i,ElemType *e)</span>&#123;<br>    <span class="hljs-keyword">if</span>(i&gt;L-&gt;length<span class="hljs-number">-1</span> || i&lt;<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">1</span> &amp;&amp; i&lt;=L-&gt;length<span class="hljs-number">-1</span>)&#123;<br>        e = L-&gt;data[i<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">return</span> OK;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="顺序结构的插入（重点！）"><a href="#顺序结构的插入（重点！）" class="headerlink" title="顺序结构的插入（重点！）"></a>顺序结构的插入（重点！）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始条件：L存在，1&lt;=i&lt;=ListLength(L)</span><br><span class="hljs-comment">//操作结果：在L中第i个位置之前插入新的元素e，L长度加一</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status<br>Status <span class="hljs-title function_">ListInsert</span><span class="hljs-params">(SqList *L,<span class="hljs-type">int</span> i,ElemType *e)</span>&#123;<br><span class="hljs-type">int</span> k;<br><span class="hljs-keyword">if</span>(L-&gt;length==MAXSIZE)<span class="hljs-comment">//如果线性表满了插不进去</span><br>        <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span> || i&gt;L-&gt;length+<span class="hljs-number">1</span>)<span class="hljs-comment">//如果元素在线性表外，也插不进去</span><br>        <span class="hljs-keyword">return</span> OK;<br>    <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">1</span> &amp;&amp; i&lt;=length+<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">for</span>(k=L-&gt;length<span class="hljs-number">-1</span>;k&gt;=i<span class="hljs-number">-1</span>;k--)&#123;<br>            data[k+<span class="hljs-number">1</span>] = data[k];<br>        &#125;<br>        L-&gt;length = L-&gt;length+<span class="hljs-number">1</span>;<br>        L-&gt;data[i<span class="hljs-number">-1</span>] = e;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="顺序结构的删除"><a href="#顺序结构的删除" class="headerlink" title="顺序结构的删除"></a>顺序结构的删除</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//删除i位置的元素，并用</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;<span class="hljs-comment">//Status当作int类型</span><br>ListDelete(sqList *L,<span class="hljs-type">int</span> i,ElemType *e)&#123;<br>    <span class="hljs-type">int</span> k;<br>    <span class="hljs-keyword">if</span>(L-&gt;length==<span class="hljs-number">0</span> || i&lt;<span class="hljs-number">1</span> || i&gt;L-&gt;length)<br>        <span class="hljs-keyword">return</span> ERROR;<br>    *e = L-&gt;data[i<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">if</span>(L-&gt;length&gt;i &amp;&amp; i&gt;<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">for</span>(k=i;k&lt;=L-&gt;length<span class="hljs-number">-1</span>;k++)&#123;<br>            L-&gt;data[k<span class="hljs-number">-1</span>] = L-&gt;data[k];<br>        &#125;<br>    &#125;<br>    L-&gt;length--;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="插入和删除的时间复杂度"><a href="#插入和删除的时间复杂度" class="headerlink" title="插入和删除的时间复杂度"></a>插入和删除的时间复杂度</h5><p>最简单的情况：插在最后一个元素位置，时间复杂度是O（1）</p><p>最复杂的情况：插在第一个元素位置，时间复杂度是O（n）</p><p>平均下来的时间复杂度是：(n+1)/2，即O（n）</p><h4 id="线性表顺序存储的优缺点"><a href="#线性表顺序存储的优缺点" class="headerlink" title="线性表顺序存储的优缺点"></a>线性表顺序存储的优缺点</h4><p>优点：1.无需为表中元素之间的逻辑关系而增加额外的存储空间；</p><p>​            2.可以快速的查找任意元素的位置</p><p>缺点：1.插入和删除操作需要移动大量的元素</p><p>​            2.当线性表长度变化太大时，难以确定存储空间的变化！</p><p>​            3.造成存储空间的“碎片化”。</p><h3 id="线性表的链式存储"><a href="#线性表的链式存储" class="headerlink" title="线性表的链式存储"></a>线性表的链式存储</h3><h4 id="链式存储的定义"><a href="#链式存储的定义" class="headerlink" title="链式存储的定义"></a>链式存储的定义</h4><p>​    为了表示ai和ai+1之间的关系，对于ai来说，除了存储本身的数据，还需要存储一个指向下一个数据元素的指针，我们把ai中存储数据的域叫做<strong>数据域</strong>，把存储指针的域叫做<strong>指针域</strong>，把指针域中的数据叫做<strong>指针或链</strong>，这两部分信息组成数据元素ai的存储映像，称为<strong>结点</strong>。</p><p>​    n个结点链接成一个链表，即为线性表的链式存储，每个结点中值包含一个指针域，称为<strong>单链表</strong>。</p><p>​    链表中第一个结点的存储位置称为<strong>头指针</strong></p><p>​    链表中最后一个结点的存储位置为空，用<strong>NULL或者^</strong>表示</p><p>​    <strong>如a|b -&gt; c|d -&gt; e|f    这个案例中a|b就是头结点，b就是头指针。头节点中的数据域a一般不存放数据</strong></p><p>​    如果线性表为空表，那么头结点的指针为空指针</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><h4 id="链式存储的代码（重点！）"><a href="#链式存储的代码（重点！）" class="headerlink" title="链式存储的代码（重点！）"></a>链式存储的代码（重点！）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//线性表单链表的存储结构之定义单链表结点类型（一切的基础！）</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><span class="hljs-comment">//定义一个结构体</span><br>ElemType data;<span class="hljs-comment">//定义数据域</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//指针指向下一个结点</span><br>&#125;Node;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">LinkList</span>;</span><br></code></pre></td></tr></table></figure><p>假设p是指向下一个元素的指针，那么下一个元素的数据域表示为<strong>p-&gt;data</strong>，下一个元素的指针域表示为<strong>p-&gt;next</strong>，那么<strong>p-&gt;next-&gt;data</strong>就指向再下一个元素的数据域！</p><h5 id="查找元素并返回值GetElem"><a href="#查找元素并返回值GetElem" class="headerlink" title="查找元素并返回值GetElem()"></a>查找元素并返回值GetElem()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//链式存储中的用e返回第i个位置的元素操作！</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;<br>Status <span class="hljs-title function_">GetElem</span> <span class="hljs-params">(LinkList L,<span class="hljs-type">int</span> i,ElemType *e)</span>&#123;<br>    <span class="hljs-type">int</span> k;<br>    LinkList p;<span class="hljs-comment">//声明指针</span><br>    p = L-&gt;next;<span class="hljs-comment">//p指向线性表的第一个结点</span><br>    k = <span class="hljs-number">1</span>;<span class="hljs-comment">//k为计数器</span><br>    <span class="hljs-keyword">while</span>(p &amp;&amp; k&lt;i)<span class="hljs-comment">//p不为NULL且k没等于i时，循环继续</span><br>    &#123;<br>        p = p-&gt;next;<span class="hljs-comment">//p指向下一个结点,在最后一次循环的时候，其实指向的是第i-1个元素</span><br>        ++k;<span class="hljs-comment">//k递增</span><br>    &#125;<br>    <span class="hljs-keyword">while</span>(!p || k&gt;i)&#123;<br>        <span class="hljs-keyword">return</span> ERROR；<br>    &#125;<br>    *e = p-&gt;data;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-comment">//核心思想是指针的后移，这也是很多算法的实现方法。</span><br></code></pre></td></tr></table></figure><h5 id="不知道要循环多少次的循环别使用for，用while"><a href="#不知道要循环多少次的循环别使用for，用while" class="headerlink" title="不知道要循环多少次的循环别使用for，用while"></a>不知道要循环多少次的循环别使用for，用while</h5><h5 id="链式表的插入操作"><a href="#链式表的插入操作" class="headerlink" title="链式表的插入操作"></a>链式表的插入操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//先进行元素位置i的查找，找到时候进行插入新的元素e的赋值操作！</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;<br>Status <span class="hljs-title function_">ListInsert</span><span class="hljs-params">(LinkList *L,<span class="hljs-type">int</span> i,ElemType e)</span>&#123;<br>    <span class="hljs-type">int</span> k;<br>    LinkList p,s;<br>    p = *L<br>    <span class="hljs-keyword">while</span>(p &amp;&amp; k&lt;=i)&#123;<br>        p = p-&gt;next;<br>        ++k;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!p || k&gt;i)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    s = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node)); <span class="hljs-comment">//生成新结点（C标准函数）</span><br>    s-&gt;data = e;<br>    s-&gt;next = p-&gt;next;<br>    p-&gt;next = s;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="链式表的删除操作"><a href="#链式表的删除操作" class="headerlink" title="链式表的删除操作"></a>链式表的删除操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">ListDelete</span><span class="hljs-params">(LinkList *L,<span class="hljs-type">int</span> i,ElemType *e)</span>&#123;<br><span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;<br>LinkList p,q;<br>p = *L;<br><span class="hljs-keyword">while</span>(p-&gt;next &amp;&amp; k&lt;i)<br>&#123;<br>p = p-&gt;next;<br>k++;<br>&#125;<br><span class="hljs-keyword">if</span>(!(p-&gt;next) || k&gt;i)<br><span class="hljs-keyword">return</span> ERROR;<br>q = p-&gt;next;<span class="hljs-comment">//令q为要删除的结点</span><br>p-&gt;next = q-&gt;next;<br><span class="hljs-built_in">free</span>(q);<span class="hljs-comment">//释放q的空间</span><br><span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="单链表的整表创建"><a href="#单链表的整表创建" class="headerlink" title="单链表的整表创建"></a>单链表的整表创建</h5><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/* 随机产生n个元素的值，建立带表头结点的单链线性表L(头插法) */</span><br><span class="hljs-keyword">void</span> CreateListHead(LinkList *L,<span class="hljs-keyword">int</span> n)<br>&#123;<br>LinkList p;<br><span class="hljs-keyword">int</span> i;<br>srand(time(<span class="hljs-number">0</span>));<span class="hljs-comment">//初始化随机数种子</span><br>*L = (LinkList)malloc(sizeof(Node));<br>(*L)-&gt;<span class="hljs-keyword">next</span> = <span class="hljs-keyword">NULL</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>p=(LinkList)malloc(sizeof(Node));<br>p-&gt;data = rand() % <span class="hljs-number">100</span>+<span class="hljs-number">1</span>;<br>p-&gt;<span class="hljs-keyword">next</span> = (*L)-&gt;<span class="hljs-keyword">next</span>;<br>(*L)-&gt;<span class="hljs-keyword">next</span>=p;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构--基本概念</title>
    <link href="/2022/02/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2022/02/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="本章主要讲解数据结构和算法的基本概念，在文中标有-的是重点内容一定要熟记！"><a href="#本章主要讲解数据结构和算法的基本概念，在文中标有-的是重点内容一定要熟记！" class="headerlink" title="本章主要讲解数据结构和算法的基本概念，在文中标有*的是重点内容一定要熟记！"></a>本章主要讲解数据结构和算法的基本概念，在文中标有*的是重点内容一定要熟记！</h1><span id="more"></span><h2 id="数据结构知识点"><a href="#数据结构知识点" class="headerlink" title="数据结构知识点"></a>数据结构知识点</h2><h3 id="数据结构考纲"><a href="#数据结构考纲" class="headerlink" title="数据结构考纲"></a>数据结构考纲</h3><h4 id="数据结构的三要素（考点）"><a href="#数据结构的三要素（考点）" class="headerlink" title="数据结构的三要素（考点）"></a>数据结构的三要素（考点）</h4><p>1.<em>逻辑结构：分为线性结构和非线性结构。*<em>线性结构：线性表，栈，队列；非线性结构：树，图，集合</em></em></p><p>2.*存储结构（物理结构）</p><p>3.数据的运算</p><h4 id="数据结构的五个特征"><a href="#数据结构的五个特征" class="headerlink" title="数据结构的五个特征"></a>数据结构的五个特征</h4><p>有穷性，确定性，可行性，输入，输出</p><h4 id="效率的度量（重点-考点）"><a href="#效率的度量（重点-考点）" class="headerlink" title="效率的度量（重点+考点）"></a>效率的度量（重点+考点）</h4><p><strong>时间复杂度</strong>*和空间复杂度（<strong>时间复杂度是重中之重，选择题大题都会出现</strong>）</p><h2 id="数据结构知识点-1"><a href="#数据结构知识点-1" class="headerlink" title="数据结构知识点"></a>数据结构知识点</h2><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>1.数据：数据是<strong>信息的载体</strong>，是描述客观事物属性的数，字符及所有<strong>能输入到计算机中并被计算机程序识别</strong>和处理的符号集合。数据是计算机程序加工的原料。</p><p>（1）数值型数据：整数，实数等</p><p>（2）非数值型数据：符号，文字，图像，图形，声音等。其中文字，图像等可以通过编码的方式转换成为字符数据进行处理。</p><p>2.数据元素：<strong>数据元素</strong>是数据的基本单位，通常作为一个整体考虑。也称为<strong>记录</strong>、<strong>顶点</strong>、<strong>结点</strong>。</p><p>3.数据项：一个数据元素由若干个数据项组成，<strong>数据项</strong>是数据元素中不可分割的<strong>最小单位</strong>。</p><p>4.数据结构：<strong>数据结构</strong>是数据相互之间存在<strong>一种或多种特定关系</strong>的数据元素的集合。 </p><p>（1）<strong>逻辑结构</strong>：数据元素之间的逻辑关系</p><p>​    <strong>a.线性结构</strong>：有且仅有一个开始和一个终端结点，并且所有节点最多只有一个之间前趋和一个直接后继。</p><p>​                            例如：<strong>线性表（一对一）、栈、队列、串</strong></p><p>​    <strong>b.非线性结构</strong>：一个结点可能有多个直接前趋和直接后继</p><p>​                            例如：<strong>树（一对多）、图（多对多）</strong></p><p>（2）<strong>物理结构</strong>（存储结构）：数据元素及其关系在计算机内存中的表示。</p><p>​    <strong>a.顺序存储结构</strong>：用一组<strong>连续</strong>的存储单元<strong>依次</strong>存储数据元素，数据元素之间的逻辑关系由元素的<strong>存储位置</strong>来表示，C中用数组来实现顺序存储关系。<strong>方便查找。</strong></p><p>​    <strong>b.链式存储结构</strong>：用任意的存储单元存储数据元素，数据元素之间的逻辑关系用<strong>指针</strong>表示，C用<strong>指针</strong>来实现链式存储结构。<strong>方便插入和删除。</strong></p><p>​    <strong>c.索引存储结构</strong>：需建立附加的索引表，索引表中每一项称为索引项，一般形式为（关键字，地址）</p><p>​    <strong>d.散列存储</strong>：根据关键字计算出结点的存储地址</p><p>5.数据对象：<strong>数据对象</strong>是具有<strong>相同性质</strong>的<strong>数据元素</strong>的集合，是数据的一个子集。如整数的数据对象是集合N={1,2,3,…}</p><p> 6.数据类型：是指一组性质相同的值的集合和定义在此集合上的一组操作的总称。</p><p>（1）原子类型：是不可以再分解的基本类型，包括整型（int），实型，字符型（char）等</p><p>（2）结构类型：由若干个类型组合而成，是可以再分解的。如整型数组是由若干个整型数据组成的</p><p>7.抽象数据类型（ADT）：抽象数据类型可用三元组（D，S，P）表示，D是数据对象，S是D上的关系集，P是对D的基本操作集。</p><p>​    抽象数据类型的标准格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">ADT 抽象数据类型名<br>    Data<br>        数据元素之间逻辑关系的定义<br>    Operation<br>        操作<span class="hljs-number">1</span><br>        初始条件<br>        操作结果描述<br>        操作<span class="hljs-number">2</span><br>        ...<br>        操作n<br>        ...<br>    endADT<br></code></pre></td></tr></table></figure><p><strong>综上：数据&gt;数据对象&gt;数据元素&gt;数据项</strong></p><h2 id="算法知识点"><a href="#算法知识点" class="headerlink" title="算法知识点"></a>算法知识点</h2><h3 id="算法的基本概念"><a href="#算法的基本概念" class="headerlink" title="算法的基本概念"></a>算法的基本概念</h3><p>1.<strong>算法的定义：</strong>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且，每条指令表示一个或多个操作。</p><p>2.<strong>算法的特性：</strong>算法具有五个基本特性：<strong>输入</strong>，<strong>输出</strong>，<strong>有穷性</strong>，<strong>确定性</strong>，<strong>可行性</strong>。</p><p>​    （1）输入和输出：算法具有<strong>零个或多个</strong>输入，尽管大部分的函数都需要有输入。算法至少需要<strong>一个或多个</strong>输出，输出的形式可以是打印输出也可以是返回一个或多个值。</p><p>​    （2）有穷性：指算法在执行<strong>有限步骤</strong>之后，自动结束循环而不会出现无限循环，并且每个步骤在一个<strong>可接受的时间</strong>内。</p><p>​    （3）确定性：算法的每一个步骤都有确定的含义，<strong>不会出现二义性</strong>。即相同的输入只能出现相同的输出。</p><p>​    （4）可行性：算法的每一步都必须是<strong>可行</strong>的，即每一步都能够通过执行<strong>有限步骤</strong>完成。</p><h3 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h3><p>1.<strong>正确性</strong>：算法的正确性是指算法至少应该具有输入，输出和加工处理无歧义性，能正确反映问题的需求、得到问题的正确答案。</p><p>正确性的要求分为以下四点，按照难度依次递增：    </p><p>（1）算法程序没有语法错误。</p><p>（2）算法程序对于合法的输入能够产生符合其要求的结果。</p><p>（3）算法程序对于非法的输入数据能得出满足规格说明的结果。</p><p>（4）算法程序对于精心选择的，甚至刁难的程序都有满足要求的输出结果。</p><p>2.<strong>可读性</strong>：算法设计的另一目的是为了便于阅读、理解和交流。为了让别人看得懂啊。</p><p>3.<strong>健壮性</strong>（处理异常问题的能力）：当输入数据不合法时，算法也能做出相关的处理，而不是产生异常或莫名其妙的结果。</p><p>4.<strong>时间效率高和存储量低</strong>：设计算法应该尽量满足时间效率和存储量低的需求。</p><h3 id="算法效率的度量方法"><a href="#算法效率的度量方法" class="headerlink" title="算法效率的度量方法"></a>算法效率的度量方法</h3><p>1.事后统计方法：利用计算机的计时器功能，对算法的运行时间进行对比，从而得出算法效率的高低。</p><p>2.事前分析估计方法：在计算机程序编制之前，依据统计方法对算法进行估算。</p><p>​    下面我们来对比1+2+3+…+100的两种算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//算法一</span><br><span class="hljs-type">int</span> i,sum=<span class="hljs-number">0</span>,n=<span class="hljs-number">100</span>;<span class="hljs-comment">//执行1次</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//执行n+1次</span><br>    sum = sum + i;<span class="hljs-comment">//执行n次</span><br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,sum)<span class="hljs-comment">//执行一次</span><br>    <br><span class="hljs-comment">//一共执行了1+(n+1)+n+1 = 2n+3次，即n次</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//算法二</span><br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>,n = <span class="hljs-number">100</span>;<span class="hljs-comment">//执行一次</span><br>sum = (<span class="hljs-number">1</span>+n)*n/<span class="hljs-number">2</span>;<span class="hljs-comment">//执行一次</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,sum);<span class="hljs-comment">//执行一次</span><br><br><span class="hljs-comment">//执行了三次，即1次</span><br></code></pre></td></tr></table></figure><h3 id="算法中函数的渐近增长（重点！）"><a href="#算法中函数的渐近增长（重点！）" class="headerlink" title="算法中函数的渐近增长（重点！）"></a>算法中函数的渐近增长（重点！）</h3><p>定义：给定两个函数f(n)和g(n)，如果存在一个整数N，使得所有的n&gt;N，f(n)总是比g(n)大，那么我们说f(n)的增长渐近快于g(n).</p><p>对于算法A：2n^2+n 和 算法B：n^3+n^2 我们只需要看最高次幂的幂数，连与最高次项相乘的常数都不重要！</p><p><strong>综上可知：判断一个算法的效率时，我们只需观察最高阶项，而函数中的常数和其他次要项往往可以忽略不计！</strong></p><h3 id="算法的时间复杂度"><a href="#算法的时间复杂度" class="headerlink" title="算法的时间复杂度"></a>算法的时间复杂度</h3><p>使用O（）来体现算法时间复杂度的记法。</p><p>推导大O阶：</p><p>1.用常数1取代运行时间中的所有加法常数。</p><p>2.在修改后的运行次数函数中，只保留最高阶项。</p><p>3.如果最高阶项存在且不是1，则去除与这个项相乘的常数。</p><p><strong>得到的结果就是大O阶！</strong></p><h4 id="常数阶"><a href="#常数阶" class="headerlink" title="常数阶"></a>常数阶</h4><p>常数阶不论运行了10次20次100次都只能记作O(1)不能记作O(3)O(10)，初学者常常犯这样的错误</p><p><strong>对于分支结构而言，无论是真是假，时间复杂度都是O(1)</strong></p><h4 id="线性阶"><a href="#线性阶" class="headerlink" title="线性阶"></a>线性阶</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//线性阶的时间复杂度时O(n)</span><br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;&#125;<br></code></pre></td></tr></table></figure><h4 id="对数阶"><a href="#对数阶" class="headerlink" title="对数阶"></a>对数阶</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> count = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(count&lt;n)&#123;<br>count = count * <span class="hljs-number">2</span>;<span class="hljs-comment">//因为2^x=n，所以x=log2(n),即O(logn)</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="平方阶"><a href="#平方阶" class="headerlink" title="平方阶"></a>平方阶</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">#平方阶的时间复杂度是O(n^<span class="hljs-number">2</span>)<br><span class="hljs-type">int</span> i,j;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>&#123;<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//一个比较常见的时间复杂度判断</span><br><span class="hljs-type">int</span> i,j;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(j=i;j&lt;n;j++)&#123;<span class="hljs-comment">//当i=0，执行n次，当i=1，执行n-1次...总执行次数是等差数列求和问题，n(n+1)/2=n^2/2 + n/2,所以O(n^2).</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数列知识点（做题的基础）"><a href="#数列知识点（做题的基础）" class="headerlink" title="数列知识点（做题的基础）"></a>数列知识点（做题的基础）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//等差数列的计算：前n项和等于n(n+1)/2</span><br><span class="hljs-comment">//等比数列的前n项和：(a1-an*q)/(1-q)</span><br></code></pre></td></tr></table></figure><h4 id="时间复杂度所耗费的时间"><a href="#时间复杂度所耗费的时间" class="headerlink" title="时间复杂度所耗费的时间"></a>时间复杂度所耗费的时间</h4><p>O(1)&lt;O(log n)&lt;O(n)&lt;O(n*log n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>要做好大O阶时间复杂度的题目，要学好数列的相关知识</p><h3 id="算法的空间复杂度"><a href="#算法的空间复杂度" class="headerlink" title="算法的空间复杂度"></a>算法的空间复杂度</h3><p>算法空间复杂度的计算公式为S(n) = O(f(n))，其中n为问题的规模，f(n)是n所占存储空间的函数。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python--函数</title>
    <link href="/2022/02/19/python-%E5%87%BD%E6%95%B0/"/>
    <url>/2022/02/19/python-%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="函数的基本操作"><a href="#函数的基本操作" class="headerlink" title="函数的基本操作"></a><strong>函数的基本操作</strong></h2><span id="more"></span><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#使用def来定义一个函数myfun,来实现x的累加</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">myfunadd</span>(<span class="hljs-params">x</span>):<br>x = x + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#位置参数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">a,b,c</span>):<br>    <span class="hljs-keyword">return</span><span class="hljs-string">&quot;&quot;</span>.join((c,b,a)) <span class="hljs-comment">#使用join表示在后面添加字符串</span><br><span class="hljs-built_in">print</span>(func(<span class="hljs-string">&quot;我&quot;</span>, <span class="hljs-string">&quot;是&quot;</span>, <span class="hljs-string">&quot;你&quot;</span>))<br><br><span class="hljs-comment">#帮助函数中的/:代表着/的左边不能指定参数的名字，只能指定其值，但是/的右边就无所谓了。</span><br><span class="hljs-comment">#我们还可以用*来代替/ *的左边不能用参数的名字，但是右边要用</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">a,*,b,c</span>):<br><span class="hljs-built_in">print</span>(a,b,c)<br>fun(<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;g&quot;</span>) <span class="hljs-comment">#error,第二第三个参数要加参数名字</span><br>fun(<span class="hljs-string">&quot;d&quot;</span>,b=<span class="hljs-string">&quot;e&quot;</span>,c=<span class="hljs-string">&quot;g&quot;</span>) <span class="hljs-comment">#d e g</span><br></code></pre></td></tr></table></figure><h3 id="收集参数"><a href="#收集参数" class="headerlink" title="收集参数"></a><strong>收集参数</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#收集函数即只指定一个参数，然后允许调用函数时传入任意数量的参数。在函数的形式参数之前加上*号即可</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">myfun</span>(<span class="hljs-params">*var</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;一共传入了&#123;&#125;个参数&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(var)))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;第二个参数是&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(var[<span class="hljs-number">1</span>]))<br><br><span class="hljs-comment">#注意只能指定一个带*号的参数，要是需要其他的形式参数，那么需要用到关键字参数。</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">myfun2</span>(<span class="hljs-params">*var,a,b</span>):<br>    <span class="hljs-built_in">print</span>(var,a,b)<br>myfun2(<span class="hljs-string">&quot;Deng&quot;</span>,a=<span class="hljs-string">&quot;Gao&quot;</span>,b=<span class="hljs-string">&quot;zheng&quot;</span>) <span class="hljs-comment">#像这样a和b使用了关键字参数即可</span><br><br><span class="hljs-comment">#在形式参数之前加上两个*代表着传入的参数可以自动转换成为字典</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">myfun</span>(<span class="hljs-params">**var</span>):<br>    <span class="hljs-built_in">print</span>(var) <span class="hljs-comment">#</span><br>myfun(a=<span class="hljs-number">1</span>,b=<span class="hljs-number">2</span>,c=<span class="hljs-number">3</span>) <span class="hljs-comment">#(&#x27;a&#x27;:&#x27;1&#x27;,&#x27;b&#x27;:&#x27;2&#x27;,&#x27;c&#x27;:&#x27;3&#x27;)即为字典形式</span><br><br><span class="hljs-comment">#综合</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">xing</span>(<span class="hljs-params">a,*b,**c</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a=&quot;</span>,a,<span class="hljs-string">&quot;b=&quot;</span>,b,<span class="hljs-string">&quot;c=&quot;</span>,c)<br>xing(<span class="hljs-string">&quot;deng&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,c=<span class="hljs-string">&quot;zheng&quot;</span>)<br></code></pre></td></tr></table></figure><p>#！！！个人总结：1.对于没有星的参数来说，在传入参数时只要出现“，”，那么就会自动跳到下一个参数！2.对于有一个星的参数来说，不能使用关键字参数来传递参数给它！！！否则会报错，它会自动收集剩下的数，即捡破烂。3.对于有两个*的参数来说，你必须要使用关键字参数来传递，因为它会让你的数变成字典！</p><p>综上：没有星无所谓使不使用关键字参数，有一个星不能使用关键字参数，两个星必须使用关键字参数。</p><h3 id="解包参数"><a href="#解包参数" class="headerlink" title="解包参数"></a>解包参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#先定义参数的值，然后再传递参数</span><br>var = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">a,b,c</span>):<br>    <span class="hljs-built_in">print</span>(a,b,c)<br>fun(*var)  <span class="hljs-comment">#1,2,3 这样就是解包啦！</span><br><br><span class="hljs-comment">#字典的解包</span><br>var = (<span class="hljs-string">&#x27;a&#x27;</span> = <span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span> = <span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span> = <span class="hljs-string">&#x27;3&#x27;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">a,b,c</span>):<br>    <span class="hljs-built_in">print</span>(a,b,c)<br>fun(**var)<br></code></pre></td></tr></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#在函数中定义函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">funA</span>():<br>    x = <span class="hljs-number">888</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">funB</span>(): <span class="hljs-comment">#这个funB函数的作用域就在funA中，外部调用funB会报错的。</span><br>    <span class="hljs-built_in">print</span>(x)<br>    funB() <br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">outer</span>():<br>    x=<span class="hljs-number">0</span><br>    y=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params">x1,y1</span>):<br>        <span class="hljs-built_in">print</span>(x,y)<br><span class="hljs-comment">#使用下列语句可以调用inner函数！</span><br>outer()() <span class="hljs-comment">#第一个括号表示调用outer函数，第二个括号表示inner函数</span><br></code></pre></td></tr></table></figure><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#函数中函数的名称可以做参数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">avg</span>(<span class="hljs-params">x,y</span>):<br>    <span class="hljs-keyword">return</span> (x+y)/<span class="hljs-number">2</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">函数名,x,y</span>):<br>    函数名(x,y)  <span class="hljs-comment">#我们这里把参数的名字当中函数名</span><br>f(avg,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>) <span class="hljs-comment">#这里实现的就是avg(2,4) = 3</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python--集合</title>
    <link href="/2022/02/17/python-%E9%9B%86%E5%90%88/"/>
    <url>/2022/02/17/python-%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="一些集合的基本操作"><a href="#一些集合的基本操作" class="headerlink" title="一些集合的基本操作"></a>一些集合的基本操作</h1><span id="more"></span><h2 id="set-的集合表示方法"><a href="#set-的集合表示方法" class="headerlink" title="set()的集合表示方法"></a>set()的集合表示方法</h2><h3 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#可以用&#123;&#125;或者set函数创建集合</span><br><span class="hljs-built_in">type</span>(&#123;<span class="hljs-string">&quot;Deng&quot;</span>&#125;) <span class="hljs-comment">#class=&quot;set&quot;</span><br>s = <span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;Deng&quot;</span>) <span class="hljs-comment">#class=&quot;set&quot;</span><br></code></pre></td></tr></table></figure><h3 id="集合的无序性"><a href="#集合的无序性" class="headerlink" title="集合的无序性"></a>集合的无序性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#创建一个集合并且按字符输出可以发现集合是无序的！</span><br>s = <span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;Deng&quot;</span>)<br>D <span class="hljs-keyword">in</span> s <span class="hljs-comment">#True</span><br>d <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> s <span class="hljs-comment">#True</span><br><span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> s:<br>    <span class="hljs-built_in">print</span>(each) <span class="hljs-comment"># n e D g 我们可以发现输出的结果是无序的，证明了集合的无序性！</span><br></code></pre></td></tr></table></figure><h3 id="集合会自动去重"><a href="#集合会自动去重" class="headerlink" title="集合会自动去重"></a>集合会自动去重</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>])) <span class="hljs-comment">#[1,2,3,4]就把多出来的3和4去掉了！</span><br></code></pre></td></tr></table></figure><h3 id="判断两个集合之间是否有关系"><a href="#判断两个集合之间是否有关系" class="headerlink" title="判断两个集合之间是否有关系"></a>判断两个集合之间是否有关系</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#先创建第一个集合</span><br>D = <span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;Deng&quot;</span>)<br><span class="hljs-comment">#使用isdisjoint方法判断两个集合之间是否有关系，具体如下</span><br>s.isdisjoint(<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;python&quot;</span>)) <span class="hljs-comment">#False代表两个集合之间是有相关的！判断的依据是两个集合之间有相关的元素重合，那么可见有n重合，所以两个集合之间是有相关的及false</span><br><span class="hljs-comment">#再判断JAVA</span><br>s.isdisjoint(<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;JAVA&quot;</span>)) <span class="hljs-comment">#True代表两个集合无关</span><br></code></pre></td></tr></table></figure><h3 id="检测两个集合是否有子集关系"><a href="#检测两个集合是否有子集关系" class="headerlink" title="检测两个集合是否有子集关系"></a>检测两个集合是否有子集关系</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#使用issubset方法，判断前面是否为后面的子集！</span><br>s = <span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;Deng&quot;</span>)<br><span class="hljs-comment">#判断s是否为后面的子集</span><br>s.issubset(<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;DengGaozheng&quot;</span>)) <span class="hljs-comment">#True说明s正是DengGaozheng的子集！</span><br></code></pre></td></tr></table></figure><h3 id="检测两个集合是否有超集关系"><a href="#检测两个集合是否有超集关系" class="headerlink" title="检测两个集合是否有超集关系"></a>检测两个集合是否有超集关系</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#用issuperset对于A和B来说，A中所有元素都在B中有出现，那么说明B是A的超集！</span><br>A = <span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;Deng&quot;</span>)<br>B = <span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;DengGaozheng&quot;</span>)<br>B.issuperset(A) <span class="hljs-comment">#True说明B是A的超集！</span><br></code></pre></td></tr></table></figure><h3 id="两个集合之间使用交集"><a href="#两个集合之间使用交集" class="headerlink" title="两个集合之间使用交集"></a>两个集合之间使用交集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#intersection方法</span><br>s = <span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;Deng&quot;</span>)<br>s.intersection(<span class="hljs-string">&quot;De&quot;</span>) <span class="hljs-comment">#&quot;De&quot;</span><br></code></pre></td></tr></table></figure><h3 id="两个集合之间使用并集"><a href="#两个集合之间使用并集" class="headerlink" title="两个集合之间使用并集"></a>两个集合之间使用并集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#union方法</span><br>s = <span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;Deng&quot;</span>)<br>s.union(<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;Gaozheng&quot;</span>)) <span class="hljs-comment">#&quot;DengGaozheng&quot;</span><br></code></pre></td></tr></table></figure><h3 id="两个集合之间使用差集"><a href="#两个集合之间使用差集" class="headerlink" title="两个集合之间使用差集"></a>两个集合之间使用差集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#difference方法，差集即存在于一个集合而不存在于另一个集合的元素</span><br>s = <span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;DengGao&quot;</span>)<br>s.difference(<span class="hljs-string">&quot;Deng&quot;</span>) <span class="hljs-comment">#&quot;Gao&quot;存在于s中而不存在于&quot;Deng&quot;中</span><br></code></pre></td></tr></table></figure><h3 id="管道符"><a href="#管道符" class="headerlink" title="管道符"></a>管道符</h3><p>| 管道符的作用是 把 管道符左边的的输出 当做右边命令后面待处理的结果。相当于并集的作用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;Deng&quot;</span><br>s | <span class="hljs-string">&quot;Gao&quot;</span> | <span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;zheng&quot;</span>) <span class="hljs-comment">#这串代码相当于s并&quot;Gao&quot;并set(&quot;zheng&quot;)，结果是&quot;DengGaozheng&quot;</span><br></code></pre></td></tr></table></figure><h3 id="专属于set的方法"><a href="#专属于set的方法" class="headerlink" title="专属于set的方法"></a>专属于set的方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#update()用来在set创建的集合里面更新元素</span><br>s = <span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;Deng&quot;</span>)<br>s.update(<span class="hljs-string">&quot;Gao&quot;</span>)<br><span class="hljs-built_in">print</span>(s) <span class="hljs-comment">#[&quot;Deng&quot;,&quot;G&quot;,&quot;a&quot;,&quot;o&quot;]</span><br><br><span class="hljs-comment">#add()用于添加元素</span><br>s = <span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;Deng&quot;</span>)<br>s.add(<span class="hljs-string">&quot;Gao&quot;</span>)<br><span class="hljs-built_in">print</span>(s) <span class="hljs-comment">#&quot;DengGao&quot;</span><br><br><span class="hljs-comment">#update和add都可以添加元素，但是区别在于update添加字符串时添加的是单个字符，add添加字符串时添加的是字符串。</span><br><br><span class="hljs-comment">#用remove方法删除集合中的元素,如果删除了不存在的元素，那么会抛出异常</span><br>s = [<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>]<br>s.remove(<span class="hljs-string">&quot;D&quot;</span>) <span class="hljs-comment">#[&#x27;e&#x27;,&#x27;n&#x27;,&#x27;g&#x27;]</span><br><br><span class="hljs-comment">#pop方法用于随机从集合中弹出一个元素(有点出栈的感觉)</span><br>s = [<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>]<br>s.pop() <span class="hljs-comment">#&#x27;e&#x27;</span><br>s.pop() <span class="hljs-comment">#&#x27;g&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="frozenset-的集合表示方法"><a href="#frozenset-的集合表示方法" class="headerlink" title="frozenset()的集合表示方法"></a>frozenset()的集合表示方法</h2><h3 id="创建frozenset集合"><a href="#创建frozenset集合" class="headerlink" title="创建frozenset集合"></a>创建frozenset集合</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#创建frozenset集合</span><br>s = <span class="hljs-built_in">frozenset</span>(<span class="hljs-string">&quot;Deng&quot;</span>)<br><span class="hljs-built_in">type</span>(s) <span class="hljs-comment">#class = frozenset</span><br></code></pre></td></tr></table></figure><h3 id="可哈希"><a href="#可哈希" class="headerlink" title="可哈希"></a>可哈希</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#整数哈希值：对于整数来说，哈希值永远等于自身的值</span><br><span class="hljs-built_in">hash</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">#1</span><br><span class="hljs-built_in">hash</span>(<span class="hljs-number">1.0</span>) <span class="hljs-comment">#1.0</span><br><br><span class="hljs-comment">#列表是不可哈希的</span><br><span class="hljs-built_in">hash</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]) <span class="hljs-comment">#error!</span><br><br><span class="hljs-comment">#哈希配合frozenset可以实现嵌套的集合，这在set里面是实现不了的！</span><br>x = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br>x = <span class="hljs-built_in">frozenset</span>(x)<br>y = &#123;x,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br><span class="hljs-built_in">print</span>(y)  <span class="hljs-comment">#&#123;forzenset(&#123;1,2,3&#125;),4,5&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python--字典</title>
    <link href="/2022/02/16/python-%E5%AD%97%E5%85%B8/"/>
    <url>/2022/02/16/python-%E5%AD%97%E5%85%B8/</url>
    
    <content type="html"><![CDATA[<h2 id="字典是另一种可变容器模型，且可存储任意类型对象。"><a href="#字典是另一种可变容器模型，且可存储任意类型对象。" class="headerlink" title="字典是另一种可变容器模型，且可存储任意类型对象。"></a>字典是另一种可变容器模型，且可存储任意类型对象。</h2><span id="more"></span><p>字典的每个键值 <strong>key=&gt;value</strong> 对用冒号 <strong>:</strong> 分割，每个对之间用逗号(<strong>,</strong>)分割，整个字典包括在花括号 <strong>{}</strong> 中 ,格式如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">d = &#123;key1 : value1, key2 : value2, key3 : value3 &#125;<br></code></pre></td></tr></table></figure><p>在字典中，键是不变的，但是键值是可变的。</p><p>下面是一个简单的字典例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">myinformation = &#123;<span class="hljs-string">&#x27;name&#x27;</span> = <span class="hljs-string">&#x27;denggaozheng&#x27;</span>,<span class="hljs-string">&#x27;number&#x27;</span> = <span class="hljs-string">&quot;01&quot;</span>,<span class="hljs-string">&#x27;grade&#x27;</span> = <span class="hljs-string">&#x27;freshman&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="字典的一些操作"><a href="#字典的一些操作" class="headerlink" title="字典的一些操作"></a>字典的一些操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用大括号 &#123;&#125; 来创建空字典</span><br>emptyDict = &#123;&#125;<br> <br><span class="hljs-comment"># 打印字典</span><br><span class="hljs-built_in">print</span>(emptyDict)<span class="hljs-comment">#&#123;&#125;</span><br> <br><span class="hljs-comment"># 查看字典的数量</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Length:&quot;</span>, <span class="hljs-built_in">len</span>(emptyDict))<span class="hljs-comment">#0</span><br> <br><span class="hljs-comment"># 查看类型</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(emptyDict))<span class="hljs-comment">#class = dict</span><br></code></pre></td></tr></table></figure><h3 id="使用内建函数dict来创建字典"><a href="#使用内建函数dict来创建字典" class="headerlink" title="使用内建函数dict来创建字典"></a>使用内建函数dict来创建字典</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">emptyDict = <span class="hljs-built_in">dict</span>()<br> <br><span class="hljs-comment"># 打印字典</span><br><span class="hljs-built_in">print</span>(emptyDict)   <span class="hljs-comment">#&#123;&#125;</span><br> <br><span class="hljs-comment"># 查看字典的数量</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Length:&quot;</span>,<span class="hljs-built_in">len</span>(emptyDict))<span class="hljs-comment">#0</span><br> <br><span class="hljs-comment"># 查看类型</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(emptyDict))<span class="hljs-comment">#class = dict</span><br></code></pre></td></tr></table></figure><h3 id="访问字典里面的值"><a href="#访问字典里面的值" class="headerlink" title="访问字典里面的值"></a>访问字典里面的值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#通常使用 字典名[key名]名来访问字典里的键值</span><br>di = &#123;<span class="hljs-string">&#x27;name&#x27;</span> = <span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;num&#x27;</span> = <span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;class&#x27;</span> = <span class="hljs-number">3</span>&#125;<br><span class="hljs-comment">#现在我们访问name里的值</span><br>di[<span class="hljs-string">&#x27;name&#x27;</span>] <span class="hljs-comment">#就是这么简单</span><br><br><span class="hljs-comment">#如果访问的是字典里面没有的键，那么会报错！</span><br>di = &#123;<span class="hljs-string">&#x27;name&#x27;</span> = <span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;num&#x27;</span> = <span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;class&#x27;</span> = <span class="hljs-number">3</span>&#125;<br>di[<span class="hljs-string">&#x27;number&#x27;</span>] <span class="hljs-comment">#error</span><br></code></pre></td></tr></table></figure><h3 id="修改字典和删除字典"><a href="#修改字典和删除字典" class="headerlink" title="修改字典和删除字典"></a>修改字典和删除字典</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#修改字典</span><br>di = &#123;<span class="hljs-string">&#x27;name&#x27;</span> = <span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;num&#x27;</span> = <span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;class&#x27;</span> = <span class="hljs-number">3</span>&#125;<br>di[<span class="hljs-string">&#x27;name&#x27;</span> = <span class="hljs-string">&#x27;10&#x27;</span>]<br><span class="hljs-built_in">print</span>(di[<span class="hljs-string">&#x27;name&#x27;</span>])  <span class="hljs-comment">#10</span><br><br><span class="hljs-comment">#删除字典</span><br><span class="hljs-keyword">del</span> di[<span class="hljs-string">&#x27;name&#x27;</span>] <span class="hljs-comment"># 删除键 &#x27;Name&#x27;</span><br>di.clear()     <span class="hljs-comment"># 清空字典，但是字典还是保留着的</span><br><span class="hljs-keyword">del</span> di         <span class="hljs-comment"># 删除字典</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python--序列</title>
    <link href="/2022/02/15/python-%E5%BA%8F%E5%88%97/"/>
    <url>/2022/02/15/python-%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="包含了大部分的序列的操作和函数"><a href="#包含了大部分的序列的操作和函数" class="headerlink" title="包含了大部分的序列的操作和函数"></a>包含了大部分的序列的操作和函数</h2><span id="more"></span><h3 id="序列中-和-的操作和is，in函数"><a href="#序列中-和-的操作和is，in函数" class="headerlink" title="序列中+和*的操作和is，in函数"></a>序列中+和*的操作和is，in函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># +的操作</span><br>i = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br>i = i + i <span class="hljs-comment"># (1,2,3,1,2,3)</span><br>a = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br><span class="hljs-built_in">id</span>(a) <span class="hljs-comment">#1440589908416</span><br>a += a <br><span class="hljs-built_in">id</span>(a) <span class="hljs-comment">#1440589908416</span><br><span class="hljs-comment">#发现两次的id是一模一样的，说明变量（对象）的id是固定的，不管对它进行什么样的加法运算！</span><br><br><span class="hljs-comment"># *的操作</span><br>i = i * <span class="hljs-number">2</span> <span class="hljs-comment"># (1,2,3,1,2,3)</span><br>a = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br><span class="hljs-built_in">id</span>(a) <span class="hljs-comment">#1440589908416</span><br>a *= a <br><span class="hljs-built_in">id</span>(a) <span class="hljs-comment">#1440512989913</span><br><span class="hljs-comment">#发现这两次的id并不相同。</span><br><br><span class="hljs-comment">#加法和乘法结果的id值并不相似，为此，python推出了is和is not 函数来判断两个对象是否是相同的</span><br>x = <span class="hljs-string">&quot;dgz&quot;</span><br>y = <span class="hljs-string">&quot;dgz&quot;</span><br>x <span class="hljs-keyword">is</span> y <span class="hljs-comment">#true,说明x和y是相同的对象</span><br>a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>b = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>a <span class="hljs-keyword">is</span> b <span class="hljs-comment">#false,说明a和b不是相同的对象</span><br><br><span class="hljs-comment">#in和not in函数，比如我们想知道字符串&quot;dgz&quot;里面是否含有&quot;d&quot;字符，我们可以使用：</span><br><span class="hljs-string">&quot;d&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;dgz&quot;</span> <span class="hljs-comment">#true</span><br><span class="hljs-string">&quot;d&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;dgz&quot;</span> <span class="hljs-comment">#false</span><br></code></pre></td></tr></table></figure><h3 id="删除对象"><a href="#删除对象" class="headerlink" title="删除对象"></a>删除对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#删除全部对象</span><br>x = <span class="hljs-number">12</span><br>y = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br><span class="hljs-keyword">del</span> x,y <span class="hljs-comment">#我们会发现对象x和y全部不见了！</span><br><span class="hljs-built_in">print</span>(x) <span class="hljs-comment">#error,此时会报错</span><br><br><span class="hljs-comment">#删除数组里面的部分对象</span><br>x = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-keyword">del</span> x[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>] <span class="hljs-comment">#x = [1,5]最后一个是能取到的，左闭右开</span><br><br><span class="hljs-comment">#删除数组所有内容，但是保留着数组的变量对象</span><br>x = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br><span class="hljs-keyword">del</span> x[:] 或 <span class="hljs-keyword">del</span> x[::] 或 <span class="hljs-keyword">del</span> x[::<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h3 id="函数：list-、tuple-、str"><a href="#函数：list-、tuple-、str" class="headerlink" title="函数：list()、tuple()、str()"></a>函数：list()、tuple()、str()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#list() 将可迭代对象或者元组，数组等等变成列表</span><br>x = <span class="hljs-string">&quot;denggaozheng&quot;</span><br>x.<span class="hljs-built_in">list</span>() <span class="hljs-comment">#[&#x27;d&#x27;,&#x27;g&#x27;,...,&#x27;g&#x27;]</span><br><br><span class="hljs-comment">#tuple() 将可迭代对象或者数组变成元组</span><br>x = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)<br>x.<span class="hljs-built_in">tuple</span>()<br><br><span class="hljs-comment">#str() 将可迭代对象等转换成字符串</span><br>x = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br>x.__<span class="hljs-built_in">str</span>()__ <span class="hljs-comment">#[1,2,3,4]字符串类型的</span><br></code></pre></td></tr></table></figure><h3 id="函数：max-和min"><a href="#函数：max-和min" class="headerlink" title="函数：max()和min()"></a>函数：max()和min()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#都知道min找最小值，max找最大值，那就举一些极端的例子</span><br><br><span class="hljs-comment">#如果传入的数组是空的，那么找最小最大的时候会报错的</span><br>s = []<br><span class="hljs-built_in">min</span>(s) <span class="hljs-comment">#error</span><br><br><span class="hljs-comment">#min max函数都可以传入默认值default</span><br>s = []<br><span class="hljs-built_in">min</span>(s,default = <span class="hljs-string">&quot;啥都没有！&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="函数：sum-、len"><a href="#函数：sum-、len" class="headerlink" title="函数：sum()、len()"></a>函数：sum()、len()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#sum() 用于求和,可以设定求和开始的位置，比如我从一百开始加s这个数组</span><br>s = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br><span class="hljs-built_in">sum</span>(s,start = <span class="hljs-number">100</span>) <span class="hljs-comment">#100+1+2+3+1+2=109</span><br><span class="hljs-comment">#如果start=100报错，那就直接sum(s,100)</span><br><br><span class="hljs-comment">#len() 方法返回对象（字符、列表、元组等）长度或项目个数</span><br><span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;runoob&quot;</span><br><span class="hljs-built_in">len</span>(<span class="hljs-built_in">str</span>) <span class="hljs-comment">#6</span><br> <br>l = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-built_in">len</span>(l) <span class="hljs-comment">#5</span><br></code></pre></td></tr></table></figure><h3 id="函数：sorted-和reversed"><a href="#函数：sorted-和reversed" class="headerlink" title="函数：sorted()和reversed()"></a>函数：sorted()和reversed()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#传什么参数给sorted()他都可以操作!</span><br><span class="hljs-comment">#sorted()返回的是一个全新的列表(对参数列表进行排序之后得到的新列表),而原列表不会发生改变。</span><br>s = [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>]<br><span class="hljs-built_in">sorted</span>(s) <span class="hljs-comment">#[1,2,3,4]</span><br><span class="hljs-built_in">print</span>(s) <span class="hljs-comment">#[1,4,2,5]</span><br><span class="hljs-comment">#sort会对原先的列表进行修改</span><br>s.sort() <span class="hljs-comment">#[1,2,4,5]</span><br><span class="hljs-comment">#sorted还可以进行翻转操作</span><br><span class="hljs-built_in">sorted</span>(s,reverse = true)<br><br><span class="hljs-comment">#reversed返回的是迭代器，参数里面可以放数组元组等等</span><br>a = <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>, <span class="hljs-number">9</span>)<br><span class="hljs-built_in">list</span>(<span class="hljs-built_in">reversed</span>(a)) <span class="hljs-comment">#[5,6,7,8,9]</span><br></code></pre></td></tr></table></figure><h3 id="函数：all-和any"><a href="#函数：all-和any" class="headerlink" title="函数：all()和any()"></a>函数：all()和any()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#all函数判断可迭代对象中是否所有元素的值都为真，其中0是假</span><br>a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>]<br><span class="hljs-built_in">all</span>(a) <span class="hljs-comment">#false</span><br><span class="hljs-comment">#any函数判断可迭代对象中是否存在为真的值，其中0是假</span><br>a = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br><span class="hljs-built_in">any</span>(a) <span class="hljs-comment">#true</span><br></code></pre></td></tr></table></figure><h3 id="函数：enumerate"><a href="#函数：enumerate" class="headerlink" title="函数：enumerate()"></a>函数：enumerate()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#enumerate函数用于将一个可遍历的数据对象(列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，加入start表示下标开始的位置。一般用在 for 循环当中，通常与list函数搭配使用。</span><br>seasons = [<span class="hljs-string">&#x27;Spring&#x27;</span>, <span class="hljs-string">&#x27;Summer&#x27;</span>, <span class="hljs-string">&#x27;Fall&#x27;</span>, <span class="hljs-string">&#x27;Winter&#x27;</span>]<br><span class="hljs-built_in">list</span>(<span class="hljs-built_in">enumerate</span>(seasons, start=<span class="hljs-number">1</span>)) <span class="hljs-comment">#[(1, &#x27;Spring&#x27;), (2, &#x27;Summer&#x27;), (3, &#x27;Fall&#x27;), (4, &#x27;Winter&#x27;)]</span><br></code></pre></td></tr></table></figure><h3 id="函数：zip-常用！！"><a href="#函数：zip-常用！！" class="headerlink" title="函数：zip()常用！！"></a>函数：zip()常用！！</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#zip函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组</span><br>a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>b = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>c = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]<br>zipped = <span class="hljs-built_in">zip</span>(a,b)     <span class="hljs-comment"># 打包为元组的列表 [(1, 4), (2, 5), (3, 6)]</span><br><span class="hljs-built_in">zip</span>(a,c)              <span class="hljs-comment"># 元素个数与最短的列表一致 [(1, 4), (2, 5), (3, 6)]</span><br><span class="hljs-built_in">zip</span>(*zipped)          <span class="hljs-comment"># 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式 [(1, 2, 3), (4, 5, 6)]</span><br><span class="hljs-comment">#拓展：如果长的数组和短的数组进行zip，而我们不想按最短的来匹配，可以导入itertools</span><br><span class="hljs-keyword">import</span> itertools<br>a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br>b = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>it = itertools.zip_longest(a,b)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(it)) <span class="hljs-comment">#[(1, 1), (2, 2), (3, 3), (4, 4), (5, None), (6, None), (7, None)]</span><br></code></pre></td></tr></table></figure><h3 id="函数：map-常用！-和filter函数、iter函数"><a href="#函数：map-常用！-和filter函数、iter函数" class="headerlink" title="函数：map()常用！!和filter函数、iter函数"></a>函数：map()常用！!和filter函数、iter函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#map函数会根据提供的函数对指定序列做映射。第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次function 函数返回值的新列表。默认返回的是迭代器：&lt;map object at 0x000001289EC93490&gt;，但是使用list函数可以让他变成数组。</span><br><span class="hljs-comment">#先定义一个函数fun</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">x</span>):<br>    x = x + <span class="hljs-number">1</span><br>s = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(fun,s)) <span class="hljs-comment">#[2,3,4,5,6]</span><br><br><span class="hljs-comment">#map函数传递的是包含计算结果的数，而filter函数传递的是计算结果为真的数（就没有0了）。</span><br><span class="hljs-comment">#例如我现在想要找到下面字符串中的大写字符</span><br>strn = <span class="hljs-string">&quot;DengGaoZheng&quot;</span><br><span class="hljs-built_in">filter</span>(<span class="hljs-built_in">str</span>.isupper,strn) <span class="hljs-comment">#[&#x27;D&#x27;,&quot;G&quot;,&#x27;Z&#x27;]</span><br><br><span class="hljs-comment">#iter函数：把一个可迭代对象变成迭代器</span><br>x = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>y = <span class="hljs-built_in">iter</span>(x) <span class="hljs-comment">#这时候y就是一个迭代器啦！</span><br><span class="hljs-comment">#使用next函数可以将迭代器y中的元素逐一取出来！</span><br><span class="hljs-built_in">next</span>(y) <span class="hljs-comment">#1</span><br><span class="hljs-built_in">next</span>(y) <span class="hljs-comment">#2</span><br><span class="hljs-built_in">next</span>(y) <span class="hljs-comment">#3</span><br><span class="hljs-built_in">next</span>(y) <span class="hljs-comment">#当我们拿完了迭代器里面的元素，再使用next的时候就会报异常！我们还可以自定义报异常的值，在next的第二个参数</span><br><span class="hljs-built_in">next</span>(y,<span class="hljs-string">&quot;已经没了!&quot;</span>) <span class="hljs-comment">#已经没了！</span><br></code></pre></td></tr></table></figure><h3 id="迭代器，迭代对象"><a href="#迭代器，迭代对象" class="headerlink" title="迭代器，迭代对象"></a>迭代器，迭代对象</h3><p>首先要知道一个迭代器一定是一个迭代对象！</p><p>区别是：迭代对象是可以反复使用的，而迭代器是一次性的。</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python--字符串</title>
    <link href="/2022/02/13/python-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/02/13/python-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="涵盖了python中大部分的字符串操作"><a href="#涵盖了python中大部分的字符串操作" class="headerlink" title="涵盖了python中大部分的字符串操作"></a>涵盖了python中大部分的字符串操作</h2><span id="more"></span><h3 id="大小写字母转换："><a href="#大小写字母转换：" class="headerlink" title="大小写字母转换："></a>大小写字母转换：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#capitalize 将首字母变成大写，其他不变</span><br>x = <span class="hljs-string">&quot;abcde&quot;</span><br>x.capitalize() <span class="hljs-comment">#Abcde</span><br><br><span class="hljs-comment">#casefold 返回一个全部是小写的新字符串</span><br>x = <span class="hljs-string">&quot;AbCdE&quot;</span><br>x.casefold() <span class="hljs-comment">#abcde</span><br><br><span class="hljs-comment">#title 将字符串首字母变成大写，其他的全变成小写</span><br>x = <span class="hljs-string">&quot;aBCDe&quot;</span><br>x.title() <span class="hljs-comment">#Abcde</span><br><br><span class="hljs-comment">#swapcase 将字符串中大小写字母翻转，大写变小写，小写变大写</span><br>x = <span class="hljs-string">&quot;AbCdE&quot;</span><br>x.swapcase() <span class="hljs-comment">#aBcDe</span><br><br><span class="hljs-comment">#upper 将所有字母变大写</span><br>x = <span class="hljs-string">&quot;abcde&quot;</span><br>x.upper() <span class="hljs-comment">#ABCDE</span><br><br><span class="hljs-comment">#lower 将所有字母变小写</span><br>x = <span class="hljs-string">&quot;ABCDE&quot;</span><br>x.lower() <span class="hljs-comment">#abcde</span><br><span class="hljs-comment">#关于casefold和lower：casefold比lower更加强大。casefold可以处理包括英文字符在内的诸多字符类型，但是lower只能处理英文字符。</span><br></code></pre></td></tr></table></figure><h3 id="左中右对齐"><a href="#左中右对齐" class="headerlink" title="左中右对齐"></a>左中右对齐</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#使用对齐有一个条件：在center等的括号内的数字要大于字符串的长度才能实现此功能！</span><br>x = <span class="hljs-string">&quot;你真厉害！&quot;</span> <span class="hljs-comment">#这里一共有五个字符长度，在center括号内的数字需要大于五个字符</span><br>x.center(<span class="hljs-number">7</span>) <span class="hljs-comment">#&quot; 你真厉害！ &quot;</span><br>x.ljust(<span class="hljs-number">7</span>)  <span class="hljs-comment">#&quot;你真厉害！  &quot;</span><br>x.rjust(<span class="hljs-number">7</span>)  <span class="hljs-comment">#&quot;  你真厉害！&quot;</span><br>x.zfill(<span class="hljs-number">9</span>)  <span class="hljs-comment">#&quot;0000你真厉害d！&quot;右对齐，并且用0填充左侧</span><br><span class="hljs-comment">#在后面可以自定义空格中填充的字符串</span><br>x.center(<span class="hljs-number">11</span>,<span class="hljs-string">&quot;噢&quot;</span>) <span class="hljs-comment">#&quot;噢噢噢你真厉害！噢噢噢&quot;</span><br></code></pre></td></tr></table></figure><h3 id="寻找字符串"><a href="#寻找字符串" class="headerlink" title="寻找字符串"></a>寻找字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#count统计字符在字符串中出现的次数</span><br>x = <span class="hljs-string">&quot;上海的自来水来自海上&quot;</span><br>x.count(<span class="hljs-string">&quot;自&quot;</span>) <span class="hljs-comment">#出现了两次，所以是2</span><br><br><span class="hljs-comment">#find查找字符在字符串中第一次出现的位置，rfind则是相反方向的查找（从右往左查找）</span><br>x = <span class="hljs-string">&quot;上海的自来水来自海上&quot;</span><br>x.find(<span class="hljs-string">&quot;海&quot;</span>)  <span class="hljs-comment">#1</span><br>x.rfind(<span class="hljs-string">&quot;海&quot;</span>) <span class="hljs-comment">#8</span><br>x.find(<span class="hljs-string">&quot;去&quot;</span>)  <span class="hljs-comment">#如果在字符串中找不到字符则返回-1</span><br><br><span class="hljs-comment">#index和find类似，但是如果找不到会抛出异常</span><br>x.index(<span class="hljs-string">&quot;去&quot;</span>) <span class="hljs-comment">#error:...</span><br></code></pre></td></tr></table></figure><h3 id="字符串替换和表格转换"><a href="#字符串替换和表格转换" class="headerlink" title="字符串替换和表格转换"></a>字符串替换和表格转换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#replace方法用于将前后的字符串进行对调</span><br>x = <span class="hljs-string">&quot;上海自来水来自海上&quot;</span><br>x.replace(<span class="hljs-string">&quot;上海&quot;</span>,<span class="hljs-string">&quot;北京&quot;</span>) <span class="hljs-comment">#北京自来水来自海上</span><br><br><span class="hljs-comment">#创建表格maketrans,注意：在maketrans中字符串的长度一定要匹配，否则会报如下错误：ValueError: the first two maketrans arguments must have equal length</span><br>table = <span class="hljs-built_in">str</span>.maketrans(<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;def&quot;</span>)<br><span class="hljs-string">&quot;ghi&quot;</span>.translate(table)<br></code></pre></td></tr></table></figure><h3 id="字符串的判断（全部返回bool类型）"><a href="#字符串的判断（全部返回bool类型）" class="headerlink" title="字符串的判断（全部返回bool类型）"></a>字符串的判断（全部返回bool类型）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#startwith判断字符是否出现在字符串的开始位置</span><br>x = <span class="hljs-string">&quot;我爱python&quot;</span><br>x.startwith(<span class="hljs-string">&quot;我&quot;</span>) <span class="hljs-comment">#true</span><br><br><span class="hljs-comment">#同理endswith判断字符是否出现在字符串的结束位置</span><br>x = <span class="hljs-string">&quot;我爱python&quot;</span><br>x.endswith(<span class="hljs-string">&quot;o&quot;</span>) <span class="hljs-comment">#false</span><br><br><span class="hljs-comment">#startswith和endswith的进阶，可以自定义起始和结束位置</span><br>startswith(<span class="hljs-string">&quot;我&quot;</span>,<span class="hljs-number">1</span>) <span class="hljs-comment">#表示从“1”的位置开始，此时字符串变成了“爱python”</span><br>endswith(<span class="hljs-string">&quot;on&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>) <span class="hljs-comment">#表示从“0”的地方开始，在“4”的位置结束，此时字符串变成了“我爱pyt”</span><br><br><span class="hljs-comment">#istitle判断字符串中是否都是以大写字母开头，其余的都是小写</span><br>x = <span class="hljs-string">&quot;Abc&quot;</span><br>x.istitle() <span class="hljs-comment">#true</span><br><br><span class="hljs-comment">#isupper判断字符串里面是否都是大写字母</span><br><span class="hljs-comment">#islower判断字符串里面是否都是小写字母</span><br>x = <span class="hljs-string">&quot;ABC&quot;</span><br>x.isupper() <span class="hljs-comment">#true</span><br>x.islower() <span class="hljs-comment">#false</span><br><br><span class="hljs-comment">#isalpha判断字符串是否全部由字母构成（存在空格也不算！）</span><br>x=<span class="hljs-string">&quot;ABCDE &quot;</span><br>x.isalpha() <span class="hljs-comment">#false,因为我有空格的存在</span><br><br><span class="hljs-comment">#isspace判断是否全部由空白字符构成，转义字符，tab，space全部都算是空白字符</span><br><span class="hljs-string">&quot;\n \t &quot;</span>.space() <span class="hljs-comment">#true</span><br><br><span class="hljs-comment">#isprintable判断字符串所有元素是否都是可打印字符，注意细节：转义字符不是可打印字符！！</span><br><span class="hljs-string">&quot;我爱python \n&quot;</span>.isprintable() <span class="hljs-comment">#false</span><br><br><span class="hljs-comment">#isdecimal(),isdigit(),isnumeric()都是判断字符串中是否都是数字的方法。但是我们通常使用isalnum()方法，它是一个集大成者，只要上面三个方法中任意一个返回true，那么isalnum就返回true</span><br>x = <span class="hljs-string">&quot;123456&quot;</span><br>x.isalum() <span class="hljs-comment">#true</span><br><br><span class="hljs-comment">#isidentifier判断是否是python承认的变量命名</span><br><span class="hljs-string">&quot;I love python&quot;</span>.isidentifier() <span class="hljs-comment">#false</span><br><span class="hljs-string">&quot;I_love_python&quot;</span>.isidentifier() <span class="hljs-comment">#true</span><br></code></pre></td></tr></table></figure><h3 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#lstrip去除左侧的空白</span><br><span class="hljs-comment">#rstrip去除右侧的空白</span><br><span class="hljs-comment">#strip左右的空白都不要</span><br><span class="hljs-string">&quot;左侧不要留白&quot;</span>.lstrip() <span class="hljs-comment">#&quot;左侧不要留白&quot;</span><br><span class="hljs-string">&quot;右侧不要留白&quot;</span>.rstrip() <span class="hljs-comment">#&quot;右侧不要留白&quot;</span><br><span class="hljs-comment">#也可以自定义去除，但是其实是从左或者从右去除到与传入字符没有相同才停止，即匹配来去除，而不是只是删除对应的字符！</span><br><span class="hljs-string">&quot;www.dopagip00.com&quot;</span>.lstrip(abcd) <span class="hljs-comment">#&quot;dopagip00.com&quot;</span><br><span class="hljs-string">&quot;www.dopagip00.com&quot;</span>.rstrip(abcd) <span class="hljs-comment">#&quot;www.dopagip00&quot;</span><br><span class="hljs-string">&quot;www.dopagip00.com&quot;</span>.strip(abcd) <span class="hljs-comment">#&quot;dopagip00&quot;</span><br><span class="hljs-comment">#对应上面的代码实际上去除的不是abcd（根本不存在abcd）去除的是abcd对应的左右分别四个字符。</span><br><br><span class="hljs-comment">#使用removeprefix(prefix)--&gt;前缀和removesuffix(suffix)--&gt;后缀去除一个特定的子字符串</span><br><span class="hljs-string">&quot;www.dopagip00.com&quot;</span>.removeprefix(www.) <span class="hljs-comment">#&quot;dopagip00.com&quot;</span><br><span class="hljs-string">&quot;www.dopagip00.com&quot;</span>.removesuffix(.com) <span class="hljs-comment">#&quot;www.dopagip00&quot;</span><br><br><span class="hljs-comment">#只切分一次：切割字符串,partition表示以.进行切割从右往左寻找分隔符,只找一个！！找到一个就不找了！rpartition表示从右往左寻找分隔符，同样只寻找一个。</span><br><span class="hljs-string">&quot;www.dopagip00.com&quot;</span>.partition(<span class="hljs-string">&quot;.&quot;</span>) <span class="hljs-comment">#(&#x27;www&#x27;,&#x27;.&#x27;,&#x27;dopagip00.com&#x27;)</span><br><span class="hljs-string">&quot;www.dopagip00.com&quot;</span>.rpartition(<span class="hljs-string">&quot;.&quot;</span>) <span class="hljs-comment">#(&#x27;www.dopagip00&#x27;,&#x27;.&#x27;,&#x27;com&#x27;)</span><br><br><span class="hljs-comment">#切分到没有为止：split按照给定的字符进行切分，默认切分空格。在指定字符的后面一个参数还可以指定分割的次数。</span><br><span class="hljs-string">&quot;www dopagip com&quot;</span>.split() <span class="hljs-comment">#(&#x27;www&#x27;,&#x27;dopagip&#x27;,&#x27;com&#x27;)</span><br><span class="hljs-string">&quot;www.dopagip.com&quot;</span>.split(<span class="hljs-string">&quot;.&quot;</span>) <span class="hljs-comment">#(&#x27;www&#x27;,&#x27;dopagip&#x27;,&#x27;com&#x27;)</span><br><span class="hljs-string">&quot;www.dopagip.com&quot;</span>.rsplit(<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-number">1</span>) <span class="hljs-comment">#我这里指定切割一次，而且是从右往左切，结果： (&quot;www.dopagip&quot;,&quot;com&quot;)</span><br><br><span class="hljs-comment">#splitlines是以&#x27;行&#x27;进行分割。</span><br><span class="hljs-string">&quot;www\ndopagip00\ncom&quot;</span>.splitlines() <span class="hljs-comment">#(&#x27;www&#x27;,&#x27;dopagip00&#x27;,&#x27;com&#x27;)</span><br><br> <span class="hljs-comment">#join是把列表的数组组合起来成字符串。</span><br><span class="hljs-string">&quot;.&quot;</span>.join([<span class="hljs-string">&#x27;www&#x27;</span>,<span class="hljs-string">&#x27;dopagip00&#x27;</span>,<span class="hljs-string">&#x27;com&#x27;</span>]) <span class="hljs-comment">#www.dopagip00.com</span><br></code></pre></td></tr></table></figure><h3 id="格式化字符串（占位）"><a href="#格式化字符串（占位）" class="headerlink" title="格式化字符串（占位）"></a>格式化字符串（占位）</h3><p>其实和c语言的%d,%s占位符类似，只不过python是用{}来占位 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#format方法format里面的参数就是占位的字符，format里面的参数与&#123;&#125;对应，有几个参数就有几个&#123;&#125;</span><br>a = <span class="hljs-string">&quot;python&quot;</span><br>b = <span class="hljs-string">&quot;C&quot;</span><br>c = <span class="hljs-string">&quot;PHP&quot;</span><br>d = <span class="hljs-string">&quot;JAVA&quot;</span><br><span class="hljs-string">&quot;我爱 &#123;&#125; &quot;</span>.<span class="hljs-built_in">format</span>(a) <span class="hljs-comment">#我爱python</span><br><span class="hljs-string">&quot;我爱&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(a,b,c,d) <span class="hljs-comment">#我爱python,C,PHP,JAVA</span><br><span class="hljs-comment">#可以在花括号中间加入数字表示占位的顺序,甚至可以在括号内加变量名，然后在format里面给变量赋值</span><br>a = <span class="hljs-string">&quot;python&quot;</span><br>b = <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我爱&#123;1&#125;,&#123;0&#125;&quot;</span>.<span class="hljs-built_in">format</span>(a, b)) <span class="hljs-comment">#我爱python，C</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我爱&#123;0&#125;,&#123;1&#125;&quot;</span>.<span class="hljs-built_in">format</span>(a, b)) <span class="hljs-comment">#我爱C，python</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我爱&#123;py&#125;,&#123;ja&#125;&quot;</span>.<span class="hljs-built_in">format</span>(py=<span class="hljs-string">&quot;python&quot;</span>,ja=<span class="hljs-string">&quot;java&quot;</span>)) <span class="hljs-comment">#我爱python,java</span><br><br><span class="hljs-comment">#千分符</span><br><span class="hljs-string">&quot;&#123;:,&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-number">1234</span>) <span class="hljs-comment">#1,234</span><br><br><span class="hljs-comment">#保留小数点后x位即.xf，类别c语言%.xf</span><br><span class="hljs-string">&quot;&#123;.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-number">3.14159</span>) <span class="hljs-comment">#3.14</span><br><br><span class="hljs-comment">#保留x位数,即.xg</span><br><span class="hljs-string">&quot;&#123;.2g&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-number">3.14159</span>) <span class="hljs-comment">#3.1</span><br><br><span class="hljs-comment">#截取x位字符，不能用于数字，会报错！！</span><br><span class="hljs-string">&quot;&#123;:.2&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;我爱py&quot;</span>)  <span class="hljs-comment">#我爱</span><br><span class="hljs-string">&quot;&#123;:.2&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-number">1234</span>)     <span class="hljs-comment">#error</span><br></code></pre></td></tr></table></figure><p>：后面可以加很多值，如下表：（参数即format里面的参数）</p><p><img src="/2022/02/13/python-%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20220213212943323.png" alt="image-20220213212943323"></p><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令手册</title>
    <link href="/2022/02/12/Linux%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/"/>
    <url>/2022/02/12/Linux%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="常用的Linux命令大全"><a href="#常用的Linux命令大全" class="headerlink" title="常用的Linux命令大全"></a>常用的Linux命令大全</h2><span id="more"></span><h1 id="关机-重启-注销"><a href="#关机-重启-注销" class="headerlink" title="关机/重启/注销"></a>关机/重启/注销</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>shutdown -h now</td><td>即刻关机</td></tr><tr><td>shutdown -h 10</td><td>10分钟后关机</td></tr><tr><td>shutdown -h 11:00</td><td>11：00关机</td></tr><tr><td>shutdown -h +10</td><td>预定时间关机（10分钟后）</td></tr><tr><td>shutdown -c</td><td>取消指定时间关机</td></tr><tr><td>shutdown -r now</td><td>重启</td></tr><tr><td>shutdown -r 10</td><td>10分钟之后重启</td></tr><tr><td>shutdown -r 11:00</td><td>定时重启</td></tr><tr><td>reboot</td><td>重启</td></tr><tr><td>init 6</td><td>重启</td></tr><tr><td>init 0</td><td>⽴刻关机</td></tr><tr><td>telinit 0</td><td>关机</td></tr><tr><td>poweroff</td><td>⽴刻关机</td></tr><tr><td>halt</td><td>关机</td></tr><tr><td>sync</td><td>buff数据同步到磁盘</td></tr><tr><td>logout</td><td>退出登录Shell</td></tr></tbody></table><h1 id="系统信息和性能查看"><a href="#系统信息和性能查看" class="headerlink" title="系统信息和性能查看"></a>系统信息和性能查看</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>uname -a</td><td>查看内核/OS/CPU信息</td></tr><tr><td>uname -r</td><td>查看内核版本</td></tr><tr><td>uname -m</td><td>查看处理器架构</td></tr><tr><td>arch</td><td>查看处理器架构</td></tr><tr><td>hostname</td><td>查看计算机名</td></tr><tr><td>who</td><td>显示当前登录系统的⽤户</td></tr><tr><td>who am i</td><td>显示登录时的⽤户名</td></tr><tr><td>whoami</td><td>显示当前⽤户名</td></tr><tr><td>cat /proc/version</td><td>查看linux版本信息</td></tr><tr><td>cat /proc/cpuinfo</td><td>查看CPU信息</td></tr><tr><td>cat /proc/interrupts</td><td>查看中断</td></tr><tr><td>cat /proc/loadavg</td><td>查看系统负载</td></tr><tr><td>uptime</td><td>查看系统运⾏时间、⽤户数、负载</td></tr><tr><td>env</td><td>查看系统的环境变量</td></tr><tr><td>lsusb -tv</td><td>查看系统USB设备信息</td></tr><tr><td>lspci -tv</td><td>查看系统PCI设备信息</td></tr><tr><td>lsmod</td><td>查看已加载的系统模块</td></tr><tr><td>grep MemTotal /proc/meminfo</td><td>查看内存总量</td></tr><tr><td>grep MemFree /proc/meminfo</td><td>查看空闲内存量</td></tr><tr><td>free -m</td><td>查看内存⽤量和交换区⽤量</td></tr><tr><td>date</td><td>显示系统⽇期时间</td></tr><tr><td>cal 2021</td><td>显示2021⽇历表</td></tr><tr><td>top</td><td>动态显示cpu/内存/进程等情况</td></tr><tr><td>vmstat 1 20</td><td>每1秒采⼀次系统状态，采20次</td></tr><tr><td>iostat</td><td>查看io读写/cpu使⽤情况</td></tr><tr><td>查看io读写/cpu使⽤情况</td><td>查询cpu使⽤情况（1秒⼀次，共10次）</td></tr><tr><td>sar -d 1 10</td><td>查询磁盘性能</td></tr></tbody></table><h1 id="磁盘和分区"><a href="#磁盘和分区" class="headerlink" title="磁盘和分区"></a>磁盘和分区</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>fdisk -l</td><td>查看所有磁盘分区</td></tr><tr><td>swapon -s</td><td>查看所有交换分区</td></tr><tr><td>df -h</td><td>查看磁盘使⽤情况及挂载点</td></tr><tr><td>df -hl</td><td>同上</td></tr><tr><td>du -sh /dir</td><td>查看指定某个⽬录的⼤⼩</td></tr><tr><td>du -sk * | sort -rn</td><td>从⾼到低依次显示⽂件和⽬录⼤⼩</td></tr><tr><td>mount /dev/hda2 /mnt/hda2</td><td>挂载hda2盘</td></tr><tr><td>mount -t ntfs /dev/sdc1 /mnt/usbhd1</td><td>指定⽂件系统类型挂载（如ntfs）</td></tr><tr><td>mount -o loop xxx.iso /mnt/cdrom</td><td>挂 载 iso ⽂ 件</td></tr><tr><td>umount -v /dev/sda1</td><td>通过设备名卸载</td></tr><tr><td>umount -v /mnt/mymnt</td><td>通过挂载点卸载</td></tr><tr><td>fuser -km /mnt/hda1</td><td>强制卸载(慎⽤)</td></tr></tbody></table><h1 id="⽤户和⽤户组"><a href="#⽤户和⽤户组" class="headerlink" title="⽤户和⽤户组"></a>⽤户和⽤户组</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>useradd codesheep</td><td>创建⽤户</td></tr><tr><td>userdel -r codesheep</td><td>删除⽤户</td></tr><tr><td>usermod -g group_name user_name</td><td>修改⽤户的组</td></tr><tr><td>usermod -aG group_name user_name</td><td>将⽤户添加到组</td></tr><tr><td>usermod -s /bin/ksh -d /home/codepig –g dev codesheep</td><td>修改⽤户codesheep的登录Shell、主⽬录以及⽤户组</td></tr><tr><td>groups test</td><td>查看test⽤户所在的组</td></tr><tr><td>groupadd group_name</td><td>创建⽤户组</td></tr><tr><td>groupdel group_name</td><td>删除⽤户组</td></tr><tr><td>groupmod -n new_name old_name</td><td>重命名⽤户组</td></tr><tr><td>su - user_name</td><td>su - user_name</td></tr><tr><td>passwd</td><td>修改⼝令</td></tr><tr><td>passwd codesheep</td><td>修改某⽤户的⼝令</td></tr><tr><td>w</td><td>查看活动⽤户</td></tr><tr><td>id codesheep</td><td>查看指定⽤户codesheep信息</td></tr><tr><td>last</td><td>查看⽤户登录⽇志</td></tr><tr><td>crontab -l</td><td>查看当前⽤户的计划任务</td></tr><tr><td>cut -d: -f1 /etc/passwd</td><td>查看系统所有⽤户</td></tr><tr><td>cut -d: -f1 /etc/group</td><td>查看系统所有组</td></tr></tbody></table><h1 id="⽹络和进程管理"><a href="#⽹络和进程管理" class="headerlink" title="⽹络和进程管理"></a>⽹络和进程管理</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>ifconfig</td><td>查看⽹络接⼝属性</td></tr><tr><td>ifconfig eth0</td><td>查看某⽹卡的配置</td></tr><tr><td>route -n</td><td>查看路由表</td></tr><tr><td>netstat -lntp</td><td>查看所有监听端⼝</td></tr><tr><td>netstat -antp</td><td>查看已经建⽴的TCP连接</td></tr><tr><td>netstat -lutp</td><td>查看TCP/UDP的状态信息</td></tr><tr><td>ifup eth0</td><td>启⽤eth0⽹络设备</td></tr><tr><td>ifdown eth0</td><td>禁⽤eth0⽹络设备</td></tr><tr><td>iptables -L</td><td>查看iptables规则</td></tr><tr><td>ifconfig eth0 192.168.1.1 netmask 255.255.255.0</td><td>配置ip地址</td></tr><tr><td>dhclient eth0</td><td>以dhcp模式启⽤eth0</td></tr><tr><td>route add -net 0/0 gw Gateway_IP</td><td>配置默认⽹关</td></tr><tr><td>route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1</td><td>配置静态路由到达⽹络’192.168.0.0/16’</td></tr><tr><td>route del 0/0 gw Gateway_IP</td><td>删除静态路由</td></tr><tr><td>hostname</td><td>查看主机名</td></tr><tr><td>host <a href="http://www.baidu.com/">www.baidu.com</a></td><td>解析主机名</td></tr><tr><td>nslookup <a href="http://www.baidu.com/">www.baidu.com</a></td><td>查询DNS记录，查看域名解析是否正常</td></tr><tr><td>ps -ef</td><td>查看所有进程</td></tr><tr><td>ps -ef | grep codesheep</td><td>过滤出你需要的进程</td></tr><tr><td>kill -s name</td><td>kill指定名称的进程</td></tr><tr><td>kill -s pid</td><td>kill指定pid的进程</td></tr><tr><td>top</td><td>实时显示进程状态</td></tr><tr><td>vmstat 1 20</td><td>每1秒采⼀次系统状态，采20次</td></tr><tr><td>iostat</td><td>iostat</td></tr><tr><td>sar -u 1 10</td><td>查询cpu使⽤情况（1秒⼀次，共10次）</td></tr><tr><td>sar -d 1 10</td><td>查询磁盘性能</td></tr></tbody></table><h1 id="常⻅系统服务命令"><a href="#常⻅系统服务命令" class="headerlink" title="常⻅系统服务命令"></a>常⻅系统服务命令</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>chkconfig –list</td><td>列出系统服务</td></tr><tr><td>service &lt;服务名&gt; status</td><td>查看某个服务</td></tr><tr><td>service &lt;服务名&gt; start</td><td>启动某个服务</td></tr><tr><td>service &lt;服务名&gt; stop</td><td>终⽌某个服务</td></tr><tr><td>service &lt;服务名&gt; restart</td><td>重启某个服务</td></tr><tr><td>systemctl status &lt;服务名&gt;</td><td>查看某个服务</td></tr><tr><td>systemctl start &lt;服务名&gt;</td><td>启动某个服务</td></tr><tr><td>systemctl stop &lt;服务名&gt;</td><td>终⽌某个服务</td></tr><tr><td>systemctl restart &lt;服务名&gt;</td><td>重启某个服务</td></tr><tr><td>systemctl enable &lt;服务名&gt;</td><td>关闭⾃启动</td></tr><tr><td>systemctl disable &lt;服务名&gt;</td><td>关闭⾃启动</td></tr></tbody></table><h1 id="⽂件和⽬录操作"><a href="#⽂件和⽬录操作" class="headerlink" title="⽂件和⽬录操作"></a>⽂件和⽬录操作</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>cd &lt;⽬录名&gt;</td><td>进⼊某个⽬录</td></tr><tr><td>cd ..</td><td>回上级⽬录</td></tr><tr><td>cd ../..</td><td>回上两级⽬录</td></tr><tr><td>cd</td><td>进个⼈主⽬录</td></tr><tr><td>cd -</td><td>回上⼀步所在⽬录</td></tr><tr><td>pwd</td><td>显示当前路径</td></tr><tr><td>ls</td><td>查看⽂件⽬录列表</td></tr><tr><td>ls -F</td><td>查看⽬录中内容（显示是⽂件还是⽬录）</td></tr><tr><td>ls -l</td><td>查看⽂件和⽬录的详情列表</td></tr><tr><td>ls -a</td><td>查看隐藏⽂件</td></tr><tr><td>ls -lh</td><td>查看⽂件和⽬录的详情列表（增强⽂件⼤⼩易读性）</td></tr><tr><td>ls -lSr</td><td>查看⽂件和⽬录列表（以⽂件⼤⼩升序查看）</td></tr><tr><td>tree</td><td>查看⽂件和⽬录的树形结构</td></tr><tr><td>mkdir &lt;⽬录名&gt;</td><td>创建⽬录</td></tr><tr><td>mkdir dir1 dir2</td><td>同时创建两个⽬录</td></tr><tr><td>mkdir -p /tmp/dir1/dir2</td><td>创建⽬录树</td></tr><tr><td>rm -f file1</td><td>删除’file1’⽂件</td></tr><tr><td>rmdir dir1</td><td>删除’dir1’⽬录</td></tr><tr><td>rm -rf dir1</td><td>删除’dir1’⽬录和其内容</td></tr><tr><td>rm -rf dir1 dir2</td><td>同时删除两个⽬录及其内容</td></tr><tr><td>mv old_dir new_dir</td><td>重命名/移动⽬录</td></tr><tr><td>cp file1 file2</td><td>复制⽂件</td></tr><tr><td>cp dir/* .</td><td>复制某⽬录下的所有⽂件⾄当前⽬录</td></tr><tr><td>cp -a dir1 dir2</td><td>复制⽬录</td></tr><tr><td>cp -a /tmp/dir1 .</td><td>复制⼀个⽬录⾄当前⽬录</td></tr><tr><td>ln -s file1 link1</td><td>创建指向⽂件/⽬录的软链接</td></tr><tr><td>ln file1 lnk1</td><td>创建指向⽂件/⽬录的物理链接</td></tr><tr><td>find / -name file1</td><td>从跟⽬录开始搜索⽂件/⽬录</td></tr><tr><td>find / -user user1</td><td>搜索⽤户user1的⽂件/⽬录</td></tr><tr><td>find /dir -name *.bin</td><td>在⽬录/dir中搜带有.bin后缀的⽂件</td></tr><tr><td>locate &lt;关键词&gt;</td><td>快速定位⽂件</td></tr><tr><td>locate *.mp4</td><td>寻找.mp4结尾的⽂件</td></tr><tr><td>whereis &lt;关键词&gt;</td><td>显示某⼆进制⽂件/可执⾏⽂件的路径</td></tr><tr><td>which &lt;关键词&gt;</td><td>查找系统⽬录下某的⼆进制⽂件</td></tr><tr><td>chmod ugo+rwx dir1</td><td>设置⽬录所有者(u)、群组(g)及其他⼈(o)的读（r）写(w)执⾏(x)权限</td></tr><tr><td>chmod go-rwx dir1</td><td>移除群组(g)与其他⼈(o)对⽬录的读写执⾏权限</td></tr><tr><td>chown user1 file1</td><td>改变⽂件的所有者属性</td></tr><tr><td>chown -R user1 dir1</td><td>改变⽬录的所有者属性</td></tr><tr><td>chgrp group1 file1</td><td>改变⽂件群组</td></tr><tr><td>chown user1:group1 file1</td><td>改变⽂件的所有⼈和群组</td></tr></tbody></table><h1 id="⽂件查看和处理"><a href="#⽂件查看和处理" class="headerlink" title="⽂件查看和处理"></a>⽂件查看和处理</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>cat file1</td><td>查看⽂件内容</td></tr><tr><td>cat -n file1</td><td>查看内容并标示⾏数</td></tr><tr><td>tac file1</td><td>从最后⼀⾏开始反看⽂件内容</td></tr><tr><td>more file1</td><td>more file1</td></tr><tr><td>less file1</td><td>类似more命令，但允许反向操作</td></tr><tr><td>head -2 file1</td><td>查看⽂件前两⾏</td></tr><tr><td>tail -2 file1</td><td>查看⽂件后两⾏</td></tr><tr><td>tail -f /log/msg</td><td>实时查看添加到⽂件中的内容</td></tr><tr><td>grep codesheep hello.txt</td><td>在⽂件hello.txt中查找关键词codesheep</td></tr><tr><td>grep ^sheep hello.txt</td><td>在⽂件hello.txt中查找以sheep开头的内容</td></tr><tr><td>grep [0-9] hello.txt</td><td>选择hello.txt⽂件中所有包含数字的⾏</td></tr><tr><td>sed ‘s/s1/s2/g’ hello.txt</td><td>将hello.txt⽂件中的s1替换成s2</td></tr><tr><td>sed ‘/^$/d’ hello.txt</td><td>从hello.txt⽂件中删除所有空⽩⾏</td></tr><tr><td>sed ‘/ *#/d; /^$/d’ hello.txt</td><td>从hello.txt⽂件中删除所有注释和空⽩⾏</td></tr><tr><td>sed -e ‘1d’ hello.txt</td><td>从⽂件hello.txt 中排除第⼀⾏</td></tr><tr><td>sed -n ‘/s1/p’ hello.txt</td><td>查看只包含关键词”s1”的⾏</td></tr><tr><td>sed -e ‘s/ *$//‘ hello.txt</td><td>删除每⼀⾏最后的空⽩字符</td></tr><tr><td>sed -e ‘s/s1//g’ hello.txt</td><td>从⽂档中只删除词汇s1并保留剩余全部</td></tr><tr><td>sed -n ‘1,5p;5q’ hello.txt</td><td>查看从第⼀⾏到第5⾏内容</td></tr><tr><td>sed -n ‘5p;5q’ hello.txt</td><td>查看第5⾏</td></tr><tr><td>paste file1 file2</td><td>合并两个⽂件或两栏的内容</td></tr><tr><td>paste -d ‘+’ file1 file2</td><td>合并两个⽂件或两栏的内容，中间⽤”+”区分</td></tr><tr><td>sort file1 file2</td><td>排序两个⽂件的内容</td></tr><tr><td>comm -1 file1 file2</td><td>⽐较两个⽂件的内容(去除’file1’所含内容)</td></tr><tr><td>comm -2 file1 file2</td><td>⽐较两个⽂件的内容(去除’file2’所含内容</td></tr><tr><td>comm -3 file1 file2</td><td>⽐较两个⽂件的内容(去除两⽂件共有部分)</td></tr></tbody></table><h1 id="打包和解压"><a href="#打包和解压" class="headerlink" title="打包和解压"></a>打包和解压</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>zip xxx.zip file</td><td>压缩⾄zip包</td></tr><tr><td>zip -r xxx.zip file1 file2 dir1</td><td>将多个⽂件+⽬录压成zip包</td></tr><tr><td>unzip xxx.zip</td><td>解压zip包</td></tr><tr><td>tar -cvf xxx.tar file</td><td>创建⾮压缩tar包</td></tr><tr><td>tar -cvf xxx.tar file1 file2 dir1</td><td>将多个⽂件+⽬录打tar包</td></tr><tr><td>tar -tf xxx.tar</td><td>查看tar包的内容</td></tr><tr><td>tar -xvf xxx.tar</td><td>解压tar包</td></tr><tr><td>tar -xvf xxx.tar -C /dir</td><td>将tar包解压⾄指定⽬录</td></tr><tr><td>tar -cvfj xxx.tar.bz2 dir</td><td>创建bz2压缩包</td></tr><tr><td>tar -jxvf xxx.tar.bz2</td><td>解压bz2压缩包</td></tr><tr><td>tar -cvfz xxx.tar.gz dir</td><td>创建gzip压缩包</td></tr><tr><td>tar -zxvf xxx.tar.gz</td><td>解压gzip压缩包</td></tr><tr><td>bunzip2 xxx.bz2</td><td>解压bz2压缩包</td></tr><tr><td>bzip2 filename</td><td>压缩⽂件</td></tr><tr><td>gunzip xxx.gz</td><td>解压gzip压缩包</td></tr><tr><td>gzip filename</td><td>压缩⽂件</td></tr><tr><td>gzip -9 filename</td><td>最⼤程度压缩</td></tr></tbody></table><h1 id="RPM包管理命令"><a href="#RPM包管理命令" class="headerlink" title="RPM包管理命令"></a>RPM包管理命令</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>rpm -qa</td><td>查看已安装的rpm包</td></tr><tr><td>rpm -q pkg_name</td><td>查询某个rpm包</td></tr><tr><td>rpm -q –whatprovides xxx</td><td>显示xxx功能是由哪个包提供的</td></tr><tr><td>rpm -q –whatrequires xxx</td><td>显示xxx功能被哪个程序包依赖的</td></tr><tr><td>rpm -q –changelog xxx</td><td>显示xxx包的更改记录</td></tr><tr><td>rpm -qi pkg_name</td><td>查看⼀个包的详细信息</td></tr><tr><td>rpm -qd pkg_name</td><td>查询⼀个包所提供的⽂档</td></tr><tr><td>rpm -qc pkg_name</td><td>查看已安装rpm包提供的配置⽂件</td></tr><tr><td>rpm -ql pkg_name</td><td>查看⼀个包安装了哪些⽂件</td></tr><tr><td>rpm -qf filename</td><td>查看某个⽂件属于哪个包</td></tr><tr><td>rpm -qR pkg_name</td><td>查询包的依赖关系</td></tr><tr><td>rpm -ivh xxx.rpm</td><td>安装rpm包</td></tr><tr><td>rpm -ivh –test xxx.rpm</td><td>测试安装rpm包</td></tr><tr><td>rpm -ivh –nodeps xxx.rpm</td><td>安装rpm包时忽略依赖关系</td></tr><tr><td>rpm -e xxx</td><td>卸载程序包</td></tr><tr><td>rpm -Fvh pkg_name</td><td>升级确定已安装的rpm包</td></tr><tr><td>rpm -Uvh pkg_name</td><td>升级rpm包(若未安装则会安装)</td></tr><tr><td>rpm -V pkg_name</td><td>RPM包详细信息校验</td></tr></tbody></table><h1 id="YUM包管理命令"><a href="#YUM包管理命令" class="headerlink" title="YUM包管理命令"></a>YUM包管理命令</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>yum repolist enabled</td><td>显示可⽤的源仓库</td></tr><tr><td>yum search pkg_name</td><td>搜索软件包</td></tr><tr><td>yum install pkg_name</td><td>下载并安装软件包</td></tr><tr><td>yum install –downloadonly pkg_name</td><td>只 下 载 不 安 装</td></tr><tr><td>yum list</td><td>显示所有程序包</td></tr><tr><td>yum list installed</td><td>查看当前系统已安装包</td></tr><tr><td>yum list updates</td><td>查看可以更新的包列表</td></tr><tr><td>yum check-update</td><td>查看可升级的软件包</td></tr><tr><td>yum update</td><td>更新所有软件包</td></tr><tr><td>yum update pkg_name</td><td>升级指定软件包</td></tr><tr><td>yum deplist pkg_name</td><td>列出软件包依赖关系</td></tr><tr><td>yum remove pkg_name</td><td>删除软件包</td></tr><tr><td>yum clean all</td><td>清除缓存</td></tr><tr><td>yum clean packages</td><td>清除缓存的软件包</td></tr><tr><td>yum clean headers</td><td>清除缓存的header</td></tr></tbody></table><h1 id="DPKG包管理命令"><a href="#DPKG包管理命令" class="headerlink" title="DPKG包管理命令"></a>DPKG包管理命令</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>dpkg -c xxx.deb</td><td>列出deb包的内容</td></tr><tr><td>dpkg -i xxx.deb</td><td>安装/更新deb包</td></tr><tr><td>dpkg -r pkg_name</td><td>移除deb包</td></tr><tr><td>dpkg -P pkg_name</td><td>移除deb包(不保留配置)</td></tr><tr><td>dpkg -l</td><td>查看系统中已安装deb包</td></tr><tr><td>dpkg -l pkg_name</td><td>显示包的⼤致信息</td></tr><tr><td>dpkg -L pkg_name</td><td>查看deb包安装的⽂件</td></tr><tr><td>dpkg -s pkg_name</td><td>查看包的详细信息</td></tr><tr><td>dpkg –unpack xxx.deb</td><td>解开deb包的内容</td></tr></tbody></table><h1 id="APT软件⼯具"><a href="#APT软件⼯具" class="headerlink" title="APT软件⼯具"></a>APT软件⼯具</h1><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>apt-cache search pkg_name</td><td>搜索程序包</td></tr><tr><td>apt-cache show pkg_name</td><td>获取包的概览信息</td></tr><tr><td>apt-get install pkg_name</td><td>安装/升级软件包</td></tr><tr><td>apt-get purge pkg_name</td><td>卸载软件（包括配置）</td></tr><tr><td>apt-get remove pkg_name</td><td>卸载软件（不包括配置）</td></tr><tr><td>apt-get update</td><td>更新包索引信息</td></tr><tr><td>apt-get upgrade</td><td>更新已安装软件包</td></tr><tr><td>apt-get clean</td><td>清理缓存</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python--元组</title>
    <link href="/2022/02/11/python-%E5%85%83%E7%BB%84/"/>
    <url>/2022/02/11/python-%E5%85%83%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="包含了元组中的大部分操作"><a href="#包含了元组中的大部分操作" class="headerlink" title="包含了元组中的大部分操作"></a>包含了元组中的大部分操作</h3><span id="more"></span><p>1.元组类似于数组，但是元组<strong>可以</strong>不带括号表示，如：数组：（1，2，3），元组：1，2，3。但是建议最好一直加上，增加代码的可读性。</p><p>2.不可以改变元组里面的数，如：a[1] = 9 是不可取的。正是因为元组不能修改，所以相对于数组来说安全性更高。</p><p>3.切片的翻转操作：a[::-1] 会把元组里面的所有的数进行翻转。</p><p>4.大部分的函数操作是和数组操作一样的：index操作，count操作等等都和数组是一样的</p><p>5.元组的嵌套：</p><p>s=(1,2,3)</p><p>t=(4,5,6)</p><p>w=s , t</p><p>print(w)</p><p>输出w的结果是((1,2,3),(4,5,6))</p><p>6.元组的迭代：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">s=(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br>t=(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)<br>w=s,t<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> w:<br><span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> i:<br><span class="hljs-built_in">print</span>(each,end=<span class="hljs-string">&quot; &quot;</span>)<br></code></pre></td></tr></table></figure><p>7.在元组中如何生成只有一个元素的元组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">x = (<span class="hljs-number">12</span>,)<br><span class="hljs-built_in">type</span>(x)<br></code></pre></td></tr></table></figure><p>使用type函数查看即可得出x是tuple元组类型，重要的是12后面的逗号！！</p><p>8.打包和解包：</p><p><strong>打包：即生成一个元组</strong></p><p>解包：如下图这样，生成的t有三个元素，分别赋值给x,y,z称之为解包，解包需要注意的是：左侧变量名的数量必须跟右侧元素的数量一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">t = (<span class="hljs-number">123</span>,<span class="hljs-number">12</span>,<span class="hljs-number">1</span>)<br>x,y,z = t<br><span class="hljs-built_in">print</span>(x,y,z)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo d出错时的解决办法</title>
    <link href="/2022/02/09/hexo-d%E5%87%BA%E9%94%99%E6%97%B6%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <url>/2022/02/09/hexo-d%E5%87%BA%E9%94%99%E6%97%B6%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>该方法是一次性的，并不能永久解决</p><span id="more"></span><p>删除blog/.deploy_git文件</p><p>然后输入</p><p>git config –gloabl core.autocrlf false`</p><p>重新</p><p>hexo clean</p><p>hexo g</p><p>hexo d</p><p>部署</p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”python--深拷贝和浅拷贝“</title>
    <link href="/2022/02/09/python-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <url>/2022/02/09/python-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<p><strong>假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。</strong></p><span id="more"></span><p>浅拷贝的实现方法：</p><p>x=…..</p><p>y=copy.copy(x)</p><p>深拷贝的实现方法：</p><p>x=…</p><p>y=copy.deepcopy(x)</p><p>其中第一个copy是copy模块</p><p><img src="https://img-blog.csdnimg.cn/550469b3a1764d3d9357df29840651d2.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>这样的copy是浅拷贝</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”python--列表里的函数“</title>
    <link href="/2022/02/09/python-%E5%88%97%E8%A1%A8%E9%87%8C%E7%9A%84%E5%87%BD%E6%95%B0/"/>
    <url>/2022/02/09/python-%E5%88%97%E8%A1%A8%E9%87%8C%E7%9A%84%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p> sort()将数组从小到大排序。</p><p>reverse（）将数组此时的位置进行倒转</p><span id="more"></span><p>count（？）问号的内容是数组里面的数据元素，这个函数用于数出这个数据元素在这个数组里面出现了几次</p><p>index（？），问号的内容是数组里面的数据元素，这个函数用于显示这个元素在数组里面出现的位置（如果有多个元素相同，那么显示第一个元素的位置）。<strong>可以在后面再加两个参数分别显示查找开始和结束的位置，index(？，start，end)</strong></p><p>一个数组赋值给另外一个列表，比如nums数组赋值给nums_two数组：nums_two = nums.copy()</p><p><strong>注意：nums这个数组和nums[:]这个数组是表示的同一个</strong></p><p><img src="https://img-blog.csdnimg.cn/9ee34faef1d743f089ab46f13fbc0e56.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/1918e8c5870c4dcba8d4b42608cde2ad.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_5,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”python--一些函数“</title>
    <link href="/2022/02/09/python-%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0/"/>
    <url>/2022/02/09/python-%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p> bool()：判断括号里面的结果是真还是假。</p><p>真的情况：在括号里面加引号，引号里面有任何值的结果都是真以及直接输入true（不加引号）</p><p>假的情况：在引号里面有引号但是引号里面什么都没有以及直接输入false</p><span id="more"></span><p>以下是定义为false的情况：</p><p><img src="https://img-blog.csdnimg.cn/91c7d524a1064e67a99244784f03bcc4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”python--除和地板除“</title>
    <link href="/2022/02/09/python-%E9%99%A4%E5%92%8C%E5%9C%B0%E6%9D%BF%E9%99%A4/"/>
    <url>/2022/02/09/python-%E9%99%A4%E5%92%8C%E5%9C%B0%E6%9D%BF%E9%99%A4/</url>
    
    <content type="html"><![CDATA[<p>3/2=1.5这个谁都懂</p><p>但是3//2=1这个代表3/2的结果向下取整，称之为地板除。</p><span id="more"></span><p>如-5//2，先算-5/2=-2.5，再向下取整，得-3。</p><p>我们还可以使用python的内置函数divmod（）</p><p>如divmod(3,2)=(1,1)结果中的第一个1代表着3//2的结果，第二个1代表着3%2的结果。</p><p>内置函数abs，如abs（x）意思是取x的绝对值</p><p>任何数据类型后面加括号加值的结果都是强制转换成该数据类型。</p><p>如：x=2.5</p><p>int（x）的结果就是2，向下取整！</p><p>pow(2,3)代表2的三次方，和2**3的效果一样。</p><p>pow（2,3,4）代表着2**3%4即2的三次方结果除四的余数！</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”python--字符串“</title>
    <link href="/2022/02/09/python-%E5%AD%97%E7%AC%A6%E4%B8%B2OLD/"/>
    <url>/2022/02/09/python-%E5%AD%97%E7%AC%A6%E4%B8%B2OLD/</url>
    
    <content type="html"><![CDATA[<p>在打印文本的时候如果不想显示转义字符的结果，可以在字符串的引号前面加上r。</p><span id="more"></span><p>如：1.不加r的时候:print(“D:\three\two\one\now”)</p><p>​     显示的结果是：<img src="https://img-blog.csdnimg.cn/cec7ee435319424bad8f796d47085fe4.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>2.加上r的时候: print(<strong>r</strong>“D:\three\two\one\now”)</p><p>​     显示的结果是：<img src="https://img-blog.csdnimg.cn/f7f5f4fca14d45db930067db3de40836.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>加上r代表这后面的字符串显示原始字符！</strong></p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”python--random“</title>
    <link href="/2022/02/09/python-random/"/>
    <url>/2022/02/09/python-random/</url>
    
    <content type="html"><![CDATA[<p>随机生产一个取值范围在10~100的整数：random.randint(10,100)</p><span id="more"></span><p>一个比较重要的语法：</p><p>random.randint(1~10)假设生成的随机数是1</p><p>random.randint(1~10)假设生成的随机数是3</p><p>random.randint(1~10)假设生成的随机数是6</p><p>我们使用random.setstate(x)</p><p>在后面我们再使用三次</p><p>random.randint(1~10）</p><p>三次生成的数分别是1，3，6，所以可以推断出setstate的作用是把前三次生成的随机数变成一个固定的状态再后面再生成！</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”Linux--文件目录指令“</title>
    <link href="/2022/02/09/Linux-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E6%8C%87%E4%BB%A4/"/>
    <url>/2022/02/09/Linux-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>介绍Linux用于文件的常用指令</p><span id="more"></span><p>1.pwd指令：显示当前文件目录的绝对路径</p><p>2.ls指令：显示当前目录下的文件（-a显示隐藏文件，-l以单行形式输出）</p><p>3.cd指令：（1）cd ~ 回到自己的家目录</p><p>​        （2）cd .. 回到上一级目录</p><p>4.mkdir（make dir）指令：mkdir 创建目录，mkdir -p 创建多级目录</p><p>5.rmdir 删除指定目录：（1）删除空目录 rmdir 目录</p><p>​                    (2) 删除非空目录 rm -rf 目录（是rm -f 和rm -r的结合体）</p><p>6.创建空文件：touch 文件名称。如创建一个Hello.txt 文件，使用touch Hello.txt</p><p><strong>7.cp指令：</strong></p><p><strong>(1)比如想把home/a路径下的Hello.txt文件拷贝到home/b路径下，我们要先在home/a路径下执行操作:cp Hello.txt home/b/</strong></p><p><strong>(2)把整个文件夹的内容拷贝到另外一个文件夹：cp -r home/a/ home/b/（其中是把a拷贝到b）</strong></p><p><strong>（3）强制覆盖文件的方法是在cp前面加一个\ 其他的不变</strong></p><p>8.rm指令：rm -r 递归删除整个文件夹</p><p>​         rm -f 强制删除不提示</p><p>9.mv指令：</p><p><img src="https://img-blog.csdnimg.cn/ab9d6a81664b4e97bfbb25e95846b7ba.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>例：若想把/home/目录下面的pig.txt文件移动到/target/目录下面，使用1.cd /home/  2.mv pig.txt /target/</p><p>10.cat指令：显示文件的内容（用cat -n 来显示行数），通常在cat指令后面会加上一个| more来给用户操作，有了more指令不会把你的文件在一行显示完可以有更多的操作。</p><p>11.more指令：也可以使用more指令来显示文件内容：more /home/Hello.java<img src="https://img-blog.csdnimg.cn/77e9b31369dc4d4b82157f2fb77c92fd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> 12.less指令： 跟more指令一样的作用，但是less指令是在文件看到哪里加载到哪里，不看的内容不会加载，这对大型文件很有作用。<img src="https://img-blog.csdnimg.cn/8593ab6174384638beca6a7edf1bb9bc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>13.echo指令：</p><p><img src="https://img-blog.csdnimg.cn/54a6b36c221b419e94f67338cf510d72.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_16,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>14.head指令：<br> <img src="https://img-blog.csdnimg.cn/b7a7a2663dd64d828304850916f30986.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">​</p><p> 例题答案：head -n 5 /etc/profile</p><p>15.tail指令：（与head指令相反） </p><p><img src="https://img-blog.csdnimg.cn/57c3d4a749ae43fa9a3530cd01a49298.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> 在后面加-f是实时监控、</p><p>比如我要监控Hello.txt文件，那么使用tail -f Hello.txt，然后我在linux的终端使用echo Hello &gt; Hello.txt，这时会在Xshell中显示Hello，因为实时监控了。</p><p>在echo Hello &gt; Hello.txt 中&gt;的作用是覆盖原先文件的内容，而&gt;&gt;的作用是在文件的后面追加内容</p><p><img src="https://img-blog.csdnimg.cn/9c2cbff394d14f77b07a3d72c5631388.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/6abcdc70449d491fa2902b21acffb776.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>16.ln指令：</p><p>ln -s [源文件或者目录] [软链接名] </p><p><img src="https://img-blog.csdnimg.cn/9f1d6f2211584101bd42d61514438c39.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>17.history指令：</p><p>显示出历史指令。</p><p><img src="https://img-blog.csdnimg.cn/a9bd055e7e5b4ecdbd997227dca209b4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_14,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>18.date指令：</p><p>显示当前日期</p><p>（1）date                显示当前时间</p><p>（2）date+%Y         显示当前年份（year）</p><p>（3）date+%m        显示当前月份（month）</p><p>（4）date+%d          显示当前是哪一天</p><p>（5）date“+%Y-%m-%d %H;%M;%S” 显示年月日时分秒</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”Linux--实用指令“</title>
    <link href="/2022/02/09/Linux-%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>/2022/02/09/Linux-%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>介绍Linux的运行级别和找回root密码的方式</p><span id="more"></span><p> <strong>1.运行级别：</strong></p><p><img src="https://img-blog.csdnimg.cn/cfe449dfc95f4cc1869792e4e53bf39c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_11,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>常用的运行级别是3和5</p><p>使用init来切换运行级别（init 运行级别）</p><p>查看当前运行级别：systemctl get-default</p><p><strong>2.找回root密码</strong></p><p>(1)在登录前的界面按下“e”编辑，如图：</p><p><img src="https://img-blog.csdnimg.cn/24c29cb043ac4d2f91a731ff9b6121ae.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>（2）找到linux16所在的那一行的下面一行：（如果没找到linux16就按着键盘向下的箭头就能看见了）</p><p><img src="https://img-blog.csdnimg.cn/2f7d063b6b994865a19935d18958e2de.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> （3）在UTF-8后面按下空格后加上这句话：init=/bin/sh</p><p><img src="https://img-blog.csdnimg.cn/8b229a66f7534503bcf5298f85aa9fcf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>(4)输入完之后按下快捷键Ctrl+x进入单用户模式（如果左边的Ctrl不行就试试右边的） </p><p>（5）在光标闪烁的位置输入这句话：mount -o remount,rw/  输入完之后回车。</p><p><img src="https://img-blog.csdnimg.cn/2f62ded86e884e48b6b27fa8e15eb14d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/3db9328c5fb742acbf74ccdcc4698f29.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> （6）然后在新界面光标闪烁位置输入passwd然后回车，输入新密码，然后确认密码</p><p>（7）输入完之后当我们看到passwd=****就说明成功修改了密码。</p><p><img src="https://img-blog.csdnimg.cn/5f29832e73d74f2dad243c54a44b6f6e.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>（8）紧接着在下面的一行输入这句话：touch /.autorelabel（注意：touch和/之间有一个空格）</p><p><img src="https://img-blog.csdnimg.cn/8df0b14725b648ec9f51e7b974ae8f33.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>（9）继续在光标闪烁的位置输入exec /sbin/init（同样在exec和/之间有一个空格），完成后按回车，耐心等待系统修改密码（时间会稍长）完成后linux会自动重启。</p><p><img src="https://img-blog.csdnimg.cn/4b5f47ea34064e89a594099f73e1c200.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>（10）登录时使用新密码即可 .</p><p>如果在登录的状态下修改密码那就容易得多了，在终端使用passwd 用户名 即可。</p><p><img src="https://img-blog.csdnimg.cn/8d46bf1dc8f4486f80463a0ad95c030b.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id="Linux里的帮助指令"><a href="#Linux里的帮助指令" class="headerlink" title="Linux里的帮助指令"></a><strong>Linux里的帮助指令</strong></h1><p><img src="https://img-blog.csdnimg.cn/4735254542224f94a3e8ba707bc2c2dc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> 基本命令：</p><p>ls 显示当前目录下所有文件但是没有隐藏文件</p><p>ls -a 显示当前目录下所有文件包括隐藏文件</p><p>ls -l（等效于ll）表示目录以单行的方式输出<img src="https://img-blog.csdnimg.cn/c8efefc5fb2144dc9fab281847b94cb6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> ls -la或者ls -al 表示单行输出文件包括隐藏文件</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”Linux--忘记密码的找回方法“</title>
    <link href="/2022/02/09/Linux-%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81%E7%9A%84%E6%89%BE%E5%9B%9E%E6%96%B9%E6%B3%95/"/>
    <url>/2022/02/09/Linux-%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81%E7%9A%84%E6%89%BE%E5%9B%9E%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>非常详细！保姆级教程！</p><span id="more"></span><p> (1)在登录前的界面按下“e”编辑，如图：</p><p><img src="https://img-blog.csdnimg.cn/24c29cb043ac4d2f91a731ff9b6121ae.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>（2）找到linux16所在的那一行的下面一行：（如果没找到linux16就按着键盘向下的箭头就能看见了）</p><p><img src="https://img-blog.csdnimg.cn/2f7d063b6b994865a19935d18958e2de.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> （3）在UTF-8后面按下空格后加上这句话：init=/bin/sh</p><p><img src="https://img-blog.csdnimg.cn/8b229a66f7534503bcf5298f85aa9fcf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>(4)输入完之后按下快捷键Ctrl+x进入单用户模式（如果左边的Ctrl不行就试试右边的） </p><p>（5）在光标闪烁的位置输入这句话：mount -o remount,rw/  输入完之后回车。</p><p><img src="https://img-blog.csdnimg.cn/2f62ded86e884e48b6b27fa8e15eb14d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/3db9328c5fb742acbf74ccdcc4698f29.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> （6）然后在新界面光标闪烁位置输入passwd然后回车，输入新密码，然后确认密码</p><p>（7）输入完之后当我们看到passwd=****就说明成功修改了密码。</p><p><img src="https://img-blog.csdnimg.cn/5f29832e73d74f2dad243c54a44b6f6e.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>（8）紧接着在下面的一行输入这句话：touch /.autorelabel（注意：touch和/之间有一个空格）</p><p><img src="https://img-blog.csdnimg.cn/8df0b14725b648ec9f51e7b974ae8f33.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>（9）继续在光标闪烁的位置输入exec /sbin/init（同样在exec和/之间有一个空格），完成后按回车，耐心等待系统修改密码（时间会稍长）完成后linux会自动重启。</p><p><img src="https://img-blog.csdnimg.cn/4b5f47ea34064e89a594099f73e1c200.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>（10）登录时使用新密码即可 .</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”Linux--用户管理“</title>
    <link href="/2022/02/09/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
    <url>/2022/02/09/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p> 一、基本操作：</p><p>添加用户：useradd 用户名</p><p>删除用户(保留家目录）：userdel 用户名(但是需要root权限，自己当然不能删除自己)</p><span id="more"></span><p>删除用户(不保留家目录)：userdel -r 用户名</p><p>更改用户密码：passwd 用户名</p><p>查询用户信息：id 用户名</p><p>切换用户：1.低权限用户到高权限用户（root）需要密码，反之不需要。</p><p>​         2.使用su - 用户名来实现，在高权限状态时可以使用exit/logout来换成普通用户。</p><p>想要查看现在的用户是谁：who am i（离谱）</p><p>pwd：查看现在在哪个目录下面</p><p><strong>用户组：（有一定的权限，对一个组的用户进行批量操作）</strong></p><p>添加组：groupadd 组名</p><p>删除组：groupdel 组名</p><p>创建用户的同时分组：useradd -g 组名 用户名</p><p>用户换组：usermod -g 新组名 用户名</p><p><strong>用户和组的相关文件：</strong></p><p>/etc/passwd文件：（其中shell相当于中间商，我们的指令要经过shell才能发送给linux进行识别）<img src="https://img-blog.csdnimg.cn/7157c66835b141c2a79d908aca8b62bd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>/etc/shadow文件：<img src="https://img-blog.csdnimg.cn/112b921605f2469faa7f4c5662f1c333.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”Linux--vi和vim“</title>
    <link href="/2022/02/09/Linux-vi%E5%92%8Cvim/"/>
    <url>/2022/02/09/Linux-vi%E5%92%8Cvim/</url>
    
    <content type="html"><![CDATA[<p> vim具有编程的能力，是vi的增强版本，代码补全，颜色都有（有点像IDEA） </p><span id="more"></span><p><img src="https://img-blog.csdnimg.cn/7f41fab8a28c46cc877a41e40ddc1957.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>注意：</p><p>1.按下“i”进入输入模式；先输入esc再按下“：”进入命令行模式。不进入编辑模式是没办法写代码的。</p><p>2.vim和vi的命令是区分大小写的。</p><p>-——————————————————————————————————————————–</p><h2 id="下面用Xshell和vim写一个Hello-java程序："><a href="#下面用Xshell和vim写一个Hello-java程序：" class="headerlink" title="下面用Xshell和vim写一个Hello.java程序："></a><strong>下面用Xshell和vim写一个Hello.java程序：</strong></h2><p>1.先输入这个指令：vim Hello.java</p><p><img src="https://img-blog.csdnimg.cn/6e6abde8af21487191742eadbff7d350.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>2.在生成的界面中按下“i”键进入编辑模式，看到最下面变成“–插入–” 即可</p><p><img src="https://img-blog.csdnimg.cn/a4df0727a4e446f79efd224933f30871.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_12,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>3.在空白的地方写java代码，输出一个Helloworld</p><p><img src="https://img-blog.csdnimg.cn/ab0f994ac7ec4d73aeb50f516514790f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>4.最后按下esc再按下“：wq”（其中wq表示write和quit）即可完成Hello.java程序的编写。</p><p>-——————————————————————————————————————————–</p><h1 id="重点：在vim中各种模式的切换"><a href="#重点：在vim中各种模式的切换" class="headerlink" title="重点：在vim中各种模式的切换"></a><strong>重点：在vim中各种模式的切换</strong></h1><p> <img src="https://img-blog.csdnimg.cn/a081d79f164048a8a0b204e1e2237e82.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>wq（保存退出），q（退出），q！（强制退出，并且不保存）</p><p>快捷键：</p><p>1.“yy”用于拷贝当前行，“5yy”用于拷贝从光标那行往下的5行。</p><p>2.“dd”用于删除当前行，“5dd”用于删除光标往下的那5行。</p><p>3.寻找文件中对应的关键字或者字符，在一般模式下点“/” 然后输入你想找的关键字。输入“n”寻找下一个。</p><p>4.按下“G”到达文件的最底端，按下“gg”到达文件的最顶端。</p><p>5.撤销动作：在一般模式下按“u”。</p><p>6.想要定位到对应的行：比如你想对应到20行，在一般模式下输入20，然后shift+g。</p><p>7.一般模式下“：”输入set nu表示打开行号，输入“set nonu”表示关闭行号。</p><h1 id="Linux下的开机，重启，关机"><a href="#Linux下的开机，重启，关机" class="headerlink" title="Linux下的开机，重启，关机"></a><strong>Linux下的开机，重启，关机</strong></h1><p>1.shutdown -h now 现在马上关机</p><p>2.shutdown -h 1 一分钟后关机</p><p>3.shutdown -r now 现在马上重启</p><p>4.halt 关机</p><p>5.reboot 现在重启</p><p>6.sync 将内存的内容同步到磁盘(相当于保存)</p><h1 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a><strong>用户登录</strong></h1><p>尽量不要使用root登录，避免失误。</p><p>若是普通用户登录后需要获得管理员权限，使用su-用户名 即可。</p><p>使用logout来注销用户登录（在运行级别三上面有用）</p><p>在root情况下logout退到你原来的用户，再使用一次logout退出系统！</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”Linux--Xshell和Xftp“</title>
    <link href="/2022/02/09/Linux-Xshell%E5%92%8CXftp/"/>
    <url>/2022/02/09/Linux-Xshell%E5%92%8CXftp/</url>
    
    <content type="html"><![CDATA[<p>共同点：xshell和Xftp都需要使用Linux中的ip地址（在linux的cmd中使用ifconfig来查看连接用到的ip）</p><p>不同点：Xftp用于发送文件。</p><p>Xshell可以使用windows来访问Linux，实现远程操控。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”JAVA--泛型“</title>
    <link href="/2022/02/09/JAVA-%E6%B3%9B%E5%9E%8B/"/>
    <url>/2022/02/09/JAVA-%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>介绍泛型的基本概念</p><span id="more"></span><p><strong>基本概念：</strong>（传递类型参数的东西）</p><p><img src="https://img-blog.csdnimg.cn/img_convert/446e9973ebc5dab7b15dbedca430ed4c.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”JAVA--List接口“</title>
    <link href="/2022/02/09/JAVA-List%E6%8E%A5%E5%8F%A3/"/>
    <url>/2022/02/09/JAVA-List%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<p>List接口的特点：有序，有下标，元素可以重复</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c9cdc1cdd6f5c40143f331e073b1e6d5.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>方法</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0bedf789e0a4cd33aaa07ae2168acd44.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>添加和删除元素</p><p><img src="https://img-blog.csdnimg.cn/img_convert/19185e0b9483bfe1b38c34162844d34f.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>get方法用于获取对应下标的元素</p><p>使用迭代器的时候一定要创建对象：Iteration it = new Iteration();</p><p>列表迭代器ListIteration:</p><p><img src="https://img-blog.csdnimg.cn/img_convert/dcbd1ce79c18634b6492f4448bf5b888.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>ListIteration</p><p>判断和获取位置：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ca6817f90e6db3a22f8091e3658e58ab.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>List对象使用List.remove();括号里面填的是对应删除位置的下标，要删除对应元素要使用“”</p><p>subList方法：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6f314a747cf1a833d4c6d71055ca2ac7.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>subList</p><p>用来返回一个子集合，括号里面有两个数，逗号前面是集合开始的位置，后面是集合结束的位置。注意是含头不含尾的，左闭右开。</p><p><strong>List的类</strong>：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/de3ed4574c6a50d128b9bd4d3f3cdacb.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>Vector现在少用了，ArrayList用的多</p><p>ArrayList默认长度是0。</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”JAVA--Collec体系集合“</title>
    <link href="/2022/02/09/JAVA-Collecting%E4%BD%93%E7%B3%BB%E9%9B%86%E5%90%88/"/>
    <url>/2022/02/09/JAVA-Collecting%E4%BD%93%E7%B3%BB%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<p> Collect接口知识点总结</p><span id="more"></span><p><img src="https://img-blog.csdnimg.cn/img_convert/5888cfe5738f77ca7a81306dbae10536.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>rt</p><h2 id="Collect父接口"><a href="#Collect父接口" class="headerlink" title="Collect父接口"></a>Collect父接口</h2><p>特点：（有些）对象，无序，无下标，不能重复–&gt;对应着Set接口。</p><p>方法：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3bf59b036ab708cfc76b85554f643deb.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>常用方法</p><p>iteration迭代器</p><p><img src="https://img-blog.csdnimg.cn/img_convert/58df797c645cb5fe3e3f7dbd39a89bc0.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>使用next()来用指针不断指向下一行</p><p>iteration要定义对象的：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/79b7331b81bc69966635494f587bc2a0.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>三个常用方法</p><p><strong>注意：</strong>在iteration里面不能使用collection.remove();来删除元素，要使用iteration(这是对象)来删除元素，iteration.remove()。</p><p>collection判断：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/80ec081de26e2bccf885c09c38fe3aba.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>使用contains方法进行判断，返回值是布朗类型的</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”JAVA--集合知识点“</title>
    <link href="/2022/02/09/JAVA-%E9%9B%86%E5%90%88%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2022/02/09/JAVA-%E9%9B%86%E5%90%88%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>1.集合的概念：存放对象的容器，类似数组的概念，同样集合也有对多个对象进行批量操作的功能。</p><span id="more"></span><p>2.集合与数组的区别：<br>（1）数组的长度是固定的，但是集合的长度是不固定的。</p><p>（2）数组可以存放引用类型（如Integer Float等）和基本数据类型（int float 等），集合只能存放引用类型。</p><p>3.集合用到的所有类都在java.util.*这个包里面。</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”JAVA--JDBC知识点“</title>
    <link href="/2022/02/09/JAVA-JDBC%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2022/02/09/JAVA-JDBC%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>JDBC相当于一个驱动，让数据库和java打交道。</p><span id="more"></span><p>对于开发人员来说，只需要掌握JDBC接口的操作即可。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6cb5c95aa1fa076e8db6cc3bbedaf3e6.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>结构图，我们只需要学JDBC</p><p><img src="https://img-blog.csdnimg.cn/img_convert/1f734dc4920ffa0e272fe890bfcf6492.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>记得先要导入jar包</p><h2 id="mysql-—-基本的操作"><a href="#mysql-—-基本的操作" class="headerlink" title="mysql — 基本的操作"></a><a href="https://dopagip.wordpress.com/2021/12/12/mysql-%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/">mysql — 基本的操作</a></h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--在sql里面所有的注释都用“--”,school是我们创建的数据库。</span><br><span class="hljs-keyword">show</span> databases; <span class="hljs-comment">--显示所有的数据库</span><br><br>use school; <span class="hljs-comment">--使用数据库</span><br>change <span class="hljs-keyword">database</span><br><br>use <span class="hljs-keyword">tables</span>;  <span class="hljs-comment">--显示所有的数据表</span><br><br><span class="hljs-keyword">desc</span> <span class="hljs-keyword">tables</span>; <span class="hljs-comment">--显示数据库中所有表的信息</span><br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> &quot;school&quot;; <span class="hljs-comment">--创建数据库</span><br><br><span class="hljs-keyword">exit</span>; <span class="hljs-comment">--退出mysql</span><br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>数据库XX语言：</strong></p><p>DDL 定义</p><p>DML 操作</p><p>DQL 查询</p><p>DCL 控制</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”JAVA--数据库操作“</title>
    <link href="/2022/02/09/JAVA-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/02/09/JAVA-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">1.创建数据库<br>CREATE DATABASE [IF NOT EXISTS] school;<br><br>2.使用数据库<br>USE `school` --如果你的数据库是一个字段名称，则需要用到``<br>USE school<br><br>3.删除数据库<br>DROP school<br><br>4.查看数据库<br>show school<br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><span id="more"></span><p><strong>1.数据的类型：</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/91af09cb3212396fd9c813d854b51273.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>数据类型</p><p><strong>2.字符的类型</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/56725a5990086f030065bd7f4d69e6ec.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>3.时间日期：</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/7deb7817956479929d635e146dd7daf1.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>时间和日期的表示</p><h2 id="数据库的字段属性（重点）"><a href="#数据库的字段属性（重点）" class="headerlink" title="数据库的字段属性（重点）"></a><strong>数据库的字段属性</strong>（重点）</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/c747df1e0837a93370d176c7069d4eda.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/8b083c9474eed9a88b4beffa3043cbfe.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>修改表数据：（所有修改表的操作都使用ALTER来操作）</p><p><img src="https://img-blog.csdnimg.cn/img_convert/70414dc25ff166f16d33a9daa0bef6fc.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/d8784fef04c69c151654bbe73747730f.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>删除表的话用：DROP TABLE student;</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”JAVA--properties类“</title>
    <link href="/2022/02/09/JAVA-properties%E7%B1%BB/"/>
    <url>/2022/02/09/JAVA-properties%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p> properties相当于一个集合</p><span id="more"></span><p><img src="https://img-blog.csdnimg.cn/img_convert/d91d50beb656346ba65a174526fc43f6.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>setproperties在集合里面增加变量。</p><p>1.list方法适用于PrintWriter</p><p>2.store方法适用于FileOutputStream</p><p>3.load方法适用于FileInputStream</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”JAVA--文件file类“</title>
    <link href="/2022/02/09/JAVA-%E6%96%87%E4%BB%B6file%E7%B1%BB/"/>
    <url>/2022/02/09/JAVA-%E6%96%87%E4%BB%B6file%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>java.io.File是文件名的抽象表示。</p><span id="more"></span><p><strong>你的文件表示必须在创建对象时候体现。</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/fb6fdb58d06f307e95bb0d2ef094c34d.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>常用的方法</p><p><img src="https://img-blog.csdnimg.cn/img_convert/750b65bb2dac31431da0c1b5fd888c62.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>File中的Separator是\ ，Separator是;</p><p><strong>最好是用一个布尔类型的变量来表示createNewFile</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/528a9bda160f3d0530d1dc86aad54817.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>用布尔类型表示</p><p>删除文件：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/9af1fd354a5574fcaab8bd8ebe206a6b.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>有这两种方法</p><p>获取文件创建日期：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b26e5fed45d628eebec7235cb9350a2a.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>判断文件是否可写可读；</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3f790142d2c2d99e836e65e2346e57d7.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>当只读的时候就不能写了</p><p>判断是不是文件，是否是隐藏的：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/dce4fd3d48c2ccd0dc1fba07e62d8da5.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>判断是不是隐藏的，是不是文件：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ce447e9b190e99c3e310830dfc5b3daa.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>这里可以选择</p><h2 id="文件夹"><a href="#文件夹" class="headerlink" title="文件夹"></a>文件夹</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/ac863ec6df97a50a337f82ec314ebcbc.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>mkdirs创建多级目录文件夹，mkdir创建单级文件夹。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/9541a40c8b7423f37eb5e810b1bb34db.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>获取绝对路径，路径，文件名</p><p><img src="https://img-blog.csdnimg.cn/img_convert/9a2e173622aa85c9f576a72996639cc0.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>判断是否是文件夹是否隐藏</p><p><img src="https://img-blog.csdnimg.cn/img_convert/de6bca422bb73bab89a0181d5a3a2381.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>用了增强for循环</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”JAVA--转换流知识点“</title>
    <link href="/2022/02/09/JAVA-%E8%BD%AC%E6%8D%A2%E6%B5%81%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2022/02/09/JAVA-%E8%BD%AC%E6%8D%A2%E6%B5%81%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>InputStreamReader和OutputStreamWriter:</p><span id="more"></span><p> <strong>InputStreamReader</strong>:</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f0b6cfe4735777363bc8e2eeafde2a2b.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>这样接下来直接用isr即可</p><p>OutputStreamWriter同理。</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”JAVA--字符流知识点“</title>
    <link href="/2022/02/09/JAVA-%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2022/02/09/JAVA-%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>在使用read读取字符流的时候，一点要在硬盘里面先创建要读取的文件，否则会报错。</p><span id="more"></span><p><strong>字符流和字节流的区别：字节流可以复制所有包括图片的文件，但是字符流只能复制文本文件，图片等文件都不能复制。</strong></p><p><strong>输入流（FileReader）：</strong></p><p>public int read(char[] c);从流中读取多个字符，将读到的内容存进c数组，返回读取到的字符数，如果到达文件的结尾，返回-1。</p><p>一种方法：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/5a90bcd8900c6c6b86f4918742c563c0.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>另一种方法：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b26f776ef1dc56a1cd10c2f50b73c6d3.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>输出流（FileWriter）：</strong></p><p>public void write(String str):一次写入多个字符，将str中的所有字符全部写入输出流中。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7624a06874a9e5560ec895e884896a18.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>只能用for循环表示，while循环无法转换类型。</p><p>用FileWriter和FileReader复制文件：（只能复制文本文件，不能复制图片和声音视频等）</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ca3c56e7bb5938b65c0e17d26fe500d8.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>把read的内容复制粘贴到read1当中，利用了字符数组by</p><p><strong>复制图片文件？</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/9b0880f0888663e401ee1f5c7a0bfcde.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>文件名字不一样，其他和上面一样。</p><p>结果会报错：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/99730c60bdecf8a9c918b73c61618110.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>WriterBuffered缓冲区和ReaderBuffered缓冲区:</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0c932e4142daa263933523eea841c51a.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>br.read()一次读取一个字符</p><p>没什么难度，和前面一样。</p><p>缓冲流的特点：</p><p>1.高效读写；2.支持输入换行符(bw.newline;)；3.可以一次写一行读一行。（用readline一次读取一行而不是一个字符。）</p><p><img src="https://img-blog.csdnimg.cn/img_convert/2f6b2103d1048aa0da0f0683df50fba7.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>读取一行字符，以换行符为结尾。</p><p><strong>PrintWriter的使用：</strong>调用java.io.PrintWriter.</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ac542505b12931975133b1314d0ac37a.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>相当于直接用System.out来打印，可以使用print和println等等，记得close关闭.</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”JAVA--字符编码知识点“</title>
    <link href="/2022/02/09/JAVA-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2022/02/09/JAVA-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>介绍五种常用编码方式</p><span id="more"></span><p>ISO-8859-1 ：ASCII编码+西欧希腊等国的字符编码。</p><p>UTF-8：针对Unicode码的字符编码。</p><p>GBK ：简体中文。</p><p>GB312：简体中文。</p><p>BIG5：台湾，繁体中文。</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”JAVA--流的知识点“</title>
    <link href="/2022/02/09/JAVA-%E6%B5%81%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2022/02/09/JAVA-%E6%B5%81%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p><strong>概念：存储和内存之间的传输数据的通道.(硬盘和内存之间)</strong></p><span id="more"></span><p>一、<strong>流的分类：</strong></p><p>*<strong>1.按方向：*</strong></p><p>输入流(input)：将“存储设备”中的数据留到“内存(程序)”中。</p><p>输出流(output)：将“内存(程序)”中的数据流到“存储设备”中去。</p><p><em><strong>2.按单位：</strong></em></p><p>字节流：以字节为单位，可以读写所有数据。</p><p>字符流：以字符为单位，只能读写文本数据。</p><p>*<strong>3.按功能：*</strong></p><p>节点流：具有实际传输数据的读写功能。</p><p>过滤流：在节点流的基础之上增强功能。</p><p>字节流的父类（抽象）：<br> <strong>InputStream:字节输入流</strong>:</p><p>int <code>available()</code> 返回从该输入流中可以读取（或跳过）的字节数的估计值，而不会被下一次调用此输入流的方法阻塞。</p><p><code>void close()</code> 关闭此输入流并释放与流相关联的任何系统资源。</p><p><code>void mark(int readlimit)</code> 标记此输入流中的当前位置。</p><p><code>boolean markSupported()</code> 测试这个输入流是否支持 <code>mark</code>和 <code>reset</code>方法。</p><p><code>abstract int read()</code> 从输入流读取数据的下一个字节。</p><p><code>int read(byte[] b)</code> 从输入流读取一些字节数，并将它们存储到缓冲区 <code>b</code> 。</p><p><code>int read(byte[] b, int off, int len)</code> 从输入流读取最多 <code>len</code>字节的数据到一个字节数组。</p><p><code>void reset()</code> 将此流重新定位到上次在此输入流上调用 <code>mark</code>方法时的位置。</p><p><code>long skip(long n)</code> 跳过并丢弃来自此输入流的 <code>n</code>字节数据。</p><p><strong>OutputStream:字节输出</strong>:</p><p><code>void close()</code> 关闭此输出流并释放与此流相关联的任何系统资源。</p><p><code>void flush()</code> 刷新此输出流并强制任何缓冲的输出字节被写出。</p><p><code>void write(byte[] b)</code> 将 <code>b.length</code>字节从指定的字节数组写入此输出流。</p><p><code>void write(byte[] b, int off, int len)</code> 从指定的字节数组写入 <code>len</code>个字节，从偏移 <code>off</code>开始输出到此输出流。</p><p><code>abstract void write(int b)</code> 将指定的字节写入此输出流。</p><p>二、<strong>文件字节流：</strong></p><p>1.<strong>FileInputStream:–public int read*(*byte*[]* b*)*// 从流中读取多个数据，将读到的内容存入b数组，返回实际读到的字节数，，如果达到文件的结尾，则返回-1.</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/edc9beae38a7bf6cb7bf5991f8efc529.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>2.<strong>FileOutputStream:–public void write*(*byte*[]* b*)*//一次写多个字节，将写的字节读入输出流</strong>.<strong>(就是把想要写进文件里面的字符串写在代码里面，代码会帮你写进字符串里面)</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs abnf">FileOutputStream fop <span class="hljs-operator">=</span> new FileOutputStream(<span class="hljs-string">&quot;D:\\aa.txt&quot;</span>)<span class="hljs-comment">;</span><br>//如果改成FileOutputStream fop <span class="hljs-operator">=</span> new FileOutputStream(<span class="hljs-string">&quot;D:\\aa.txt&quot;</span>，true)<span class="hljs-comment">;则会变成运行一次在后面加一次123456；</span><br>String str <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123456&quot;</span><span class="hljs-comment">;</span><br>fop.write(str.getBytes())<span class="hljs-comment">;</span><br>//就是用这三行代码可以把<span class="hljs-number">123456</span>输入到aa.txt里面。<br><br>三、字节缓冲流<br>import  java.io.BufferedInputStream<span class="hljs-comment">;</span><br>import  java.io.BufferedOutputStream<span class="hljs-comment">;</span><br>用处：<span class="hljs-number">1</span>.提高IO流效率，减少访问磁盘的次数；<span class="hljs-number">2</span>.数据存储在缓冲区，flush是将缓冲区的内容写进文件里面，也可以直接close。<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/fd912797abd223d09258cc59acac38e2.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>在创建BufferedOutputStream对象之后，关闭bis对象时默认也会关闭fis对象，因此只用调用bis.close();即可关闭两个。</p><p><strong>输出（output）缓冲区会把write方法里面的内容存在缓冲区，要输入文件就要调用flush方法写入文件。</strong></p><p><strong>四、对象流：</strong>（ObjectInputStream和ObjectOutputStream）</p><p>两个基本方法：</p><p>1.readObject:从流中读取一个对象。</p><p>2.writeObject(Object obj):向流中写入一个对象。</p><p>称为序列化和反序列化，下面来解释：</p><p>1.序列化：(类似于在硬盘里面输出对象)（ObjectOutputStream）</p><p><img src="https://img-blog.csdnimg.cn/img_convert/de2c5f977a12b845233c293b9c2cea24.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>*<strong>注意:序列化时在要输出的类当中，必须要调用一个接口：implements Serializable。</strong></p><p>2.反序列化：(类似于往流里面输入对象)（ObjectInputStream）</p><p><img src="https://img-blog.csdnimg.cn/img_convert/bfbd81e69a080dcf34d278cac160001c.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>我们可以使用对象.toString方法打印出写入流的数据。（方法，属性等等）</strong></p><p>*序列的注意事项：</p><p>1.必须使用Serializable接口。（包括属性也是一样）</p><p>2.序列化版本号ID可以在类中定义，保证序列化和反序列化的ID是相同的值。（更改了声明对象的类的序列化ID之后，不能直接反序列化，必须先序列化一次使得硬盘中的序列号相同才能下一步反序列化）。</p><p>3.使用transient（瞬间的）修饰属性，这个属性不能被序列化。</p><p>4.静态的属性不能序列化。</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”JAVA--类的盘点“</title>
    <link href="/2022/02/09/JAVA-%E7%B1%BB%E7%9A%84%E7%9B%98%E7%82%B9/"/>
    <url>/2022/02/09/JAVA-%E7%B1%BB%E7%9A%84%E7%9B%98%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>先来一个特殊的：</p><p>double res = 1.4-0.5/0.9;</p><span id="more"></span><p>System.out.println(res);//这时候输出的会是0.999999999</p><p>这时候就要用到BigDecimal来精确输出double类型的数据了。</p><p>BigDecimal num = new BigDecimal(“0.9”);//这样就可以声明一个BigDecimal数据了。</p><p>当然要在前面加上import java.math.BigDecimal来引入BigDecimal</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.4&quot;</span>).subtract(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0.5&quot;</span>)).<br>divide(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0.9&quot;</span>)))<span class="hljs-comment">//这样就可以输出1而不是0.9999999了。</span><br>同样也可以:<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.4&quot;</span>).subtract(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0.5&quot;</span>)).divide(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0.9&quot;</span>))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”JAVA--常用类“</title>
    <link href="/2022/02/09/JAVA-%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
    <url>/2022/02/09/JAVA-%E5%B8%B8%E7%94%A8%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>介绍两个类：Date和Calendar</p><p><strong>一、Date表示特定的瞬间，精确到毫秒。</strong></p><p>1.创建date对象：</p><p>Date date=new Date();</p><p>2.一些方法：直接打印date：输出当前的时间。</p><p>打印date.getTime输出从1970.1.1到现在所有的毫秒数。</p><p>方法after和before:直接加一天。</p><p>compareTo方法，date1.toString(date2)，是date1-date2.</p><p>当然也可以用equal方法。</p><p><strong>二、Calendar类提供了获取各类日历字段的方法：(就是你代替了date类当中的许多方法)</strong></p><p>因为Calendar的构造方法是protected的，所以不能直接创建对象。要通过</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs processing">Calendar calendar = Calendar.<span class="hljs-property">getInstance</span>();来设置Calendar对象。<br>Calendar的方法很多，<span class="hljs-built_in">get</span>最常见，<span class="hljs-type">int</span> <span class="hljs-built_in">year</span> = calendar.<span class="hljs-property">get</span>(calendar.<span class="hljs-property">YEAR</span>);这样输出的就是今年的年份了。<br><span class="hljs-type">int</span> <span class="hljs-built_in">year</span> = calendar.<span class="hljs-property">get</span>(calendar.<span class="hljs-property">YEAR</span>);<br><span class="hljs-type">int</span> <span class="hljs-built_in">month</span> = calendar.<span class="hljs-property">get</span>(calendar.<span class="hljs-property">MONTH</span>);<br><span class="hljs-type">int</span> <span class="hljs-built_in">day</span> = calendar.<span class="hljs-property">get</span>(calendar.<span class="hljs-property">DAY_OF_WEEK</span>);<br><span class="hljs-type">int</span> <span class="hljs-built_in">hour</span> = calendar.<span class="hljs-property">get</span>(calendar.<span class="hljs-property">HOUR</span>);<br><span class="hljs-type">int</span> <span class="hljs-built_in">minute</span> = calendar.<span class="hljs-property">get</span>(calendar.<span class="hljs-property">MINUTE</span>);<br><span class="hljs-type">int</span> <span class="hljs-built_in">second</span> = calendar.<span class="hljs-property">get</span>(calendar.<span class="hljs-property">SECOND</span>);<br>这样分别定义了年，月，日，小时，分钟，秒。用<span class="hljs-built_in">get</span>()方法!<br>calendar.<span class="hljs-property">getActualMaximum</span>()可以输出括号内的最大值，如calendar.<span class="hljs-property">getActualMaximum</span>(Calendar.<span class="hljs-property">DAY_OF_MOUTH</span>),可以输出月份的最大值<span class="hljs-number">30.</span><br>同理calendar.<span class="hljs-property">getActualMinimum</span>()<br></code></pre></td></tr></table></figure><p><strong>三、SimpleDateFormat类用于格式化解析日期：（import java.text.SimpleDateFormat）</strong></p><p>1.创建SimpleDateFormat对象：(Y：年，M:月，d：日，H：小时，m:分钟，s：秒)</p><p>SimpleDateFormat sim = new SimpleDateFormat(“YYYY年MM月dd日 HH:mm:ss”)</p><p>2.//创建date：</p><p>Date date = new Date();</p><p>//格式化date</p><p>String str = sim.format(date);</p><p>这时候再把str打印出来就可以得到—–2021年11月08日 10:27:08</p><p><strong>四、System类（很重要！）</strong></p><p>私有类，不需要创建对象，并且方法是静态的。</p><p>方法：</p><p><strong>1.arraycopy：用于复制数组</strong></p><p>arraycopy(src,srcPos,dest,destPos,length)有五个参数</p><p>//src:原数组，srcPos：从什么位置开始复制，dest：目标数组，destPos:目标数组的位置</p><p>要注意目标数组长度要大于等于原数组长度。</p><p><strong>2.currentTimeMillis：获取当前系统时间，返回毫秒值。</strong></p><p>可以用来计算程序执行的时间，在程序前面加个start在程序后面加个end。</p><p><strong>3.gc()：建议JVM使用垃圾回收器回收垃圾。</strong></p><p>用来回收不用的对象。</p><p>4.exit(int status)：退出JVM，参数是0表示正常退出，参数是-1表示异常退出。</p><p>在exit后面的语句当然就不执行了！</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”JAVA--Sring声明“</title>
    <link href="/2022/02/09/JAVA-Sring%E5%A3%B0%E6%98%8E/"/>
    <url>/2022/02/09/JAVA-Sring%E5%A3%B0%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<p>引用类型的引用在栈里面，对象在堆里面。</p><span id="more"></span><p>字符串的字面值存储在字符串池中，可以实现共享。</p><p>String name = 20;//这里name存储在堆里面，20存储在方法池里面。</p><p>声明string字符串有两种方式：</p><p>1.String name = “Hellp”//产生一个对象，存储在字符串池中</p><p>2.String name = new String(“Hello”)//产生两个对象，在字符串池和堆中各存放一个</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”JAVA--Sring方法“</title>
    <link href="/2022/02/09/JAVA-Sring%E6%96%B9%E6%B3%95/"/>
    <url>/2022/02/09/JAVA-Sring%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>一共十三点</p><p>1.length()：返回字符串长度。</p><p>2.charAt(number)：用于定点输出字符，记住从0开始计算，例如charAt(3)用来输出在字符串第四位的字符。</p><p>3.contains（”字符串”）：用于判断在大的字符串里面是否包含contains里面的字符串，如果包含返回true，不包含返回false。</p><p>4.toCharArray()：返回字符串对应的数组 。</p><p>5.indexOf()：返回子字符串首次出现的位置。可以indexOf(“***”，number)意思就是从第number个数字开始往后数。</p><p>6.lastIndexOf()：返回字符串最后一次出现的位置。</p><p>7.trim()：去掉在字符串之间存在的空格</p><p>8.toUpperCase()：把小写转换成大写，toLowerCase()：把大写转换成小写。</p><p>9.endWith(str)：判断是否已str结尾，是输出true，反之输出false。startsWith(str)判断是否str开头。</p><p>10.split(“分隔符”)：对字符串进行拆分，用for循环输出。如果要空格逗号都成为分隔符则用split([ ,])里面放空格和逗号。如果要多个空格成为分隔符则用split([ ]+)。</p><p>11.equal：比较两个字符串是否相等，如果内容相同但是大小写不同用字符串1.equalIgnoreCase(字符串2).</p><p>12.s3.compareTo(s4)：实现s3减s4，如果是字符串就用第一个字符的ASCII码相减，如果第一个字符相等就比较第二个。<code>String s1 = &quot;abc&quot;;</code>String s2 = “abcxyz”;前三个abc都相同，但是s1后面没有了，就用长度相减3-6 = -3；</p><p>13.replace(“a1”，“a2”)：用a2替换a1。</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”JAVA--SringBuffer和StringBudilder“</title>
    <link href="/2022/02/09/JAVA-SringBuffer%E5%92%8CStringBudilder/"/>
    <url>/2022/02/09/JAVA-SringBuffer%E5%92%8CStringBudilder/</url>
    
    <content type="html"><![CDATA[<p>这两个都是可变字符串.</p><span id="more"></span><p><strong>StringBuffer</strong>：</p><p>StringBuffer str = new StringBuffer();</p><p>可以使用append在后面追加字符串，用insert增加字符串</p><p>insert（“0”，str）在第0个字符的前面增加字符串str。</p><p><strong>用replace来更改指定位置字符：</strong></p><p>replace(“0”，“5”，str)把0-5之间的字符替换为str。</p><p>用<strong>delete删除指定位置的字符：</strong></p><p>delete（“0”，“5”）删除0-5之间的字符串。</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”JAVA--拆箱和装箱，字符串数字转换“</title>
    <link href="/2022/02/09/JAVA-%E6%8B%86%E7%AE%B1%E5%92%8C%E8%A3%85%E7%AE%B1%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2/"/>
    <url>/2022/02/09/JAVA-%E6%8B%86%E7%AE%B1%E5%92%8C%E8%A3%85%E7%AE%B1%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>数据类型（int，float等等）存放在栈里面。</p><p>引用类型（Integer，Float等等）存放在堆里面 。</p><span id="more"></span><p>装箱就是 Java 将基本类型转换成对应的包装类型，比如将 int 转换成 Integer 对象。反之将 Integer 转换成 int 值，则称为拆箱。</p><p><strong>装箱:</strong></p><p>int num = 20;</p><p>Integer integer1 = num;</p><p>如上这样就可以实现装箱使int成为integer了。</p><p><strong>拆箱：</strong></p><p>int num2=integer;</p><p>这样就可以拆箱。</p><p>integer的范围是-128——127之间，超过这个范围会溢出</p><p><strong>字符串和数字之间的转换：</strong></p><p>int num = 20;</p><p>Integer integer = num;</p><p>String s = integer.tostring(num，10)//这里解释一下，tostring括号里面的num是要转换为字符串的数字，后面的10是转换为10进制的，当然也可以变成8/16转换成八进制十六进制。</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”JAVA--方法盘点“</title>
    <link href="/2022/02/09/JAVA-%E6%96%B9%E6%B3%95%E7%9B%98%E7%82%B9/"/>
    <url>/2022/02/09/JAVA-%E6%96%B9%E6%B3%95%E7%9B%98%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>介绍四个方法</p><span id="more"></span><p><strong>getCalss()方法：</strong></p><p>1.使用方法:<strong>对象.getClass()</strong>;</p><p>2.有什么用：返回对象的内容，比如这个对象是A类的，那就返回A类给getClass()，返回的值是Class类型的。</p><p><strong>hashcode()方法：</strong></p><p>1.使用方法:<strong>对象.hashcode()</strong>;</p><p>2.返回一个值，哈希码的值实际上是对象的地址或者字符串之类的，所以相同对象返回相同哈希码。</p><p><strong>toString()方法</strong>：</p><p>1.其实也就是返回getclass和hashcode的合体，但是哈希值是十六进制的。</p><p>qeual方法：</p><p>return(this == 一个类对象)</p><p>System.out.println(s1.equal(s2)) #判断s1和s2对象是否相等。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/017447037a9afaba91fed9ca66807b05.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”JAVA--捕获异常“</title>
    <link href="/2022/02/09/JAVA-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8/"/>
    <url>/2022/02/09/JAVA-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<p> 捕获异常的知识点</p><span id="more"></span><p><img src="https://img-blog.csdnimg.cn/img_convert/9e2b02acb699d3e3244694956cb154e7.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>这个代码中b等于0，所以会报错，错误类型为ArithmeException，我们使用catch关键字可以捕获这个异常，并且输出语句，最后再用finally处理最后。</p><p>假设要捕获多个异常，从大到小。</p><p>抛出异常：（用throw 关键字抛出new一个新异常）</p><p><img src="https://img-blog.csdnimg.cn/img_convert/29d685470b9578cce9bfcfcd70d0c61f.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”JAVA--外部类和内部类“</title>
    <link href="/2022/02/09/JAVA-%E5%A4%96%E9%83%A8%E7%B1%BB%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <url>/2022/02/09/JAVA-%E5%A4%96%E9%83%A8%E7%B1%BB%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p> 介绍外部类和内部类</p><span id="more"></span><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">package</span> bilibili;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Oouter</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inter</span> </span>&#123;<br>        Inter() &#123;<br>            System.out.println(<span class="hljs-string">&quot;这是内部类&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        Oouter oouter = <span class="hljs-keyword">new</span> <span class="hljs-type">Oouter</span>();<br>        Oouter.Inter inter = oouter.<span class="hljs-keyword">new</span> <span class="hljs-type">Inter</span>();<span class="hljs-comment">//这里最最重要</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment">-----------------------------------------------------------------------------</span><br>内部类的概念：在一个类的内部再定义一个完整的类，内部类也会生成<span class="hljs-built_in">class</span>文件。但是有$符号。<br></code></pre></td></tr></table></figure><p>1.声明内部类的对象的方法是：</p><p><strong>外部类名(点)内部类名(空格)内部类对象 = 外部类对象(点)new(空格)内部类名（）；</strong></p><p>比如现在<strong>外部类名Outer，内部类名Inter，外部类对象outer，内部类对象inter</strong>，则：</p><p>Outer.Inter inter = outer.new Inter();</p><p>内部类可以调用外部类的私有属性，当然也可以调用外部私有方法，但是当内部类加上了static后就不能调用外部类的private属性了。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-title">a</span>()</span>&#123;<br>    <span class="hljs-built_in">int</span> a = <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Inter</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(a());<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;这是内部类&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-number">2.</span>局部内部类：在方法里面定义类；<br><br><br><span class="hljs-number">3.</span>匿名内部类：没有名字的类：<br>假设我们有一个类Apple，Apple里面有一个<span class="hljs-keyword">a</span>方法，我们可以先不对Apple进行实例化，直接使用<span class="hljs-built_in">new</span> Apple().<span class="hljs-keyword">a</span>()来调用<span class="hljs-keyword">a</span>方法.<br>匿名内部类一般用在接口或者父类当中。<br>匿名内部类必须在声明对象之后，然后在后面可以调用该匿名内部类的方法，该内部类是匿名的，然后要用声明的对象的名字。<br>匿名内部类必须继承父类或者实现一个接口。<br></code></pre></td></tr></table></figure><p>4.静态内部类：不依赖外部类，可直接创建或通过类名访问，可声明静态成员。</p><p><strong>特点：</strong></p><p>1.在内部类中可以调用内部类的私有方法，但是调用外部类的私有方法用（外部类的对象）.私有名字。</p><p>2.只有外部类可以是静态的，内部类不行。</p><p>3.内部类想要访问局部变量，需要局部变量是final修饰的（局部变量即方法里面定义的变量）</p><p>4.内部类也可以继承接口用implements</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”JAVA--接口interface“</title>
    <link href="/2022/02/09/JAVA-%E6%8E%A5%E5%8F%A3interface/"/>
    <url>/2022/02/09/JAVA-%E6%8E%A5%E5%8F%A3interface/</url>
    
    <content type="html"><![CDATA[<p> 1.接口只有规范，无法写方法，是专业的抽象。实现约束和实现分离，面向接口编程。</p><span id="more"></span><p>2.接口就是规范，约束了编程的行为</p><p>写一个接口：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">jiekou</span> &#123;<span class="hljs-comment">//这是一个接口，下面实行增删改查</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delete</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">select</span>()</span>;<br>    <span class="hljs-comment">//上面的四个方法都是在接口里面的方法，固定为抽象方法，抽象的abstract可以省略，直接用返回值+方法名来定义方法即可；</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>（抽象）类只能单继承，但是接口可以多继承，这就是接口的好处；</p><p>继承接口用关键字implement，格式为：class+类名+implement+接口名{}</p><p>实现了接口中的类就要重写接口中的方法，接口的多继承用逗号连接实现。</p><p>接口的作用</p><p><img src="https://img-blog.csdnimg.cn/9ec1434941764960bada7de63fcf34be.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>”JAVA--抽象类“</title>
    <link href="/2022/02/09/JAVA-%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <url>/2022/02/09/JAVA-%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>抽象类的作用：如果我们不想在方法中写内容就用抽象类：abstract;</p><span id="more"></span><p>1.当子类继承的父类当中有抽象的方法时，子类必须要重写抽象方法</p><p>2.java里面的类是单继承的，但是接口时多继承的</p><p>3.不能new抽象类，只能靠子类去实现它（约束）</p><p>4.抽象方法必须在抽象类里面</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA--static关键字知识点</title>
    <link href="/2022/02/09/JAVA-static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2022/02/09/JAVA-static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>1.有static修饰的属性就不用声明对象了，直接用类名去.属性</p><span id="more"></span><p>2.非静态方法能直接调用静态方法，但是静态方法不能调用非静态方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GG</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span>  <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>)&#123;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">B</span>(<span class="hljs-params"></span>)&#123;<br><br>    &#125;<br><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> 静态 &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-variable constant_">GG</span>.<span class="hljs-title function_">A</span>();<span class="hljs-comment">//不可行，因为A方法是非静态的</span><br>        <span class="hljs-variable constant_">GG</span>.<span class="hljs-title function_">B</span>();<span class="hljs-comment">//可行，因为B是静态的</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>介绍一些奇葩的代码块：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">QIPA</span> &#123;<br>    &#123;<span class="hljs-comment">//作用：赋初值；</span><br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;匿名代码块&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<span class="hljs-comment">//作用：只能执行一次</span><br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;static代码块&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">QIPA</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;普通的代码块&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        QIPA qipa = <span class="hljs-keyword">new</span> QIPA();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/2a0caa983f3c4678bad9caf60fa4296e.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> 先执行static代码块，再执行匿名的代码块，在执行普通的代码块。（static代码块即使不定义对象也可以执行）</p><p>天秀操作：静态导入包（如我们想生成随机数）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.math;<span class="hljs-comment">//正常来说到这一步就不能往下了</span><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.math.random;<span class="hljs-comment">//加个static就可以到下一步了，这叫静态调用包</span><br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>子类不能继承被final继承的父类！</strong></p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA--多态</title>
    <link href="/2022/02/09/JAVA-%E5%A4%9A%E6%80%81/"/>
    <url>/2022/02/09/JAVA-%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<p><strong>如果子类没有重写父类方法，就调用父类的。</strong></p><p><strong>如果子类重写了父类，就算左边是父类，也是调用子类的重写方法。</strong></p><p><strong>调用父类时，可以调用子类中的重写方法，但是不能调用子类中独有的方法！！！</strong></p><span id="more"></span><p>对象执行哪些方法主要看左边，和右边关系不大<img src="https://img-blog.csdnimg.cn/9e24d298f81a470e90e67d4007b4f523.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARG9wYWdpcA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>多态的注意事项：</p><p>1.多态是方法的多态，属性没有多态；</p><p>\2. 父类和子类之间有联系 离谱的类型转换肯定报错（如String转Person方法）类型转换异常：ClassCastException.</p><p>3.方法可以转换，同样遵循低转高原则（子类是低，父类是高），如果要高转低的话可以（子类）+方法名来实现。</p><p>4.存在条件：继承关系，方法需要重写，父类的引用指向子类（即在声明对象的时候父类在左边，子类在右边）</p><p>##但是有些方法是不能重写的：</p><p>1.static方法：属于类，不属于实例</p><p>2.final属性</p><p>3.private方法是私有的，当然重写了也没用</p><p>instanceof （类型转换） 引用类型</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA--方法重写</title>
    <link href="/2022/02/09/JAVA-%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99/"/>
    <url>/2022/02/09/JAVA-%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99/</url>
    
    <content type="html"><![CDATA[<p>方法的调用只和左边有关，即A a/B b</p><span id="more"></span><p><img src="https://img-blog.csdnimg.cn/e3ae7194364e47b2b5dd489751a7ae95.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFfNTI1OTk4NzA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>方法的重写不要用static，</p><p><img src="https://img-blog.csdnimg.cn/74ba5f5219e542c88cbe7cfa66795b61.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFfNTI1OTk4NzA=,size_13,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>因为b是A new出来的对象，因此调用了A的方法</strong></p><p><strong>因为静态方法是类的方法，而非静态是对象的方法</strong></p><p><strong>有static时，b调用了B类的方法，因为b是用b类定义的</strong></p><p><strong>没有static时，b调用的是对象的方法，而b是用A类new的</strong></p><p><strong>简单来说就是有static调用后面，没有static调用前面。</strong></p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA--super知识点</title>
    <link href="/2022/02/09/JAVA-super%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2022/02/09/JAVA-super%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>1.Super指向父类的构造方法，必须在构造方法的第一个；</p><p>2.Super只能出现在子类的构造方法中.</p><span id="more"></span><p>3.this和super不能同时调用构造方法</p><p>与this的对比：<br>this：本类的构造；super：父类的构造</p><p>this：没有继承也可以使用；super：必须要有继承才可以使用</p><p>this：调用本身对象；super：调用父类对象</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA--继承</title>
    <link href="/2022/02/09/JAVA-%E7%BB%A7%E6%89%BF/"/>
    <url>/2022/02/09/JAVA-%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<p>1.extend的意思是’’拓展，扩大’’,子类是对父类的拓展。</p><span id="more"></span><p><img src="https://img-blog.csdnimg.cn/5d39b5ad4d0c474a818fe81179381fc9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFfNTI1OTk4NzA=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>如teacher is a person.</p><p><strong>子类不能继承父类的private属性或者方法！</strong></p><p>ctrl+H可以打开继承面板</p><p>2.Object！</p><p>在Java中所有的类都默认继承Object类！！！</p><p>例：public class AA /<em>entend Object</em>/{}</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA--封装</title>
    <link href="/2022/02/09/JAVA-%E5%B0%81%E8%A3%85/"/>
    <url>/2022/02/09/JAVA-%E5%B0%81%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p>1.<strong>高内聚，低耦合：</strong>程序内部的操作细节由自己或者内部人员完成，仅仅暴露少量内容给外部人员。</p><span id="more"></span><p>2.get/set 方法最重要：用get方法获得该值，用set方法给该值赋予数值,因为你的属性被private限制住了，只能通过其他方法输出。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">AA</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> a=<span class="hljs-number">20</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">geta</span>()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">seta</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a</span>)</span>&#123;<br>        <span class="hljs-keyword">this</span>.a=a;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">getset</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span>&#123;<br>        AA aa = <span class="hljs-keyword">new</span> AA();<br>        <span class="hljs-comment">//System.out.println(aa.a);这样写是错的，因为属性a被private限制了，只能在AA类中使用</span><br>        <span class="hljs-comment">//这时候就要使用set和get函数了</span><br>        aa.seta(<span class="hljs-number">50</span>);<span class="hljs-comment">//这一步用来设置a的值</span><br>        System.<span class="hljs-keyword">out</span>.println(aa.geta());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>封装的作用：</p><p>1.提高程序的安全性，保护程序</p><p>2.统一接口（唯一接口只有get/set）</p><p>3.隐藏代码实现细节</p><p>4.系统的可维护性增加</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA--面向对象知识点总结</title>
    <link href="/2022/02/09/JAVA-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <url>/2022/02/09/JAVA-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>有关面向对象知识点的总结</p><span id="more"></span><p>1.类与对象：</p><p>类是一个模板（抽象），对象是一个具体的实例（具体化）<br>2.方法：<br>定义、调用<br>3.对应的引用<br>引用类型:基本类型 (8)<br>对象是通过引用来操作的:栈—&gt;堆<br>4.属性:字段Field 成员变量<br><strong>默认初始化:</strong><br>数字: 0 和 0.0<br>char : u0000<br>boolean: false<br>引用: null<br>修饰符属性类型 属性名。属性值!<br>5.对象的创建和使用(属性就是变量的意思)<br>必须使用new关键字创造对象，构造器 Person my = new Person();<br>-对象的属性my. name<br>-对象的方法my. sleep()</p><p>6.类：<br>静态的定义：属性</p><p>动态的定义：方法</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA--构造器</title>
    <link href="/2022/02/09/JAVA-%E6%9E%84%E9%80%A0%E5%99%A8/"/>
    <url>/2022/02/09/JAVA-%E6%9E%84%E9%80%A0%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p> 定义一个构造器：（构造方法必须没有返回值）</p><span id="more"></span><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Person</span>&#123;<br>    <span class="hljs-keyword">public</span> Person()&#123;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">void</span> <span class="hljs-symbol">main</span>(<span class="hljs-symbol">String</span>[] <span class="hljs-symbol">args</span>)&#123;<br>    Person person = new Person();<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>1.在类里面即使你什么都不写，都会存在一个构造器.</p><p>2.当我们在用new关键字创建一个新对象的时候，<strong>对象调用的一定是方法，而不是调用类！！这就是为什么即使什么都不写依然会存在一个构造器的原因，因为要定义一个对象就一定需要构造器！简单理解为使用new创建对象的本质就是在调用构造器。</strong></p><p><strong>举个例子：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br><span class="hljs-comment">//还是刚才那个构造器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-type">String</span> st;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.st = <span class="hljs-string">&quot;OK!&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span></span>&#123;<br>    Person person = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>();<br>    System.out.<span class="hljs-built_in">println</span>(person.st);<br>    <span class="hljs-comment">//这里会输出OK！而不是NULL了，因为对象调用的是方法person而person已经定义了st为&quot;OK!&quot;</span><br>&#125;<br><br><br><br><br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>上面我们说的是无参数的构造器，下面我们来介绍有参数的构造器。</p><p>有参构造，一旦有了有参构造，无参构造就必须显式定义，什么意思呢，下面来解释：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><br><span class="hljs-comment">//还是刚才那个构造器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&#123;<br>    String st;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>()</span>&#123;<br>        <span class="hljs-keyword">this</span>.st = <span class="hljs-string">&quot;不OK!&quot;</span><br>&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a</span>)</span>&#123;<br>        <span class="hljs-keyword">this</span>.st = <span class="hljs-string">&quot;OK!&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span>&#123;<br>    Person person1 = <span class="hljs-keyword">new</span> Person();<span class="hljs-comment">//这里调用的是无参构造。</span><br>    Person person2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-number">20</span>);<span class="hljs-comment">//这里调用的是有参构造。</span><br>    <span class="hljs-comment">//当然，你的对象名也不能相同，否则会报错。</span><br>&#125;<br><br><br><br><br><br><br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>无参构造是什么意思：就是在构造器中不加参数的。</p><p>显式定义是什么意思：就是即使方法里面什么东西都没有你也要把该方法写出来。</p><p><strong>其实构造器最大的作用就是初始化值！</strong></p><p><strong>快捷键：在IDEA里面Alt+Insert 快速建立构造器！</strong></p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA--数组（基础）</title>
    <link href="/2022/02/09/JAVA-%E6%95%B0%E7%BB%84%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/"/>
    <url>/2022/02/09/JAVA-%E6%95%B0%E7%BB%84%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p> <strong>有关数组的基础知识</strong></p><span id="more"></span><p><strong>两种给数组赋值的方法：</strong><br> 1.静态初始化：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> num[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;;<br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>这个的意思是在声明数组的过程中顺便给数组赋了值，称为静态初始化。但是这个静态初始化赋予数组的值并不是固定的，在后面也可以对其中一个元素进行变更。</p><p>2.动态初始化：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int num[] <span class="hljs-operator">=</span> new int[<span class="hljs-number">5</span>]<span class="hljs-comment">;</span><br>num[<span class="hljs-number">0</span>] <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>num[<span class="hljs-number">1</span>] <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-comment">;</span><br>num[<span class="hljs-number">2</span>] <span class="hljs-operator">=</span> <span class="hljs-number">3</span><span class="hljs-comment">;</span><br>num[<span class="hljs-number">3</span>] <span class="hljs-operator">=</span> <span class="hljs-number">4</span><span class="hljs-comment">;</span><br>num[<span class="hljs-number">4</span>] <span class="hljs-operator">=</span> <span class="hljs-number">5</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>像这样先使用</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span>[] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>对数组num进行声明和创建（注意，这里数组的下标最多到达4，不能到5，因为是从0开始的，如果到达了5会运行错误，显示数组下标溢出）,然后在下面的代码中对num进行赋值。</p><p>数组越界异常警报是这样的：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Array</span> <span class="hljs-keyword">Index</span> <span class="hljs-keyword">Out</span> <span class="hljs-keyword">Of</span> Bounds <span class="hljs-keyword">Exception</span>:数组下标越界<br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>数组的四个基本特点：</strong></p><p>1.数组的长度是确定的，一旦数组被确定，它的长度就不能被更改。</p><p>2.数组的内容可以是所有的类型（基本类型和引用类型都可以），但是数组不能是多种类型的混合，只能是单独一种类型。</p><p>3.数组本身是在堆当中的。</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客的基本操作</title>
    <link href="/2022/02/09/hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/02/09/hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>hexo clean 清除缓存</p><p>hexo n “…” 生成博客文章，标题是…</p><span id="more"></span><p>hexo s   start博客，默认启动在localhost:4000端口</p><p>hexo d   部署到远端</p><p>当写完博客之后通常使用这三个：（依次输入）</p><p>hexo clean </p><p>hexo g</p><p>hexo d</p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
